from __future__ import annotations
import dartpy.collision
import dartpy.dynamics
import dartpy.math
import numpy
import typing
__all__: list[str] = ['BallJointConstraint', 'BoxedLcpConstraintSolver', 'BoxedLcpSolver', 'ConstraintBase', 'ConstraintSolver', 'DantzigBoxedLcpSolver', 'DynamicJointConstraint', 'JointConstraint', 'JointCoulombFrictionConstraint', 'PgsBoxedLcpSolver', 'PgsBoxedLcpSolverOption', 'RevoluteJointConstraint', 'WeldJointConstraint']
class BallJointConstraint(DynamicJointConstraint):
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self, body: dartpy.dynamics.BodyNode, jointPos: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    @typing.overload
    def __init__(self, body1: dartpy.dynamics.BodyNode, body2: dartpy.dynamics.BodyNode, jointPos: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
class RevoluteJointConstraint(DynamicJointConstraint):
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self, body: dartpy.dynamics.BodyNode, jointPos: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    @typing.overload
    def __init__(self, body1: dartpy.dynamics.BodyNode, body2: dartpy.dynamics.BodyNode, jointPos: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], axis1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], axis2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
class BoxedLcpConstraintSolver(ConstraintSolver):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, boxedLcpSolver: BoxedLcpSolver) -> None:
        ...
    @typing.overload
    def __init__(self, boxedLcpSolver: BoxedLcpSolver, secondaryBoxedLcpSolver: BoxedLcpSolver) -> None:
        ...
    def getBoxedLcpSolver(self) -> BoxedLcpSolver:
        ...
    def setBoxedLcpSolver(self, lcpSolver: BoxedLcpSolver) -> None:
        ...
class BoxedLcpSolver:
    def getType(self) -> str:
        ...
    def solve(self, n: int, A: float, x: float, b: float, nub: int, lo: float, hi: float, findex: int) -> None:
        ...
class ConstraintBase:
    @staticmethod
    def compressPath(skeleton: dartpy.dynamics.Skeleton) -> dartpy.dynamics.Skeleton:
        ...
    @staticmethod
    def getRootSkeletonOf(skeleton: dartpy.dynamics.Skeleton) -> dartpy.dynamics.Skeleton:
        ...
    def applyImpulse(self, lambda: float) -> None:
        ...
    def applyUnitImpulse(self, index: int) -> None:
        ...
    def excite(self) -> None:
        ...
    def getDimension(self) -> int:
        ...
    def getInformation(self, info: ...) -> None:
        ...
    def getRootSkeleton(self) -> dartpy.dynamics.Skeleton:
        ...
    def getType(self) -> str:
        ...
    def getVelocityChange(self, vel: float, withCfm: bool) -> None:
        ...
    def isActive(self) -> bool:
        ...
    def unexcite(self) -> None:
        ...
    def uniteSkeletons(self) -> None:
        ...
    def update(self) -> None:
        ...
class ConstraintSolver:
    def addConstraint(self, constraint: ConstraintBase) -> None:
        ...
    def addSkeleton(self, skeleton: dartpy.dynamics.Skeleton) -> None:
        ...
    def addSkeletons(self, skeletons: ..., std: ...) -> None:
        ...
    def clearLastCollisionResult(self) -> None:
        ...
    @typing.overload
    def getCollisionDetector(self) -> dartpy.collision.CollisionDetector:
        ...
    @typing.overload
    def getCollisionDetector(self) -> dartpy.collision.CollisionDetector:
        ...
    @typing.overload
    def getCollisionGroup(self) -> dartpy.collision.CollisionGroup:
        ...
    @typing.overload
    def getCollisionGroup(self) -> dartpy.collision.CollisionGroup:
        ...
    @typing.overload
    def getCollisionOption(self) -> dartpy.collision.CollisionOption:
        """
        Returns collision option that is used for collision checkings in this ConstraintSolver to generate contact constraints.
        """
    @typing.overload
    def getCollisionOption(self) -> dartpy.collision.CollisionOption:
        """
        Returns collision option that is used for collision checkings in this ConstraintSolver to generate contact constraints.
        """
    @typing.overload
    def getConstraint(self, index: int) -> ConstraintBase:
        ...
    @typing.overload
    def getConstraint(self, index: int) -> ConstraintBase:
        ...
    @typing.overload
    def getNumConstraints(self) -> bool:
        ...
    @typing.overload
    def getNumConstraints(self) -> bool:
        ...
    def getTimeStep(self) -> float:
        ...
    def removeAllConstraints(self) -> None:
        ...
    def removeAllSkeletons(self) -> None:
        ...
    def removeConstraint(self, constraint: ConstraintBase) -> None:
        ...
    def removeSkeleton(self, skeleton: dartpy.dynamics.Skeleton) -> None:
        ...
    def removeSkeletons(self, skeletons: ..., std: ...) -> None:
        ...
    def setCollisionDetector(self, collisionDetector: dartpy.collision.CollisionDetector) -> None:
        ...
    def setTimeStep(self, timeStep: float) -> None:
        ...
    def solve(self) -> None:
        ...
class DantzigBoxedLcpSolver(BoxedLcpSolver):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getType(self) -> str:
        ...
    def solve(self, n: int, A: float, x: float, b: float, nub: int, lo: float, hi: float, findex: int, earlyTermination: bool) -> bool:
        ...
class DynamicJointConstraint(ConstraintBase):
    @staticmethod
    def getConstraintForceMixing() -> float:
        ...
    @staticmethod
    def getErrorAllowance() -> float:
        ...
    @staticmethod
    def getErrorReductionParameter() -> float:
        ...
    @staticmethod
    def getMaxErrorReductionVelocity() -> float:
        ...
    @staticmethod
    def setConstraintForceMixing(cfm: float) -> None:
        ...
    @staticmethod
    def setErrorAllowance(allowance: float) -> None:
        ...
    @staticmethod
    def setErrorReductionParameter(erp: float) -> None:
        ...
    @staticmethod
    def setMaxErrorReductionVelocity(erv: float) -> None:
        ...
class JointConstraint(ConstraintBase):
    @staticmethod
    def getConstraintForceMixing() -> float:
        ...
    @staticmethod
    def getErrorAllowance() -> float:
        ...
    @staticmethod
    def getErrorReductionParameter() -> float:
        ...
    @staticmethod
    def getMaxErrorReductionVelocity() -> float:
        ...
    @staticmethod
    def setConstraintForceMixing(cfm: float) -> None:
        ...
    @staticmethod
    def setErrorAllowance(allowance: float) -> None:
        ...
    @staticmethod
    def setErrorReductionParameter(erp: float) -> None:
        ...
    @staticmethod
    def setMaxErrorReductionVelocity(erv: float) -> None:
        ...
    def __init__(self, joint: dartpy.dynamics.Joint) -> None:
        ...
class JointCoulombFrictionConstraint(ConstraintBase):
    @staticmethod
    def getConstraintForceMixing() -> float:
        ...
    @staticmethod
    def setConstraintForceMixing(cfm: float) -> None:
        ...
    def __init__(self, joint: dartpy.dynamics.Joint) -> None:
        ...
class PgsBoxedLcpSolver(BoxedLcpSolver):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getType(self) -> str:
        ...
    def setOption(self, option: PgsBoxedLcpSolverOption) -> None:
        ...
    def solve(self, n: int, A: float, x: float, b: float, nub: int, lo: float, hi: float, findex: int, earlyTermination: bool) -> bool:
        ...
class PgsBoxedLcpSolverOption:
    mDeltaXThreshold: float
    mEpsilonForDivision: float
    mMaxIteration: int
    mRandomizeConstraintOrder: bool
    mRelativeDeltaXTolerance: float
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, maxIteration: int) -> None:
        ...
    @typing.overload
    def __init__(self, maxIteration: int, deltaXTolerance: float) -> None:
        ...
    @typing.overload
    def __init__(self, maxIteration: int, deltaXTolerance: float, relativeDeltaXTolerance: float) -> None:
        ...
    @typing.overload
    def __init__(self, maxIteration: int, deltaXTolerance: float, relativeDeltaXTolerance: float, epsilonForDivision: float) -> None:
        ...
    @typing.overload
    def __init__(self, maxIteration: int, deltaXTolerance: float, relativeDeltaXTolerance: float, epsilonForDivision: float, randomizeConstraintOrder: bool) -> None:
        ...
class WeldJointConstraint(DynamicJointConstraint):
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self, body: dartpy.dynamics.BodyNode) -> None:
        ...
    @typing.overload
    def __init__(self, body1: dartpy.dynamics.BodyNode, body2: dartpy.dynamics.BodyNode) -> None:
        ...
    def setRelativeTransform(self, tf: dartpy.math.Isometry3) -> None:
        ...
