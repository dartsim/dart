from __future__ import annotations
import dartpy.collision
import dartpy.dynamics
import dartpy.math
import numpy
import typing
__all__: list[str] = ['BallJointConstraint', 'ConstraintBase', 'ConstraintSolver', 'ContactManifoldCacheOptions', 'DynamicJointConstraint', 'JointConstraint', 'JointCoulombFrictionConstraint', 'RevoluteJointConstraint', 'WeldJointConstraint']
class BallJointConstraint(DynamicJointConstraint):
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self, body: dartpy.dynamics.BodyNode, jointPos: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    @typing.overload
    def __init__(self, body1: dartpy.dynamics.BodyNode, body2: dartpy.dynamics.BodyNode, jointPos: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
class RevoluteJointConstraint(DynamicJointConstraint):
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self, body: dartpy.dynamics.BodyNode, jointPos: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    @typing.overload
    def __init__(self, body1: dartpy.dynamics.BodyNode, body2: dartpy.dynamics.BodyNode, jointPos: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], axis1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], axis2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
class ConstraintBase:
    @staticmethod
    def compressPath(skeleton: dartpy.dynamics.Skeleton) -> dartpy.dynamics.Skeleton:
        ...
    @staticmethod
    def getRootSkeletonOf(skeleton: dartpy.dynamics.Skeleton) -> dartpy.dynamics.Skeleton:
        ...
    def applyImpulse(self, lambda: float) -> None:
        ...
    def applyUnitImpulse(self, index: int) -> None:
        ...
    def excite(self) -> None:
        ...
    def getDimension(self) -> int:
        ...
    def getInformation(self, info: ...) -> None:
        ...
    def getRootSkeleton(self) -> dartpy.dynamics.Skeleton:
        ...
    def getType(self) -> str:
        ...
    def getVelocityChange(self, vel: float, withCfm: bool) -> None:
        ...
    def isActive(self) -> bool:
        ...
    def unexcite(self) -> None:
        ...
    def uniteSkeletons(self) -> None:
        ...
    def update(self) -> None:
        ...
class ContactManifoldCacheOptions:
    depthEpsilon: float
    enabled: bool
    maxPairs: int
    maxPointsPerPair: int
    maxSeparationFrames: int
    normalThreshold: float
    positionThreshold: float
    def __init__(self) -> None:
        ...
class ConstraintSolver:
    def addConstraint(self, constraint: ConstraintBase) -> None:
        ...
    def addSkeleton(self, skeleton: dartpy.dynamics.Skeleton) -> None:
        ...
    def addSkeletons(self, skeletons: ..., std: ...) -> None:
        ...
    def clearLastCollisionResult(self) -> None:
        ...
    @typing.overload
    def getCollisionDetector(self) -> dartpy.collision.CollisionDetector:
        ...
    @typing.overload
    def getCollisionDetector(self) -> dartpy.collision.CollisionDetector:
        ...
    @typing.overload
    def getCollisionGroup(self) -> dartpy.collision.CollisionGroup:
        ...
    @typing.overload
    def getCollisionGroup(self) -> dartpy.collision.CollisionGroup:
        ...
    @typing.overload
    def getCollisionOption(self) -> dartpy.collision.CollisionOption:
        """
        Returns collision option that is used for collision checkings in this ConstraintSolver to generate contact constraints.
        """
    @typing.overload
    def getCollisionOption(self) -> dartpy.collision.CollisionOption:
        """
        Returns collision option that is used for collision checkings in this ConstraintSolver to generate contact constraints.
        """
    def getContactManifoldCacheOptions(self) -> ContactManifoldCacheOptions:
        ...
    def getContactsUsedForConstraints(self) -> list[dartpy.collision.Contact]:
        ...
    def getNumContactConstraints(self) -> int:
        ...
    def getNumContactManifolds(self) -> int:
        ...
    def getNumPersistentContacts(self) -> int:
        ...
    def getNumSoftContactConstraints(self) -> int:
        ...
    @typing.overload
    def getConstraint(self, index: int) -> ConstraintBase:
        ...
    @typing.overload
    def getConstraint(self, index: int) -> ConstraintBase:
        ...
    @typing.overload
    def getNumConstraints(self) -> bool:
        ...
    @typing.overload
    def getNumConstraints(self) -> bool:
        ...
    def getTimeStep(self) -> float:
        ...
    def isContactManifoldCacheEnabled(self) -> bool:
        ...
    def removeAllConstraints(self) -> None:
        ...
    def removeAllSkeletons(self) -> None:
        ...
    def removeConstraint(self, constraint: ConstraintBase) -> None:
        ...
    def removeSkeleton(self, skeleton: dartpy.dynamics.Skeleton) -> None:
        ...
    def removeSkeletons(self, skeletons: ..., std: ...) -> None:
        ...
    def setCollisionDetector(self, collisionDetector: dartpy.collision.CollisionDetector) -> None:
        ...
    def setContactManifoldCacheEnabled(self, enabled: bool) -> None:
        ...
    def setContactManifoldCacheOptions(self, options: ContactManifoldCacheOptions) -> None:
        ...
    def setTimeStep(self, timeStep: float) -> None:
        ...
    def solve(self) -> None:
        ...
class DynamicJointConstraint(ConstraintBase):
    @staticmethod
    def getConstraintForceMixing() -> float:
        ...
    @staticmethod
    def getErrorAllowance() -> float:
        ...
    @staticmethod
    def getErrorReductionParameter() -> float:
        ...
    @staticmethod
    def getMaxErrorReductionVelocity() -> float:
        ...
    @staticmethod
    def setConstraintForceMixing(cfm: float) -> None:
        ...
    @staticmethod
    def setErrorAllowance(allowance: float) -> None:
        ...
    @staticmethod
    def setErrorReductionParameter(erp: float) -> None:
        ...
    @staticmethod
    def setMaxErrorReductionVelocity(erv: float) -> None:
        ...
class JointConstraint(ConstraintBase):
    @staticmethod
    def getConstraintForceMixing() -> float:
        ...
    @staticmethod
    def getErrorAllowance() -> float:
        ...
    @staticmethod
    def getErrorReductionParameter() -> float:
        ...
    @staticmethod
    def getMaxErrorReductionVelocity() -> float:
        ...
    @staticmethod
    def setConstraintForceMixing(cfm: float) -> None:
        ...
    @staticmethod
    def setErrorAllowance(allowance: float) -> None:
        ...
    @staticmethod
    def setErrorReductionParameter(erp: float) -> None:
        ...
    @staticmethod
    def setMaxErrorReductionVelocity(erv: float) -> None:
        ...
    def __init__(self, joint: dartpy.dynamics.Joint) -> None:
        ...
class JointCoulombFrictionConstraint(ConstraintBase):
    @staticmethod
    def getConstraintForceMixing() -> float:
        ...
    @staticmethod
    def setConstraintForceMixing(cfm: float) -> None:
        ...
    def __init__(self, joint: dartpy.dynamics.Joint) -> None:
        ...
class WeldJointConstraint(DynamicJointConstraint):
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self, body: dartpy.dynamics.BodyNode) -> None:
        ...
    @typing.overload
    def __init__(self, body1: dartpy.dynamics.BodyNode, body2: dartpy.dynamics.BodyNode) -> None:
        ...
    def setRelativeTransform(self, tf: dartpy.math.Isometry3) -> None:
        ...
