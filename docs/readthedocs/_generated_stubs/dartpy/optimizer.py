from __future__ import annotations
import numpy
import typing
__all__: list[str] = ['Function', 'GradientDescentSolver', 'GradientDescentSolverProperties', 'GradientDescentSolverUniqueProperties', 'ModularFunction', 'MultiFunction', 'NullFunction', 'Problem', 'Solver', 'SolverProperties']
M = typing.TypeVar("M", bound=int)
class Function:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, name: str) -> None_:
        ...
    def getName(self) -> str:
        ...
    def setName(self, newName: str) -> None_:
        ...
class GradientDescentSolver(Solver):
    Type: typing.ClassVar[str] = 'GradientDescentSolver'
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, properties: GradientDescentSolverProperties) -> None_:
        ...
    @typing.overload
    def __init__(self, problem: ...) -> None_:
        ...
    def clampToBoundary(self, x: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def clone(self) -> Solver:
        ...
    def getDefaultConstraintWeight(self) -> float:
        ...
    def getGradientDescentProperties(self) -> GradientDescentSolverProperties:
        ...
    def getLastConfiguration(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getLastNumIterations(self) -> int:
        ...
    def getMaxAttempts(self) -> int:
        ...
    def getMaxPerturbationFactor(self) -> float:
        ...
    def getPerturbationStep(self) -> int:
        ...
    def getStepSize(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def randomizeConfiguration(self, x: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setDefaultConstraintWeight(self, newDefault: float) -> None_:
        ...
    def setMaxAttempts(self, maxAttempts: int) -> None_:
        ...
    def setMaxPerturbationFactor(self, factor: float) -> None_:
        ...
    def setPerturbationStep(self, step: int) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GradientDescentSolverProperties) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GradientDescentSolverUniqueProperties) -> None_:
        ...
    def setStepSize(self, newMultiplier: float) -> None_:
        ...
    def solve(self) -> bool:
        ...
class GradientDescentSolverProperties(SolverProperties, GradientDescentSolverUniqueProperties):
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, solverProperties: SolverProperties) -> None_:
        ...
    @typing.overload
    def __init__(self, solverProperties: SolverProperties, descentProperties: GradientDescentSolverUniqueProperties) -> None_:
        ...
class GradientDescentSolverUniqueProperties:
    mDefaultConstraintWeight: float
    mEqConstraintWeights: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]
    mIneqConstraintWeights: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]
    mMaxAttempts: int
    mMaxPerturbationFactor: float
    mMaxRandomizationStep: float
    mPerturbationStep: int
    mStepSize: float
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, stepMultiplier: float) -> None_:
        ...
    @typing.overload
    def __init__(self, stepMultiplier: float, maxAttempts: int) -> None_:
        ...
    @typing.overload
    def __init__(self, stepMultiplier: float, maxAttempts: int, perturbationStep: int) -> None_:
        ...
    @typing.overload
    def __init__(self, stepMultiplier: float, maxAttempts: int, perturbationStep: int, maxPerturbationFactor: float) -> None_:
        ...
    @typing.overload
    def __init__(self, stepMultiplier: float, maxAttempts: int, perturbationStep: int, maxPerturbationFactor: float, maxRandomizationStep: float) -> None_:
        ...
    @typing.overload
    def __init__(self, stepMultiplier: float, maxAttempts: int, perturbationStep: int, maxPerturbationFactor: float, maxRandomizationStep: float, defaultConstraintWeight: float) -> None_:
        ...
    @typing.overload
    def __init__(self, stepMultiplier: float, maxAttempts: int, perturbationStep: int, maxPerturbationFactor: float, maxRandomizationStep: float, defaultConstraintWeight: float, eqConstraintWeights: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, stepMultiplier: float, maxAttempts: int, perturbationStep: int, maxPerturbationFactor: float, maxRandomizationStep: float, defaultConstraintWeight: float, eqConstraintWeights: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], ineqConstraintWeights: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class ModularFunction(Function):
    @typing.overload
    def clearCostFunction(self) -> None_:
        ...
    @typing.overload
    def clearCostFunction(self, printWarning: bool) -> None_:
        ...
    def clearGradientFunction(self) -> None_:
        ...
    def clearHessianFunction(self) -> None_:
        ...
    def eval(self, x: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> float:
        ...
    def setCostFunction(self, cost: ...) -> None_:
        ...
    def setGradientFunction(self, gradient: ...) -> None_:
        ...
    def setHessianFunction(self, hessian: ...) -> None_:
        ...
class MultiFunction:
    pass
class NullFunction(Function):
    def eval(self, arg0_: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> float:
        ...
class Problem:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, dim: int) -> None_:
        ...
    def addEqConstraint(self, eqConst: Function) -> None_:
        ...
    def addIneqConstraint(self, ineqConst: Function) -> None_:
        ...
    def addSeed(self, seed: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def clearAllSeeds(self) -> None_:
        ...
    def getDimension(self) -> int:
        ...
    def getEqConstraint(self, idx: int) -> Function:
        ...
    def getIneqConstraint(self, idx: int) -> Function:
        ...
    def getInitialGuess(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getNumEqConstraints(self) -> int:
        ...
    def getNumIneqConstraints(self) -> int:
        ...
    def getObjective(self) -> Function:
        ...
    def getOptimalSolution(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getOptimumValue(self) -> float:
        ...
    def removeAllEqConstraints(self) -> None_:
        ...
    def removeAllIneqConstraints(self) -> None_:
        ...
    def removeEqConstraint(self, eqConst: Function) -> None_:
        ...
    def removeIneqConstraint(self, ineqConst: Function) -> None_:
        ...
    def setDimension(self, dim: int) -> None_:
        ...
    def setInitialGuess(self, initGuess: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setLowerBounds(self, lb: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setObjective(self, obj: Function) -> None_:
        ...
    def setOptimalSolution(self, optParam: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setOptimumValue(self, val: float) -> None_:
        ...
    def setUpperBounds(self, ub: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class Solver:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, properties: SolverProperties) -> None_:
        ...
    @typing.overload
    def __init__(self, problem: ...) -> None_:
        ...
    def clone(self) -> Solver:
        ...
    def getIterationsPerPrint(self) -> int:
        ...
    def getNumMaxIterations(self) -> int:
        ...
    def getPrintFinalResult(self) -> bool:
        ...
    def getProblem(self) -> ...:
        ...
    def getResultFileName(self) -> str:
        ...
    def getTolerance(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def setIterationsPerPrint(self, newRatio: int) -> None_:
        ...
    def setNumMaxIterations(self, newMax: int) -> None_:
        ...
    def setOutStream(self, os: ...) -> None_:
        ...
    def setPrintFinalResult(self, print: bool) -> None_:
        ...
    def setProblem(self, newProblem: ...) -> None_:
        ...
    def setProperties(self, properties: SolverProperties) -> None_:
        ...
    def setResultFileName(self, resultFile: str) -> None_:
        ...
    def setTolerance(self, newTolerance: float) -> None_:
        ...
    def solve(self) -> bool:
        ...
class SolverProperties:
    mIterationsPerPrint: int
    mNumMaxIterations: int
    mOutStream: ...
    mPrintFinalResult: bool
    mProblem: ...
    mResultFile: str
    mTolerance: float
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, problem: ...) -> None_:
        ...
    @typing.overload
    def __init__(self, problem: ..., tolerance: float) -> None_:
        ...
    @typing.overload
    def __init__(self, problem: ..., tolerance: float, numMaxIterations: int) -> None_:
        ...
    @typing.overload
    def __init__(self, problem: ..., tolerance: float, numMaxIterations: int, iterationsPerPrint: int) -> None_:
        ...
    @typing.overload
    def __init__(self, problem: ..., tolerance: float, numMaxIterations: int, iterationsPerPrint: int, ostream: ...) -> None_:
        ...
    @typing.overload
    def __init__(self, problem: ..., tolerance: float, numMaxIterations: int, iterationsPerPrint: int, ostream: ..., printFinalResult: bool) -> None_:
        ...
    @typing.overload
    def __init__(self, problem: ..., tolerance: float, numMaxIterations: int, iterationsPerPrint: int, ostream: ..., printFinalResult: bool, resultFile: str) -> None_:
        ...
