from __future__ import annotations
import dartpy.common
import dartpy.math
import dartpy.optimizer
import numpy
import typing
__all__: list[str] = ['ACCELERATION', 'ActuatorType', 'ArrowShape', 'ArrowShapeProperties', 'BallJoint', 'BallJointProperties', 'BodyNode', 'BodyNodeAspectProperties', 'BodyNodeProperties', 'BoxShape', 'CapsuleShape', 'Chain', 'ChainCriteria', 'CollisionAspect', 'CompositeJoiner_EmbedProperties_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space', 'CompositeJoiner_EmbedProperties_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space', 'CompositeJoiner_EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space', 'CompositeJoiner_EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space', 'CompositeJoiner_EmbedProperties_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space', 'CompositeJoiner_EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space', 'CompositeJoiner_EmbedProperties_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_SE3GenericJointStateGenericJointUniqueProperties_Joint', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_SO3GenericJointStateGenericJointUniqueProperties_Joint', 'ConeShape', 'CylinderShape', 'DefaultActuatorType', 'DegreeOfFreedom', 'Detachable', 'DynamicsAspect', 'EllipsoidShape', 'EmbedPropertiesOnTopOf_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space', 'EmbedPropertiesOnTopOf_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space', 'EmbedPropertiesOnTopOf_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space', 'EmbedPropertiesOnTopOf_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space', 'EmbedPropertiesOnTopOf_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space', 'EmbedPropertiesOnTopOf_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space', 'EmbedPropertiesOnTopOf_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space', 'EmbedProperties_EulerJoint_EulerJointUniqueProperties', 'EmbedProperties_Joint_JointProperties', 'EmbedProperties_PlanarJoint_PlanarJointUniqueProperties', 'EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties', 'EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties', 'EmbedProperties_ScrewJoint_ScrewJointUniqueProperties', 'EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties', 'EmbedProperties_UniversalJoint_UniversalJointUniqueProperties', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties', 'EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties', 'EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties', 'EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties', 'EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties', 'Entity', 'EndEffector', 'EulerJoint', 'EulerJointProperties', 'EulerJointUniqueProperties', 'FORCE', 'Frame', 'FreeJoint', 'FreeJointProperties', 'GenericJointProperties_R1', 'GenericJointProperties_R2', 'GenericJointProperties_R3', 'GenericJointProperties_SE3', 'GenericJointProperties_SO3', 'GenericJointUniqueProperties_R1', 'GenericJointUniqueProperties_R2', 'GenericJointUniqueProperties_R3', 'GenericJointUniqueProperties_SE3', 'GenericJointUniqueProperties_SO3', 'GenericJoint_R1', 'GenericJoint_R2', 'GenericJoint_R3', 'GenericJoint_SE3', 'GenericJoint_SO3', 'Inertia', 'InverseKinematics', 'InverseKinematicsErrorMethod', 'InverseKinematicsErrorMethodProperties', 'InverseKinematicsTaskSpaceRegion', 'InverseKinematicsTaskSpaceRegionProperties', 'InverseKinematicsTaskSpaceRegionUniqueProperties', 'JacobianNode', 'Joint', 'JointProperties', 'LOCKED', 'LineSegmentShape', 'Linkage', 'LinkageCriteria', 'MIMIC', 'MeshShape', 'MetaSkeleton', 'MimicConstraintType', 'MimicDofProperties', 'MultiSphereConvexHullShape', 'Node', 'PASSIVE', 'PlanarJoint', 'PlanarJointProperties', 'PlanarJointUniqueProperties', 'PlaneShape', 'PointCloudShape', 'PrismaticJoint', 'PrismaticJointProperties', 'PrismaticJointUniqueProperties', 'ReferentialSkeleton', 'RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_Joint_JointProperties', 'RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties', 'RevoluteJoint', 'RevoluteJointProperties', 'RevoluteJointUniqueProperties', 'SERVO', 'ScrewJoint', 'ScrewJointProperties', 'ScrewJointUniqueProperties', 'Shape', 'ShapeFrame', 'ShapeNode', 'SimpleFrame', 'Skeleton', 'SoftMeshShape', 'SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_Joint_JointProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties', 'SphereShape', 'Support', 'TemplatedJacobianBodyNode', 'TranslationalJoint', 'TranslationalJoint2D', 'TranslationalJoint2DProperties', 'TranslationalJoint2DUniqueProperties', 'TranslationalJointProperties', 'UniversalJoint', 'UniversalJointProperties', 'UniversalJointUniqueProperties', 'VELOCITY', 'VisualAspect', 'WeldJoint', 'ZeroDofJoint', 'ZeroDofJointProperties']
M = typing.TypeVar("M", bound=int)
N = typing.TypeVar("N", bound=int)
class ActuatorType:
    """
    Members:
    
      FORCE
    
      PASSIVE
    
      SERVO
    
      MIMIC
    
      ACCELERATION
    
      VELOCITY
    
      LOCKED
    """
    ACCELERATION: typing.ClassVar[ActuatorType]  # value = <ActuatorType.ACCELERATION: 4>
    FORCE: typing.ClassVar[ActuatorType]  # value = <ActuatorType.FORCE: 0>
    LOCKED: typing.ClassVar[ActuatorType]  # value = <ActuatorType.LOCKED: 6>
    MIMIC: typing.ClassVar[ActuatorType]  # value = <ActuatorType.MIMIC: 3>
    PASSIVE: typing.ClassVar[ActuatorType]  # value = <ActuatorType.PASSIVE: 1>
    SERVO: typing.ClassVar[ActuatorType]  # value = <ActuatorType.SERVO: 2>
    VELOCITY: typing.ClassVar[ActuatorType]  # value = <ActuatorType.VELOCITY: 5>
    __members__: typing.ClassVar[dict[str, ActuatorType]]  # value = {'FORCE': <ActuatorType.FORCE: 0>, 'PASSIVE': <ActuatorType.PASSIVE: 1>, 'SERVO': <ActuatorType.SERVO: 2>, 'MIMIC': <ActuatorType.MIMIC: 3>, 'ACCELERATION': <ActuatorType.ACCELERATION: 4>, 'VELOCITY': <ActuatorType.VELOCITY: 5>, 'LOCKED': <ActuatorType.LOCKED: 6>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None_:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None_:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ArrowShape(MeshShape):
    @typing.overload
    def __init__(self, tail: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], head: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, tail: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], head: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], properties: ...) -> None_:
        ...
    @typing.overload
    def __init__(self, tail: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], head: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], properties: ..., color: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, tail: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], head: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], properties: ..., color: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]], resolution: int) -> None_:
        ...
    def configureArrow(self, tail: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], head: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], properties: ...) -> None_:
        ...
    def getHead(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getProperties(self) -> ...:
        ...
    def getTail(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def notifyColorUpdated(self, color: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositions(self, tail: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], head: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setProperties(self, properties: ...) -> None_:
        ...
class ArrowShapeProperties:
    mDoubleArrow: bool
    mHeadLengthScale: float
    mHeadRadiusScale: float
    mMaxHeadLength: float
    mMinHeadLength: float
    mRadius: float
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, radius: float) -> None_:
        ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float) -> None_:
        ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float) -> None_:
        ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float, minHeadLength: float) -> None_:
        ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float, minHeadLength: float, maxHeadLength: float) -> None_:
        ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float, minHeadLength: float, maxHeadLength: float, doubleArrow: bool) -> None_:
        ...
class BallJoint(GenericJoint_SO3):
    @staticmethod
    def convertToPositions(tf: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @staticmethod
    def convertToRotation(positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @staticmethod
    def convertToTransform(positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> dartpy.math.Isometry3:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def getBallJointProperties(self) -> BallJointProperties:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
class BallJointProperties(GenericJointProperties_SO3):
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, properties: GenericJointProperties_SO3) -> None_:
        ...
class BodyNode(TemplatedJacobianBodyNode, Frame):
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], isImpulseLocal: bool) -> None_:
        ...
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], isImpulseLocal: bool, isOffsetLocal: bool) -> None_:
        ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], isForceLocal: bool) -> None_:
        ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], isForceLocal: bool, isOffsetLocal: bool) -> None_:
        ...
    @typing.overload
    def addExtTorque(self, torque: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def addExtTorque(self, torque: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], isLocal: bool) -> None_:
        ...
    def clearConstraintImpulse(self) -> None_:
        ...
    def clearExternalForces(self) -> None_:
        ...
    def clearInternalForces(self) -> None_:
        ...
    def computeKineticEnergy(self) -> float:
        ...
    def computeLagrangian(self, gravity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> float:
        ...
    def computePotentialEnergy(self, gravity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> float:
        ...
    @typing.overload
    def copy(self, otherBodyNode: BodyNode) -> None_:
        ...
    @typing.overload
    def copy(self, otherBodyNode: BodyNode) -> None_:
        ...
    @typing.overload
    def copyAs(self, skeletonName: str) -> ...:
        ...
    @typing.overload
    def copyAs(self, skeletonName: str, recursive: bool) -> ...:
        ...
    @typing.overload
    def copyTo(self, newParent: BodyNode) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def copyTo(self, newParent: BodyNode, recursive: bool) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def copyTo(self, newSkeleton: ..., newParent: BodyNode) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def copyTo(self, newSkeleton: ..., newParent: BodyNode, recursive: bool) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, jointProperties: ...) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, jointProperties: ...) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, jointProperties: ...) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, jointProperties: ...) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, jointProperties: ...) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, jointProperties: ...) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, jointProperties: ...) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createShapeNode(self, shape: Shape) -> ShapeNode:
        ...
    @typing.overload
    def createShapeNode(self, shape: Shape, name: str) -> ShapeNode:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, jointProperties: ...) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, jointProperties: ...) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, jointProperties: ...) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, jointProperties: ...) -> tuple[..., BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[..., BodyNode]:
        ...
    def dependsOn(self, genCoordIndex: int) -> bool:
        ...
    def dirtyAcceleration(self) -> None_:
        ...
    def dirtyArticulatedInertia(self) -> None_:
        ...
    def dirtyCoriolisForces(self) -> None_:
        ...
    def dirtyExternalForces(self) -> None_:
        ...
    def dirtyTransform(self) -> None_:
        ...
    def dirtyVelocity(self) -> None_:
        ...
    def duplicateNodes(self, otherBodyNode: BodyNode) -> None_:
        ...
    def getAllNodeProperties(self) -> ...:
        ...
    def getAllNodeStates(self) -> ...:
        ...
    @typing.overload
    def getAngularMomentum(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularMomentum(self, pivot: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getBodyForce(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        """
        Get spatial body force transmitted from the parent joint. 
        
        The spatial body force is transmitted to this BodyNode from the parent body through the connecting joint. It is expressed in this BodyNode's frame.
        """
    def getBodyNodeProperties(self) -> BodyNodeProperties:
        ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getChainDofs(self) -> list[DegreeOfFreedom]:
        ...
    def getChildBodyNode(self, index: int) -> BodyNode:
        ...
    def getChildJoint(self, index: int) -> ...:
        ...
    def getDependentGenCoordIndex(self, arrayIndex: int) -> int:
        ...
    def getExternalForceGlobal(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getGravityMode(self) -> bool:
        ...
    def getIndexInSkeleton(self) -> int:
        ...
    def getIndexInTree(self) -> int:
        ...
    def getInertia(self) -> ...:
        ...
    def getLinearMomentum(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getLocalCOM(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getMass(self) -> float:
        ...
    def getMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None_:
        ...
    def getName(self) -> str:
        ...
    def getNumChildBodyNodes(self) -> int:
        ...
    def getNumChildJoints(self) -> int:
        ...
    def getNumDependentDofs(self) -> int:
        ...
    def getNumDependentGenCoords(self) -> int:
        ...
    def getNumEndEffectors(self) -> int:
        ...
    def createEndEffector(self, name: str = 'EndEffector') -> EndEffector:
        ...
    def getEndEffector(self, index: int) -> EndEffector:
        ...
    def getNumMarkers(self) -> int:
        ...
    def getNumShapeNodes(self) -> int:
        ...
    def getParentBodyNode(self) -> BodyNode:
        ...
    def getParentJoint(self) -> ...:
        ...
    def getShapeNode(self, index: int) -> ShapeNode:
        ...
    def getShapeNodes(self) -> list[ShapeNode]:
        ...
    @typing.overload
    def getSkeleton(self) -> ...:
        ...
    @typing.overload
    def getSkeleton(self) -> ...:
        ...
    def getTreeIndex(self) -> int:
        ...
    def isCollidable(self) -> bool:
        ...
    def isReactive(self) -> bool:
        ...
    def matchNodes(self, otherBodyNode: BodyNode) -> None_:
        ...
    @typing.overload
    def moveTo(self, newParent: BodyNode) -> bool:
        ...
    @typing.overload
    def moveTo(self, newSkeleton: ..., newParent: BodyNode) -> bool:
        ...
    @typing.overload
    def remove(self) -> ...:
        ...
    @typing.overload
    def remove(self, name: str) -> ...:
        ...
    def removeAllShapeNodes(self) -> None_:
        ...
    def setAllNodeProperties(self, properties: ..., std_param_1: ..., std_param_2: ..., std_param_3: ..., std_param_4: ..., std_param_5: ..., std_param_6: ..., std_param_7: ..., std_param_8: ..., std_param_9: ..., std_param_10: ...) -> None_:
        ...
    def setAllNodeStates(self, states: ..., std_param_11: ..., std_param_12: ..., std_param_13: ..., std_param_14: ..., std_param_15: ..., std_param_16: ..., std_param_17: ..., std_param_18: ..., std_param_19: ..., std_param_20: ...) -> None_:
        ...
    def setAlpha(self, alpha: float) -> None_:
        ...
    def setAspectProperties(self, properties: BodyNodeAspectProperties) -> None_:
        ...
    def setAspectState(self, state: ..., dart_param_1: ...) -> None_:
        ...
    def setCollidable(self, isCollidable: bool) -> None_:
        ...
    @typing.overload
    def setColor(self, color: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setColor(self, color: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setConstraintImpulse(self, constImp: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], isForceLocal: bool) -> None_:
        ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], isForceLocal: bool, isOffsetLocal: bool) -> None_:
        ...
    @typing.overload
    def setExtTorque(self, torque: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setExtTorque(self, torque: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], isLocal: bool) -> None_:
        ...
    def setGravityMode(self, gravityMode: bool) -> None_:
        ...
    def setInertia(self, inertia: ...) -> None_:
        ...
    def setLocalCOM(self, com: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setMass(self, mass: float) -> None_:
        ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float) -> None_:
        ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float) -> None_:
        ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float) -> None_:
        ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None_:
        ...
    def setName(self, name: str) -> str:
        ...
    @typing.overload
    def setProperties(self, properties: ..., std_param_21: ..., std_param_22: ..., std_param_23: ..., std_param_24: ..., std_param_25: ..., std_param_26: ..., dart_param_2: ...) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: BodyNodeAspectProperties) -> None_:
        ...
    def split(self, skeletonName: str) -> ...:
        ...
class Support:
    def setGeometry(
        self,
        geometry: typing.Iterable[
            numpy.ndarray[
                tuple[typing.Literal[3], typing.Literal[1]],
                numpy.dtype[numpy.float64],
            ]
        ],
    ) -> None_:
        ...

    def getGeometry(
        self,
    ) -> list[
        numpy.ndarray[
            tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]
        ]
    ]:
        ...

    def setActive(self, supporting: bool = True) -> None_:
        ...

    def isActive(self) -> bool:
        ...


class EndEffector(JacobianNode):
    def setDefaultRelativeTransform(self, transform: dartpy.math.Isometry3, useNow: bool = False) -> None_:
        ...
    def resetRelativeTransform(self) -> None_:
        ...
    def createSupport(self) -> Support:
        ...
    @typing.overload
    def getSupport(self) -> typing.Optional[Support]:
        ...
    @typing.overload
    def getSupport(self, createIfNull: bool) -> Support:
        ...
    def hasSupport(self) -> bool:
        ...
    def removeSupport(self) -> None_:
        ...

class BodyNodeAspectProperties:
    mGravityMode: bool
    mInertia: ...
    mIsCollidable: bool
    mName: str
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, name: str) -> None_:
        ...
    @typing.overload
    def __init__(self, name: str, inertia: ...) -> None_:
        ...
    @typing.overload
    def __init__(self, name: str, inertia: ..., isCollidable: bool) -> None_:
        ...
    @typing.overload
    def __init__(self, name: str, inertia: ..., isCollidable: bool, gravityMode: bool) -> None_:
        ...
class BodyNodeProperties:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, aspectProperties: BodyNodeAspectProperties) -> None_:
        ...
class BoxShape(Shape):
    @staticmethod
    def computeInertiaOf(size: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @staticmethod
    def computeVolume(size: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, size: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getSize(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getType(self) -> str:
        ...
    def setSize(self, size: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class CapsuleShape(Shape):
    @staticmethod
    def computeInertiaOf(radius: float, height: float, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @staticmethod
    def computeVolumeOf(radius: float, height: float) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, radius: float, height: float) -> None_:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getHeight(self) -> float:
        ...
    def getRadius(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def setHeight(self, height: float) -> None_:
        ...
    def setRadius(self, radius: float) -> None_:
        ...
class Chain(Linkage):
    @typing.overload
    def __init__(self, criteria: ...) -> None_:
        ...
    @typing.overload
    def __init__(self, criteria: ..., name: str) -> None_:
        ...
    @typing.overload
    def __init__(self, start: BodyNode, target: BodyNode) -> None_:
        ...
    @typing.overload
    def __init__(self, start: BodyNode, target: BodyNode, name: str) -> None_:
        ...
    @typing.overload
    def __init__(self, start: BodyNode, target: BodyNode, includeUpstreamParentJoint: bool) -> None_:
        ...
    @typing.overload
    def __init__(self, start: BodyNode, target: BodyNode, includeUpstreamParentJoint: bool, name: str) -> None_:
        ...
    @typing.overload
    def cloneChain(self) -> Chain:
        ...
    @typing.overload
    def cloneChain(self, cloneName: str) -> Chain:
        ...
    def cloneMetaSkeleton(self, cloneName: str) -> MetaSkeleton:
        ...
    def isStillChain(self) -> bool:
        ...
class ChainCriteria:
    mIncludeUpstreamParentJoint: bool
    mStart: ...
    mTarget: ...
    @staticmethod
    def static_convert(criteria: LinkageCriteria) -> ChainCriteria:
        ...
    @typing.overload
    def __init__(self, start: BodyNode, target: BodyNode) -> None_:
        ...
    @typing.overload
    def __init__(self, start: BodyNode, target: BodyNode, includeBoth: bool) -> None_:
        ...
    def convert(self) -> LinkageCriteria:
        ...
    def satisfy(self) -> ...:
        ...
class CollisionAspect:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, properties: ...) -> None_:
        ...
    def getCollidable(self) -> bool:
        ...
    def isCollidable(self) -> bool:
        ...
    def setCollidable(self, value: bool) -> None_:
        ...
class CompositeJoiner_EmbedProperties_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space(EmbedProperties_EulerJoint_EulerJointUniqueProperties, GenericJoint_R3):
    pass
class CompositeJoiner_EmbedProperties_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space(EmbedProperties_PlanarJoint_PlanarJointUniqueProperties, GenericJoint_R3):
    pass
class CompositeJoiner_EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space(EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties, GenericJoint_R1):
    pass
class CompositeJoiner_EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space(EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties, GenericJoint_R1):
    pass
class CompositeJoiner_EmbedProperties_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space(EmbedProperties_ScrewJoint_ScrewJointUniqueProperties, GenericJoint_R1):
    pass
class CompositeJoiner_EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space(EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, GenericJoint_R2):
    pass
class CompositeJoiner_EmbedProperties_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space(EmbedProperties_UniversalJoint_UniversalJointUniqueProperties, GenericJoint_R2):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_SE3GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_SO3GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class ConeShape(Shape):
    @staticmethod
    def computeInertiaOf(radius: float, height: float, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @staticmethod
    def computeVolume(radius: float, height: float) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, radius: float, height: float) -> None_:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getHeight(self) -> float:
        ...
    def getRadius(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def setHeight(self, height: float) -> None_:
        ...
    def setRadius(self, radius: float) -> None_:
        ...
class CylinderShape(Shape):
    @staticmethod
    def computeInertiaOf(radius: float, height: float, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @staticmethod
    def computeVolumeOf(radius: float, height: float) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, radius: float, height: float) -> None_:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getHeight(self) -> float:
        ...
    def getRadius(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def setHeight(self, height: float) -> None_:
        ...
    def setRadius(self, radius: float) -> None_:
        ...
class DegreeOfFreedom(dartpy.common.Subject):
    def getAcceleration(self) -> float:
        ...
    def getAccelerationLimits(self) -> tuple[float, float]:
        ...
    def getAccelerationLowerLimit(self) -> float:
        ...
    def getAccelerationUpperLimit(self) -> float:
        ...
    def getCommand(self) -> float:
        ...
    def getConstraintImpulse(self) -> float:
        ...
    def getCoulombFriction(self) -> float:
        ...
    def getDampingCoefficient(self) -> float:
        ...
    def getForce(self) -> float:
        ...
    def getForceLimits(self) -> tuple[float, float]:
        ...
    def getForceLowerLimit(self) -> float:
        ...
    def getForceUpperLimit(self) -> float:
        ...
    def getIndexInJoint(self) -> int:
        ...
    def getIndexInSkeleton(self) -> int:
        ...
    def getIndexInTree(self) -> int:
        ...
    def getInitialPosition(self) -> float:
        ...
    def getInitialVelocity(self) -> float:
        ...
    def getName(self) -> str:
        ...
    def getPosition(self) -> float:
        ...
    def getPositionLimits(self) -> tuple[float, float]:
        ...
    def getPositionLowerLimit(self) -> float:
        ...
    def getPositionUpperLimit(self) -> float:
        ...
    def getRestPosition(self) -> float:
        ...
    @typing.overload
    def getSkeleton(self) -> ...:
        ...
    @typing.overload
    def getSkeleton(self) -> ...:
        ...
    def getSpringStiffness(self) -> float:
        ...
    def getTreeIndex(self) -> int:
        ...
    def getVelocity(self) -> float:
        ...
    def getVelocityChange(self) -> float:
        ...
    def getVelocityLimits(self) -> tuple[float, float]:
        ...
    def getVelocityLowerLimit(self) -> float:
        ...
    def getVelocityUpperLimit(self) -> float:
        ...
    def hasPositionLimit(self) -> bool:
        ...
    def isCyclic(self) -> bool:
        ...
    def isNamePreserved(self) -> bool:
        ...
    def preserveName(self, preserve: bool) -> None_:
        ...
    def resetAcceleration(self) -> None_:
        ...
    def resetCommand(self) -> None_:
        ...
    def resetConstraintImpulse(self) -> None_:
        ...
    def resetForce(self) -> None_:
        ...
    def resetPosition(self) -> None_:
        ...
    def resetVelocity(self) -> None_:
        ...
    def resetVelocityChange(self) -> None_:
        ...
    def setAcceleration(self, acceleration: float) -> None_:
        ...
    @typing.overload
    def setAccelerationLimits(self, lowerLimit: float, upperLimit: float) -> None_:
        ...
    @typing.overload
    def setAccelerationLimits(self, limits: tuple[float, float]) -> None_:
        ...
    def setAccelerationLowerLimit(self, limit: float) -> None_:
        ...
    def setAccelerationUpperLimit(self, limit: float) -> None_:
        ...
    def setCommand(self, command: float) -> None_:
        ...
    def setConstraintImpulse(self, impulse: float) -> None_:
        ...
    def setCoulombFriction(self, friction: float) -> None_:
        ...
    def setDampingCoefficient(self, coeff: float) -> None_:
        ...
    def setForce(self, force: float) -> None_:
        ...
    @typing.overload
    def setForceLimits(self, lowerLimit: float, upperLimit: float) -> None_:
        ...
    @typing.overload
    def setForceLimits(self, limits: tuple[float, float]) -> None_:
        ...
    def setForceLowerLimit(self, limit: float) -> None_:
        ...
    def setForceUpperLimit(self, limit: float) -> None_:
        ...
    def setInitialPosition(self, initial: float) -> None_:
        ...
    def setInitialVelocity(self, initial: float) -> None_:
        ...
    @typing.overload
    def setName(self, name: str) -> str:
        ...
    @typing.overload
    def setName(self, name: str, preserveName: bool) -> str:
        ...
    def setPosition(self, position: float) -> None_:
        ...
    @typing.overload
    def setPositionLimits(self, lowerLimit: float, upperLimit: float) -> None_:
        ...
    @typing.overload
    def setPositionLimits(self, limits: tuple[float, float]) -> None_:
        ...
    def setPositionLowerLimit(self, limit: float) -> None_:
        ...
    def setPositionUpperLimit(self, limit: float) -> None_:
        ...
    def setRestPosition(self, q0: float) -> None_:
        ...
    def setSpringStiffness(self, k: float) -> None_:
        ...
    def setVelocity(self, velocity: float) -> None_:
        ...
    def setVelocityChange(self, velocityChange: float) -> None_:
        ...
    @typing.overload
    def setVelocityLimits(self, lowerLimit: float, upperLimit: float) -> None_:
        ...
    @typing.overload
    def setVelocityLimits(self, limits: tuple[float, float]) -> None_:
        ...
    def setVelocityLowerLimit(self, limit: float) -> None_:
        ...
    def setVelocityUpperLimit(self, limit: float) -> None_:
        ...
class Detachable(Entity):
    def setParentFrame(self, newParentFrame: ...) -> None_:
        ...
class DynamicsAspect:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, properties: ...) -> None_:
        ...
    def getFrictionCoeff(self) -> float:
        ...
    def getRestitutionCoeff(self) -> float:
        ...
    def setFrictionCoeff(self, value: float) -> None_:
        ...
    def setRestitutionCoeff(self, value: float) -> None_:
        ...
class EllipsoidShape(Shape):
    @staticmethod
    def computeInertiaOf(diameters: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @staticmethod
    def computeVolumeOf(diameters: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, diameters: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getDiameters(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRadii(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getType(self) -> str:
        ...
    def isSphere(self) -> bool:
        ...
    def setDiameters(self, diameters: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setRadii(self, radii: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class EmbedPropertiesOnTopOf_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space(CompositeJoiner_EmbedProperties_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space):
    pass
class EmbedPropertiesOnTopOf_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space(CompositeJoiner_EmbedProperties_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space):
    pass
class EmbedPropertiesOnTopOf_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space(CompositeJoiner_EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space):
    pass
class EmbedPropertiesOnTopOf_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space(CompositeJoiner_EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space):
    pass
class EmbedPropertiesOnTopOf_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space(CompositeJoiner_EmbedProperties_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space):
    pass
class EmbedPropertiesOnTopOf_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space(CompositeJoiner_EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space):
    pass
class EmbedPropertiesOnTopOf_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space(CompositeJoiner_EmbedProperties_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space):
    pass
class EmbedProperties_EulerJoint_EulerJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties):
    pass
class EmbedProperties_Joint_JointProperties(RequiresAspect_EmbeddedPropertiesAspect_Joint_JointProperties):
    pass
class EmbedProperties_PlanarJoint_PlanarJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties):
    pass
class EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties):
    pass
class EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties):
    pass
class EmbedProperties_ScrewJoint_ScrewJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties):
    pass
class EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties):
    pass
class EmbedProperties_UniversalJoint_UniversalJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_SE3GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_SO3GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties):
    pass
class EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties):
    pass
class EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties):
    pass
class EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties):
    pass
class EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties):
    pass
class Entity(dartpy.common.Subject):
    def descendsFrom(self, someFrame: ...) -> bool:
        ...
    def dirtyAcceleration(self) -> None_:
        ...
    def dirtyTransform(self) -> None_:
        ...
    def dirtyVelocity(self) -> None_:
        ...
    def getName(self) -> str:
        ...
    def getParentFrame(self) -> ...:
        ...
    def isFrame(self) -> bool:
        ...
    def isQuiet(self) -> bool:
        ...
    def needsAccelerationUpdate(self) -> bool:
        ...
    def needsTransformUpdate(self) -> bool:
        ...
    def needsVelocityUpdate(self) -> bool:
        ...
    def setName(self, name: str) -> str:
        ...
class EulerJoint(EmbedPropertiesOnTopOf_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space):
    @staticmethod
    def convertToRotationOf(positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], ordering: ...) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @staticmethod
    def convertToTransformOf(positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], ordering: ...) -> dartpy.math.Isometry3:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def convertToRotation(self, positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def convertToTransform(self, positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> dartpy.math.Isometry3:
        ...
    def copy(self, otherJoint: EulerJoint) -> None_:
        ...
    def getAxisOrder(self) -> ...:
        ...
    def getEulerJointProperties(self) -> EulerJointProperties:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getType(self) -> str:
        ...
    def hasEulerJointAspect(self) -> bool:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def releaseEulerJointAspect(self) -> ...:
        ...
    def removeEulerJointAspect(self) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_3: ...) -> None_:
        ...
    @typing.overload
    def setAxisOrder(self, order: ...) -> None_:
        ...
    @typing.overload
    def setAxisOrder(self, order: ..., renameDofs: bool) -> None_:
        ...
    def setEulerJointAspect(self, aspect: ..., dart_param_4: ...) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: EulerJointProperties) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: EulerJointUniqueProperties) -> None_:
        ...
class EulerJointProperties(GenericJointProperties_R3, EulerJointUniqueProperties):
    mAxisOrder: ...
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R3) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R3, uniqueProperties: EulerJointUniqueProperties) -> None_:
        ...
class EulerJointUniqueProperties:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, axisOrder: ...) -> None_:
        ...
class Frame(Entity):
    @staticmethod
    def World() -> Frame:
        ...
    def dirtyAcceleration(self) -> None_:
        ...
    def dirtyTransform(self) -> None_:
        ...
    def dirtyVelocity(self) -> None_:
        ...
    @typing.overload
    def getAngularAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularAcceleration(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularVelocity(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularVelocity(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getChildEntities(self) -> ...:
        ...
    def getChildFrames(self) -> ...:
        ...
    @typing.overload
    def getLinearAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearAcceleration(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearAcceleration(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearAcceleration(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearVelocity(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearVelocity(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearVelocity(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearVelocity(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getNumChildEntities(self) -> int:
        ...
    def getNumChildFrames(self) -> int:
        ...
    def getRelativeTransform(self) -> dartpy.math.Isometry3:
        ...
    @typing.overload
    def getSpatialAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getSpatialAcceleration(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getSpatialAcceleration(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getSpatialVelocity(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getSpatialVelocity(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getSpatialVelocity(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getTransform(self) -> dartpy.math.Isometry3:
        ...
    @typing.overload
    def getTransform(self, withRespectTo: Frame) -> dartpy.math.Isometry3:
        ...
    @typing.overload
    def getTransform(self, withRespectTo: Frame, inCoordinatesOf: Frame) -> dartpy.math.Isometry3:
        ...
    def getWorldTransform(self) -> dartpy.math.Isometry3:
        ...
    def isShapeFrame(self) -> bool:
        ...
    def isWorld(self) -> bool:
        ...
class FreeJoint(GenericJoint_SE3):
    @staticmethod
    def convertToPositions(tf: dartpy.math.Isometry3) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @staticmethod
    def convertToTransform(positions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> dartpy.math.Isometry3:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(joint: Joint, tf: dartpy.math.Isometry3) -> None_:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(joint: Joint, tf: dartpy.math.Isometry3, withRespectTo: Frame) -> None_:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(bodyNode: BodyNode, tf: dartpy.math.Isometry3) -> None_:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(bodyNode: BodyNode, tf: dartpy.math.Isometry3, withRespectTo: Frame) -> None_:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(skeleton: ..., tf: dartpy.math.Isometry3) -> None_:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(skeleton: ..., tf: dartpy.math.Isometry3, withRespectTo: Frame) -> None_:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(skeleton: ..., tf: dartpy.math.Isometry3, withRespectTo: Frame, applyToAllRootBodies: bool) -> None_:
        ...
    def getFreeJointProperties(self) -> FreeJointProperties:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[6]], numpy.dtype[numpy.float64]]:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    @typing.overload
    def setAngularAcceleration(self, newAngularAcceleration: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setAngularAcceleration(self, newAngularAcceleration: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame) -> None_:
        ...
    @typing.overload
    def setAngularAcceleration(self, newAngularAcceleration: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame, inCoordinatesOf: Frame) -> None_:
        ...
    @typing.overload
    def setAngularVelocity(self, newAngularVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setAngularVelocity(self, newAngularVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame) -> None_:
        ...
    @typing.overload
    def setAngularVelocity(self, newAngularVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame, inCoordinatesOf: Frame) -> None_:
        ...
    @typing.overload
    def setLinearAcceleration(self, newLinearAcceleration: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setLinearAcceleration(self, newLinearAcceleration: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame) -> None_:
        ...
    @typing.overload
    def setLinearAcceleration(self, newLinearAcceleration: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame, inCoordinatesOf: Frame) -> None_:
        ...
    @typing.overload
    def setLinearVelocity(self, newLinearVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setLinearVelocity(self, newLinearVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame) -> None_:
        ...
    @typing.overload
    def setLinearVelocity(self, newLinearVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame, inCoordinatesOf: Frame) -> None_:
        ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> None_:
        ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> None_:
        ...
    def setRelativeTransform(self, newTransform: dartpy.math.Isometry3) -> None_:
        ...
    def setSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame, inCoordinatesOf: Frame) -> None_:
        ...
    def setSpatialMotion(self, newTransform: dartpy.math.Isometry3, withRespectTo: Frame, newSpatialVelocity: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velRelativeTo: Frame, velInCoordinatesOf: Frame, newSpatialAcceleration: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accRelativeTo: Frame, accInCoordinatesOf: Frame) -> None_:
        ...
    def setSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: Frame, inCoordinatesOf: Frame) -> None_:
        ...
    @typing.overload
    def setTransform(self, newTransform: dartpy.math.Isometry3) -> None_:
        ...
    @typing.overload
    def setTransform(self, newTransform: dartpy.math.Isometry3, withRespectTo: Frame) -> None_:
        ...
class FreeJointProperties(GenericJointProperties_SE3):
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, properties: GenericJointProperties_SE3) -> None_:
        ...
class GenericJointProperties_R1(JointProperties, GenericJointUniqueProperties_R1):
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None_:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R1) -> None_:
        ...
class GenericJointProperties_R2(JointProperties, GenericJointUniqueProperties_R2):
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None_:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R2) -> None_:
        ...
class GenericJointProperties_R3(JointProperties, GenericJointUniqueProperties_R3):
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None_:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R3) -> None_:
        ...
class GenericJointProperties_SE3(JointProperties, GenericJointUniqueProperties_SE3):
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None_:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_SE3) -> None_:
        ...
class GenericJointProperties_SO3(JointProperties, GenericJointUniqueProperties_SO3):
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None_:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_SO3) -> None_:
        ...
class GenericJointUniqueProperties_R1:
    mAccelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mAccelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mDampingCoefficients: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mForceLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mForceUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mFrictions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mInitialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mInitialVelocities: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mPositionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mPositionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mRestPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mSpringStiffnesses: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mVelocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mVelocityUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], dampingCoefficient: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], dampingCoefficient: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], coulombFrictions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @property
    def mDofNames(self) -> ...:
        ...
    @mDofNames.setter
    def mDofNames(*args, **kwargs):
        """
        (self: dartpy.dynamics.GenericJointUniqueProperties_R1, arg0: std_array<std___cxx11_basic_string<char, std_char_traits<char>, std_allocator<char> >, 1ul>) -> None
        """
    @property
    def mPreserveDofNames(self) -> ...:
        ...
    @mPreserveDofNames.setter
    def mPreserveDofNames(*args, **kwargs):
        """
        (self: dartpy.dynamics.GenericJointUniqueProperties_R1, arg0: std_array<bool, 1ul>) -> None
        """
class GenericJointUniqueProperties_R2:
    mAccelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mAccelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mDampingCoefficients: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mForceLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mForceUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mFrictions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mInitialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mInitialVelocities: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mPositionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mPositionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mRestPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mSpringStiffnesses: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mVelocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mVelocityUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], dampingCoefficient: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], dampingCoefficient: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], coulombFrictions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @property
    def mDofNames(self) -> ...:
        ...
    @mDofNames.setter
    def mDofNames(*args, **kwargs):
        """
        (self: dartpy.dynamics.GenericJointUniqueProperties_R2, arg0: std_array<std___cxx11_basic_string<char, std_char_traits<char>, std_allocator<char> >, 2ul>) -> None
        """
    @property
    def mPreserveDofNames(self) -> ...:
        ...
    @mPreserveDofNames.setter
    def mPreserveDofNames(*args, **kwargs):
        """
        (self: dartpy.dynamics.GenericJointUniqueProperties_R2, arg0: std_array<bool, 2ul>) -> None
        """
class GenericJointUniqueProperties_R3:
    mAccelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mAccelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mDampingCoefficients: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mForceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mForceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mFrictions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mInitialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mInitialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mPositionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mPositionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mRestPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mSpringStiffnesses: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mVelocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mVelocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], dampingCoefficient: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], dampingCoefficient: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], coulombFrictions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @property
    def mDofNames(self) -> ...:
        ...
    @mDofNames.setter
    def mDofNames(*args, **kwargs):
        """
        (self: dartpy.dynamics.GenericJointUniqueProperties_R3, arg0: std_array<std___cxx11_basic_string<char, std_char_traits<char>, std_allocator<char> >, 3ul>) -> None
        """
    @property
    def mPreserveDofNames(self) -> ...:
        ...
    @mPreserveDofNames.setter
    def mPreserveDofNames(*args, **kwargs):
        """
        (self: dartpy.dynamics.GenericJointUniqueProperties_R3, arg0: std_array<bool, 3ul>) -> None
        """
class GenericJointUniqueProperties_SE3:
    mAccelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mAccelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mDampingCoefficients: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mForceLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mForceUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mFrictions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mInitialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mInitialVelocities: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mPositionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mPositionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mRestPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mSpringStiffnesses: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mVelocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mVelocityUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], dampingCoefficient: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], dampingCoefficient: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], coulombFrictions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @property
    def mDofNames(self) -> ...:
        ...
    @mDofNames.setter
    def mDofNames(*args, **kwargs):
        """
        (self: dartpy.dynamics.GenericJointUniqueProperties_SE3, arg0: std_array<std___cxx11_basic_string<char, std_char_traits<char>, std_allocator<char> >, 6ul>) -> None
        """
    @property
    def mPreserveDofNames(self) -> ...:
        ...
    @mPreserveDofNames.setter
    def mPreserveDofNames(*args, **kwargs):
        """
        (self: dartpy.dynamics.GenericJointUniqueProperties_SE3, arg0: std_array<bool, 6ul>) -> None
        """
class GenericJointUniqueProperties_SO3:
    mAccelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mAccelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mDampingCoefficients: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mForceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mForceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mFrictions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mInitialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mInitialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mPositionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mPositionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mRestPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mSpringStiffnesses: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mVelocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mVelocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], dampingCoefficient: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], positionUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialPositions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], velocityUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], initialVelocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], accelerationUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceLowerLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], forceUpperLimits: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], springStiffness: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], restPosition: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], dampingCoefficient: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], coulombFrictions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @property
    def mDofNames(self) -> ...:
        ...
    @mDofNames.setter
    def mDofNames(*args, **kwargs):
        """
        (self: dartpy.dynamics.GenericJointUniqueProperties_SO3, arg0: std_array<std___cxx11_basic_string<char, std_char_traits<char>, std_allocator<char> >, 3ul>) -> None
        """
    @property
    def mPreserveDofNames(self) -> ...:
        ...
    @mPreserveDofNames.setter
    def mPreserveDofNames(*args, **kwargs):
        """
        (self: dartpy.dynamics.GenericJointUniqueProperties_SO3, arg0: std_array<bool, 3ul>) -> None
        """
class GenericJoint_R1(EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 1
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R1) -> None_:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R1) -> None_:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getForce(self, index: int) -> float:
        ...
    def getForceLowerLimit(self, index: int) -> float:
        ...
    def getForceLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForceUpperLimit(self, index: int) -> float:
        ...
    def getForceUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_R1:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def hasGenericJointAspect(self) -> bool:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None_:
        ...
    def integrateVelocities(self, dt: float) -> None_:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None_:
        ...
    def releaseGenericJointAspect(self) -> ...:
        ...
    def removeGenericJointAspect(self) -> None_:
        ...
    def resetAccelerations(self) -> None_:
        ...
    def resetCommands(self) -> None_:
        ...
    def resetConstraintImpulses(self) -> None_:
        ...
    def resetForces(self) -> None_:
        ...
    def resetPosition(self, index: int) -> None_:
        ...
    def resetPositions(self) -> None_:
        ...
    def resetVelocities(self) -> None_:
        ...
    def resetVelocity(self, index: int) -> None_:
        ...
    def resetVelocityChanges(self) -> None_:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_5: ...) -> None_:
        ...
    def setAspectState(self, state: ..., dart_param_6: ...) -> None_:
        ...
    def setCommand(self, index: int, command: float) -> None_:
        ...
    def setCommands(self, commands: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None_:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None_:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None_:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setForce(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimit(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForceUpperLimit(self, index: int, force: float) -> None_:
        ...
    def setForceUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForces(self, forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setGenericJointAspect(self, aspect: ..., dart_param_7: ..., dart_param_8: ...) -> None_:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None_:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None_:
        ...
    def setPosition(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositions(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R1) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R1) -> None_:
        ...
    def setRestPosition(self, index: int, q0: float) -> None_:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None_:
        ...
    def setVelocities(self, velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocity(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None_:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class GenericJoint_R2(EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 2
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R2) -> None_:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R2) -> None_:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getForce(self, index: int) -> float:
        ...
    def getForceLowerLimit(self, index: int) -> float:
        ...
    def getForceLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForceUpperLimit(self, index: int) -> float:
        ...
    def getForceUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_R2:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[2]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def hasGenericJointAspect(self) -> bool:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None_:
        ...
    def integrateVelocities(self, dt: float) -> None_:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None_:
        ...
    def releaseGenericJointAspect(self) -> ...:
        ...
    def removeGenericJointAspect(self) -> None_:
        ...
    def resetAccelerations(self) -> None_:
        ...
    def resetCommands(self) -> None_:
        ...
    def resetConstraintImpulses(self) -> None_:
        ...
    def resetForces(self) -> None_:
        ...
    def resetPosition(self, index: int) -> None_:
        ...
    def resetPositions(self) -> None_:
        ...
    def resetVelocities(self) -> None_:
        ...
    def resetVelocity(self, index: int) -> None_:
        ...
    def resetVelocityChanges(self) -> None_:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_9: ...) -> None_:
        ...
    def setAspectState(self, state: ..., dart_param_10: ...) -> None_:
        ...
    def setCommand(self, index: int, command: float) -> None_:
        ...
    def setCommands(self, commands: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None_:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None_:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None_:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setForce(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimit(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForceUpperLimit(self, index: int, force: float) -> None_:
        ...
    def setForceUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForces(self, forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setGenericJointAspect(self, aspect: ..., dart_param_11: ..., dart_param_12: ...) -> None_:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None_:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None_:
        ...
    def setPosition(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositions(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R2) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R2) -> None_:
        ...
    def setRestPosition(self, index: int, q0: float) -> None_:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None_:
        ...
    def setVelocities(self, velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocity(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None_:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class GenericJoint_R3(EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 3
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R3) -> None_:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R3) -> None_:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getForce(self, index: int) -> float:
        ...
    def getForceLowerLimit(self, index: int) -> float:
        ...
    def getForceLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForceUpperLimit(self, index: int) -> float:
        ...
    def getForceUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_R3:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def hasGenericJointAspect(self) -> bool:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None_:
        ...
    def integrateVelocities(self, dt: float) -> None_:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None_:
        ...
    def releaseGenericJointAspect(self) -> ...:
        ...
    def removeGenericJointAspect(self) -> None_:
        ...
    def resetAccelerations(self) -> None_:
        ...
    def resetCommands(self) -> None_:
        ...
    def resetConstraintImpulses(self) -> None_:
        ...
    def resetForces(self) -> None_:
        ...
    def resetPosition(self, index: int) -> None_:
        ...
    def resetPositions(self) -> None_:
        ...
    def resetVelocities(self) -> None_:
        ...
    def resetVelocity(self, index: int) -> None_:
        ...
    def resetVelocityChanges(self) -> None_:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_13: ...) -> None_:
        ...
    def setAspectState(self, state: ..., dart_param_14: ...) -> None_:
        ...
    def setCommand(self, index: int, command: float) -> None_:
        ...
    def setCommands(self, commands: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None_:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None_:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None_:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setForce(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimit(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForceUpperLimit(self, index: int, force: float) -> None_:
        ...
    def setForceUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForces(self, forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setGenericJointAspect(self, aspect: ..., dart_param_15: ..., dart_param_16: ...) -> None_:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None_:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None_:
        ...
    def setPosition(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositions(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R3) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R3) -> None_:
        ...
    def setRestPosition(self, index: int, q0: float) -> None_:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None_:
        ...
    def setVelocities(self, velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocity(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None_:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class GenericJoint_SE3(EmbedStateAndPropertiesOnTopOf_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 6
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_SE3) -> None_:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_SE3) -> None_:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getForce(self, index: int) -> float:
        ...
    def getForceLowerLimit(self, index: int) -> float:
        ...
    def getForceLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForceUpperLimit(self, index: int) -> float:
        ...
    def getForceUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_SE3:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[6]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def hasGenericJointAspect(self) -> bool:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None_:
        ...
    def integrateVelocities(self, dt: float) -> None_:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None_:
        ...
    def releaseGenericJointAspect(self) -> ...:
        ...
    def removeGenericJointAspect(self) -> None_:
        ...
    def resetAccelerations(self) -> None_:
        ...
    def resetCommands(self) -> None_:
        ...
    def resetConstraintImpulses(self) -> None_:
        ...
    def resetForces(self) -> None_:
        ...
    def resetPosition(self, index: int) -> None_:
        ...
    def resetPositions(self) -> None_:
        ...
    def resetVelocities(self) -> None_:
        ...
    def resetVelocity(self, index: int) -> None_:
        ...
    def resetVelocityChanges(self) -> None_:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_17: ...) -> None_:
        ...
    def setAspectState(self, state: ..., dart_param_18: ...) -> None_:
        ...
    def setCommand(self, index: int, command: float) -> None_:
        ...
    def setCommands(self, commands: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None_:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None_:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None_:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setForce(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimit(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForceUpperLimit(self, index: int, force: float) -> None_:
        ...
    def setForceUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForces(self, forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setGenericJointAspect(self, aspect: ..., dart_param_19: ..., dart_param_20: ...) -> None_:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None_:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None_:
        ...
    def setPosition(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositions(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_SE3) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_SE3) -> None_:
        ...
    def setRestPosition(self, index: int, q0: float) -> None_:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None_:
        ...
    def setVelocities(self, velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocity(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None_:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class GenericJoint_SO3(EmbedStateAndPropertiesOnTopOf_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 3
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_SO3) -> None_:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_SO3) -> None_:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getForce(self, index: int) -> float:
        ...
    def getForceLowerLimit(self, index: int) -> float:
        ...
    def getForceLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForceUpperLimit(self, index: int) -> float:
        ...
    def getForceUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_SO3:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def hasGenericJointAspect(self) -> bool:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None_:
        ...
    def integrateVelocities(self, dt: float) -> None_:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None_:
        ...
    def releaseGenericJointAspect(self) -> ...:
        ...
    def removeGenericJointAspect(self) -> None_:
        ...
    def resetAccelerations(self) -> None_:
        ...
    def resetCommands(self) -> None_:
        ...
    def resetConstraintImpulses(self) -> None_:
        ...
    def resetForces(self) -> None_:
        ...
    def resetPosition(self, index: int) -> None_:
        ...
    def resetPositions(self) -> None_:
        ...
    def resetVelocities(self) -> None_:
        ...
    def resetVelocity(self, index: int) -> None_:
        ...
    def resetVelocityChanges(self) -> None_:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_21: ...) -> None_:
        ...
    def setAspectState(self, state: ..., dart_param_22: ...) -> None_:
        ...
    def setCommand(self, index: int, command: float) -> None_:
        ...
    def setCommands(self, commands: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None_:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None_:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None_:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setForce(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimit(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForceUpperLimit(self, index: int, force: float) -> None_:
        ...
    def setForceUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForces(self, forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setGenericJointAspect(self, aspect: ..., dart_param_23: ..., dart_param_24: ...) -> None_:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None_:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None_:
        ...
    def setPosition(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositions(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_SO3) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_SO3) -> None_:
        ...
    def setRestPosition(self, index: int, q0: float) -> None_:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None_:
        ...
    def setVelocities(self, velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocity(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None_:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class Inertia:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def verifyMoment(moment: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]], printWarnings: bool = True, tolerance: float = 1e-08) -> bool:
        ...
    @staticmethod
    def verifySpatialTensor(spatial: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[6]], numpy.dtype[numpy.float64]], printWarnings: bool = True, tolerance: float = 1e-08) -> bool:
        ...
    def __eq__(self, arg0: Inertia) -> bool:
        ...
    @typing.overload
    def __init__(self, mass: float = 1, com: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]] = ..., momentOfInertia: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]] = ...) -> None_:
        ...
    @typing.overload
    def __init__(self, spatialInertiaTensor: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[6]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def getLocalCOM(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getMass(self) -> float:
        ...
    def getMoment(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getSpatialTensor(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[6]], numpy.dtype[numpy.float64]]:
        ...
    def transform(self, transform: dartpy.math.Isometry3) -> Inertia:
        ...
    def transformed(self, transform: dartpy.math.Isometry3) -> Inertia:
        ...
    def setLocalCOM(self, com: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setMass(self, mass: float) -> None_:
        ...
    def setMoment(self, moment: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setSpatialTensor(self, spatial: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[6]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def verify(self, printWarnings: bool = True, tolerance: float = 1e-08) -> bool:
        ...
class InverseKinematics(dartpy.common.Subject):
    def __init__(self, node: JacobianNode) -> None_:
        ...
    def clearCaches(self) -> None_:
        ...
    def clone(self, newNode: JacobianNode) -> ...:
        ...
    def findSolution(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> bool:
        ...
    def getErrorMethod(self) -> InverseKinematicsErrorMethod:
        ...
    def getHierarchyLevel(self) -> int:
        ...
    def getNullSpaceObjective(self) -> dartpy.optimizer.Function:
        ...
    def getObjective(self) -> dartpy.optimizer.Function:
        ...
    def getOffset(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getProblem(self) -> dartpy.optimizer.Problem:
        ...
    def getSolver(self) -> dartpy.optimizer.Solver:
        ...
    @typing.overload
    def getTarget(self) -> SimpleFrame:
        ...
    @typing.overload
    def getTarget(self) -> SimpleFrame:
        ...
    def hasNullSpaceObjective(self) -> bool:
        ...
    def hasOffset(self) -> bool:
        ...
    def isActive(self) -> bool:
        ...
    @typing.overload
    def resetProblem(self) -> None_:
        ...
    @typing.overload
    def resetProblem(self, clearSeeds: bool) -> None_:
        ...
    @typing.overload
    def setActive(self) -> None_:
        ...
    @typing.overload
    def setActive(self, active: bool) -> None_:
        ...
    def setDofs(self, dofs: list[int]) -> None_:
        ...
    def setHierarchyLevel(self, level: int) -> None_:
        ...
    def setInactive(self) -> None_:
        ...
    def setNullSpaceObjective(self, nsObjective: dartpy.optimizer.Function) -> None_:
        ...
    def setObjective(self, objective: dartpy.optimizer.Function) -> None_:
        ...
    @typing.overload
    def setOffset(self) -> None_:
        ...
    @typing.overload
    def setOffset(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositions(self, q: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setSolver(self, newSolver: dartpy.optimizer.Solver) -> None_:
        ...
    def setTarget(self, newTarget: SimpleFrame) -> None_:
        ...
    @typing.overload
    def solveAndApply(self) -> bool:
        ...
    @typing.overload
    def solveAndApply(self, allowIncompleteResult: bool) -> bool:
        ...
    @typing.overload
    def solveAndApply(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], allowIncompleteResult: bool) -> bool:
        ...
    def useChain(self) -> None_:
        ...
    def useWholeBody(self) -> None_:
        ...
class InverseKinematicsErrorMethod(dartpy.common.Subject):
    def clearCache(self) -> None_:
        ...
    def clone(self, newIK: ...) -> InverseKinematicsErrorMethod:
        ...
    def computeDesiredTransform(self, currentTf: dartpy.math.Isometry3, error: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> dartpy.math.Isometry3:
        ...
    def computeError(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAngularBounds(self) -> tuple[numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]]:
        ...
    def getAngularErrorWeights(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getBounds(self) -> tuple[numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]]:
        ...
    def getErrorLengthClamp(self) -> float:
        ...
    def getErrorMethodProperties(self) -> InverseKinematicsErrorMethodProperties:
        ...
    def getLinearBounds(self) -> tuple[numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]]:
        ...
    def getLinearErrorWeights(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getMethodName(self) -> str:
        ...
    @typing.overload
    def setAngularBounds(self) -> None_:
        ...
    @typing.overload
    def setAngularBounds(self, lower: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setAngularBounds(self, lower: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], upper: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setAngularBounds(self, bounds: tuple[numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]]) -> None_:
        ...
    @typing.overload
    def setAngularErrorWeights(self) -> None_:
        ...
    @typing.overload
    def setAngularErrorWeights(self, weights: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setBounds(self) -> None_:
        ...
    @typing.overload
    def setBounds(self, lower: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setBounds(self, lower: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], upper: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setBounds(self, bounds: tuple[numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]]) -> None_:
        ...
    @typing.overload
    def setErrorLengthClamp(self) -> None_:
        ...
    @typing.overload
    def setErrorLengthClamp(self, clampSize: float) -> None_:
        ...
    def setErrorWeights(self, weights: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setLinearBounds(self) -> None_:
        ...
    @typing.overload
    def setLinearBounds(self, lower: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setLinearBounds(self, lower: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], upper: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setLinearBounds(self, bounds: tuple[numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]]) -> None_:
        ...
    @typing.overload
    def setLinearErrorWeights(self) -> None_:
        ...
    @typing.overload
    def setLinearErrorWeights(self, weights: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class InverseKinematicsErrorMethodProperties:
    mBounds: tuple[numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]]
    mErrorLengthClamp: float
    mErrorWeights: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]
    def __init__(self, bounds: tuple[numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]] = ..., errorClamp: float = 1.0, errorWeights: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]] = ...) -> None_:
        ...
class InverseKinematicsTaskSpaceRegion(InverseKinematicsErrorMethod):
    def __init__(self, ik: ..., properties: InverseKinematicsTaskSpaceRegionProperties = ...) -> None_:
        ...
    def getReferenceFrame(self) -> SimpleFrame:
        """
        Get the reference frame that the task space region is expressed.
        """
    def getTaskSpaceRegionProperties(self) -> InverseKinematicsTaskSpaceRegionProperties:
        """
        Get the Properties of this TaskSpaceRegion.
        """
    def isComputingFromCenter(self) -> bool:
        """
        Get whether this TaskSpaceRegion is set to compute its error vector from the center of the region.
        """
    def setComputeFromCenter(self, computeFromCenter: bool) -> None_:
        """
        Set whether this TaskSpaceRegion should compute its error vector from the center of the region.
        """
    def setReferenceFrame(self, referenceFrame: SimpleFrame) -> None_:
        """
        Set the reference frame that the task space region is expressed. Pass None to use the parent frame of the target frame instead.
        """
class InverseKinematicsTaskSpaceRegionProperties(InverseKinematicsErrorMethodProperties, InverseKinematicsTaskSpaceRegionUniqueProperties):
    def __init__(self, errorProperties: InverseKinematicsErrorMethodProperties = ..., taskSpaceProperties: InverseKinematicsTaskSpaceRegionUniqueProperties = ...) -> None_:
        ...
class InverseKinematicsTaskSpaceRegionUniqueProperties:
    mComputeErrorFromCenter: bool
    mReferenceFrame: SimpleFrame
    def __init__(self, computeErrorFromCenter: bool = True, referenceFrame: SimpleFrame = None) -> None_:
        ...
class JacobianNode(Frame, Node):
    def clearIK(self) -> None_:
        ...
    def dependsOn(self, genCoordIndex: int) -> bool:
        ...
    def dirtyJacobian(self) -> None_:
        ...
    def dirtyJacobianDeriv(self) -> None_:
        ...
    @typing.overload
    def getAngularJacobian(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    def getChainDofs(self) -> ...:
        ...
    def getDependentGenCoordIndex(self, arrayIndex: int) -> int:
        ...
    @typing.overload
    def getIK(self) -> ...:
        ...
    @typing.overload
    def getIK(self, createIfNull: bool) -> ...:
        ...
    @typing.overload
    def getJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    def getNumDependentDofs(self) -> int:
        ...
    def getNumDependentGenCoords(self) -> int:
        ...
    def getOrCreateIK(self) -> ...:
        ...
    def getWorldJacobian(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
class Joint(dartpy.common.Subject, EmbedProperties_Joint_JointProperties):
    def areLimitsEnforced(self) -> bool:
        ...
    @typing.overload
    def checkSanity(self) -> bool:
        ...
    @typing.overload
    def checkSanity(self, printWarnings: bool) -> bool:
        ...
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: Joint) -> None_:
        ...
    @typing.overload
    def copy(self, otherJoint: Joint) -> None_:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getActuatorType(self) -> ActuatorType:
        ...
    def isUsingCouplerConstraint(self) -> bool:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getChildBodyNode(self) -> BodyNode:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getForce(self, index: int) -> float:
        ...
    def getForceLowerLimit(self, index: int) -> float:
        ...
    def getForceLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForceUpperLimit(self, index: int) -> float:
        ...
    def getForceUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getJointIndexInSkeleton(self) -> int:
        ...
    def getJointIndexInTree(self) -> int:
        ...
    def getName(self) -> str:
        ...
    def getNumDofs(self) -> int:
        ...
    def getParentBodyNode(self) -> BodyNode:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def getRelativePrimaryAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeSpatialAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeSpatialVelocity(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeTransform(self) -> dartpy.math.Isometry3:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    @typing.overload
    def getSkeleton(self) -> ...:
        ...
    @typing.overload
    def getSkeleton(self) -> ...:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getTransformFromChildBodyNode(self) -> dartpy.math.Isometry3:
        ...
    def getTransformFromParentBodyNode(self) -> dartpy.math.Isometry3:
        ...
    def getTreeIndex(self) -> int:
        ...
    def getType(self) -> str:
        ...
    def getVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getWrenchToChildBodyNode(self, withRespectTo: Frame = None) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getWrenchToParentBodyNode(self, withRespectTo: Frame = None) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def hasJointAspect(self) -> bool:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None_:
        ...
    def integrateVelocities(self, dt: float) -> None_:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def isDynamic(self) -> bool:
        ...
    def isKinematic(self) -> bool:
        ...
    def notifyAccelerationUpdated(self) -> None_:
        ...
    def notifyPositionUpdated(self) -> None_:
        ...
    def notifyVelocityUpdated(self) -> None_:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None_:
        ...
    def releaseJointAspect(self) -> ...:
        ...
    def removeJointAspect(self) -> None_:
        ...
    def resetAccelerations(self) -> None_:
        ...
    def resetCommands(self) -> None_:
        ...
    def resetConstraintImpulses(self) -> None_:
        ...
    def resetForces(self) -> None_:
        ...
    def resetPosition(self, index: int) -> None_:
        ...
    def resetPositions(self) -> None_:
        ...
    def resetVelocities(self) -> None_:
        ...
    def resetVelocity(self, index: int) -> None_:
        ...
    def resetVelocityChanges(self) -> None_:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setActuatorType(self, actuatorType: ActuatorType) -> None_:
        ...
    def setUseCouplerConstraint(self, enable: bool) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_25: ...) -> None_:
        ...
    def setCommand(self, index: int, command: float) -> None_:
        ...
    def setCommands(self, commands: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None_:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None_:
        ...
    def setDampingCoefficient(self, index: int, coeff: float) -> None_:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setForce(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimit(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForceUpperLimit(self, index: int, force: float) -> None_:
        ...
    def setForceUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForces(self, forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None_:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None_:
        ...
    def setJointAspect(self, aspect: ..., dart_param_26: ...) -> None_:
        ...
    def setLimitEnforcement(self, enforced: bool) -> None_:
        ...
    @typing.overload
    def setName(self, name: str) -> str:
        ...
    @typing.overload
    def setName(self, name: str, renameDofs: bool) -> str:
        ...
    def setPosition(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositions(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setProperties(self, properties: JointProperties) -> None_:
        ...
    def setRestPosition(self, index: int, q0: float) -> None_:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None_:
        ...
    def setTransformFromChildBodyNode(self, T: dartpy.math.Isometry3) -> None_:
        ...
    def setTransformFromParentBodyNode(self, T: dartpy.math.Isometry3) -> None_:
        ...
    def setVelocities(self, velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocity(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None_:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class JointProperties:
    mActuatorType: ActuatorType
    mIsPositionLimitEnforced: bool
    mName: str
    mT_ChildBodyToJoint: dartpy.math.Isometry3
    mT_ParentBodyToJoint: dartpy.math.Isometry3
    def __init__(self, name: str = 'Joint', T_ParentBodyToJoint: dartpy.math.Isometry3 = ..., T_ChildBodyToJoint: dartpy.math.Isometry3 = ..., isPositionLimitEnforced: bool = False, actuatorType: ActuatorType = ..., mimicJoint: ... = None, mimicMultiplier: float = 1.0, mimicOffset: float = 0.0) -> None_:
        ...
    @property
    def mMimicDofProps(self) -> ...:
        ...
    @mMimicDofProps.setter
    def mMimicDofProps(self, arg0: ..., std_param_27: ...) -> None_:
        ...
class LineSegmentShape(Shape):
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, thickness: float) -> None_:
        ...
    @typing.overload
    def __init__(self, v1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], v2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, v1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], v2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], thickness: float) -> None_:
        ...
    def addConnection(self, idx1: int, idx2: int) -> None_:
        ...
    @typing.overload
    def addVertex(self, v: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> int:
        ...
    @typing.overload
    def addVertex(self, v: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], parent: int) -> int:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getThickness(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def getVertex(self, idx: int) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def removeConnection(self, vertexIdx1: int, vertexIdx2: int) -> None_:
        ...
    @typing.overload
    def removeConnection(self, connectionIdx: int) -> None_:
        ...
    def removeVertex(self, idx: int) -> None_:
        ...
    def setThickness(self, thickness: float) -> None_:
        ...
    def setVertex(self, idx: int, v: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class Linkage(ReferentialSkeleton):
    @typing.overload
    def __init__(self, criteria: ...) -> None_:
        ...
    @typing.overload
    def __init__(self, criteria: ..., name: str) -> None_:
        ...
    @typing.overload
    def cloneLinkage(self) -> Linkage:
        ...
    @typing.overload
    def cloneLinkage(self, cloneName: str) -> Linkage:
        ...
    def cloneMetaSkeleton(self, cloneName: str) -> MetaSkeleton:
        ...
    def isAssembled(self) -> bool:
        ...
    def reassemble(self) -> None_:
        ...
    def satisfyCriteria(self) -> None_:
        ...
class LinkageCriteria:
    class ExpansionPolicy:
        """
        Members:
        
          INCLUDE
        
          EXCLUDE
        
          DOWNSTREAM
        
          UPSTREAM
        """
        DOWNSTREAM: typing.ClassVar[LinkageCriteria.ExpansionPolicy]  # value = <ExpansionPolicy.DOWNSTREAM: 2>
        EXCLUDE: typing.ClassVar[LinkageCriteria.ExpansionPolicy]  # value = <ExpansionPolicy.EXCLUDE: 1>
        INCLUDE: typing.ClassVar[LinkageCriteria.ExpansionPolicy]  # value = <ExpansionPolicy.INCLUDE: 0>
        UPSTREAM: typing.ClassVar[LinkageCriteria.ExpansionPolicy]  # value = <ExpansionPolicy.UPSTREAM: 3>
        __members__: typing.ClassVar[dict[str, LinkageCriteria.ExpansionPolicy]]  # value = {'INCLUDE': <ExpansionPolicy.INCLUDE: 0>, 'EXCLUDE': <ExpansionPolicy.EXCLUDE: 1>, 'DOWNSTREAM': <ExpansionPolicy.DOWNSTREAM: 2>, 'UPSTREAM': <ExpansionPolicy.UPSTREAM: 3>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None_:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None_:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class Target:
        mChain: bool
        mNode: ...
        mPolicy: LinkageCriteria.ExpansionPolicy
        @typing.overload
        def __init__(self) -> None_:
            ...
        @typing.overload
        def __init__(self, target: BodyNode) -> None_:
            ...
        @typing.overload
        def __init__(self, target: BodyNode, policy: LinkageCriteria.ExpansionPolicy) -> None_:
            ...
        @typing.overload
        def __init__(self, target: BodyNode, policy: LinkageCriteria.ExpansionPolicy, chain: bool) -> None_:
            ...
    class Terminal:
        mInclusive: bool
        mTerminal: ...
        @typing.overload
        def __init__(self) -> None_:
            ...
        @typing.overload
        def __init__(self, terminal: BodyNode) -> None_:
            ...
        @typing.overload
        def __init__(self, terminal: BodyNode, inclusive: bool) -> None_:
            ...
    DOWNSTREAM: typing.ClassVar[LinkageCriteria.ExpansionPolicy]  # value = <ExpansionPolicy.DOWNSTREAM: 2>
    EXCLUDE: typing.ClassVar[LinkageCriteria.ExpansionPolicy]  # value = <ExpansionPolicy.EXCLUDE: 1>
    INCLUDE: typing.ClassVar[LinkageCriteria.ExpansionPolicy]  # value = <ExpansionPolicy.INCLUDE: 0>
    UPSTREAM: typing.ClassVar[LinkageCriteria.ExpansionPolicy]  # value = <ExpansionPolicy.UPSTREAM: 3>
    mStart: ...
    def satisfy(self) -> ...:
        ...
    @property
    def mTargets(self) -> ...:
        ...
    @mTargets.setter
    def mTargets(self, arg0: ..., std_param_28: ...) -> None_:
        ...
    @property
    def mTerminals(self) -> ...:
        ...
    @mTerminals.setter
    def mTerminals(self, arg0: ..., std_param_29: ...) -> None_:
        ...
class MeshShape(Shape):
    class ColorMode:
        """
        Members:
        
          MATERIAL_COLOR
        
          COLOR_INDEX
        
          SHAPE_COLOR
        """
        COLOR_INDEX: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.COLOR_INDEX: 1>
        MATERIAL_COLOR: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.MATERIAL_COLOR: 0>
        SHAPE_COLOR: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.SHAPE_COLOR: 2>
        __members__: typing.ClassVar[dict[str, MeshShape.ColorMode]]  # value = {'MATERIAL_COLOR': <ColorMode.MATERIAL_COLOR: 0>, 'COLOR_INDEX': <ColorMode.COLOR_INDEX: 1>, 'SHAPE_COLOR': <ColorMode.SHAPE_COLOR: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None_:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None_:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    COLOR_INDEX: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.COLOR_INDEX: 1>
    MATERIAL_COLOR: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.MATERIAL_COLOR: 0>
    SHAPE_COLOR: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.SHAPE_COLOR: 2>
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], mesh: aiScene) -> None_:
        ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], mesh: aiScene, uri: dartpy.common.Uri) -> None_:
        ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], mesh: aiScene, uri: dartpy.common.Uri, resourceRetriever: dartpy.common.ResourceRetriever) -> None_:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getColorIndex(self) -> int:
        ...
    def getColorMode(self) -> ...:
        ...
    def getDisplayList(self) -> int:
        ...
    def getMeshPath(self) -> str:
        ...
    def getMeshUri(self) -> str:
        ...
    def getMeshUri2(self) -> dartpy.common.Uri:
        ...
    def getResourceRetriever(self) -> dartpy.common.ResourceRetriever:
        ...
    def getScale(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getType(self) -> str:
        ...
    def notifyAlphaUpdated(self, alpha: float) -> None_:
        ...
    def setColorIndex(self, index: int) -> None_:
        ...
    def setColorMode(self, mode: ...) -> None_:
        ...
    def setDisplayList(self, index: int) -> None_:
        ...
    @typing.overload
    def setMesh(self, mesh: aiScene) -> None_:
        ...
    @typing.overload
    def setMesh(self, mesh: aiScene, path: str) -> None_:
        ...
    @typing.overload
    def setMesh(self, mesh: aiScene, path: str, resourceRetriever: dartpy.common.ResourceRetriever) -> None_:
        ...
    @typing.overload
    def setMesh(self, mesh: aiScene, path: dartpy.common.Uri) -> None_:
        ...
    @typing.overload
    def setMesh(self, mesh: aiScene, path: dartpy.common.Uri, resourceRetriever: dartpy.common.ResourceRetriever) -> None_:
        ...
    @typing.overload
    def setScale(self, scale: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setScale(self, scale: float) -> None_:
        ...
    def update(self) -> None_:
        ...
class MetaSkeleton:
    def clearExternalForces(self) -> None_:
        ...
    def clearInternalForces(self) -> None_:
        ...
    @typing.overload
    def cloneMetaSkeleton(self, cloneName: str) -> MetaSkeleton:
        ...
    @typing.overload
    def cloneMetaSkeleton(self) -> MetaSkeleton:
        ...
    def computeKineticEnergy(self) -> float:
        ...
    def computeLagrangian(self) -> float:
        ...
    def computePotentialEnergy(self) -> float:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getAccelerationLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAccelerationLowerLimits(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getAccelerationUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAccelerationUpperLimits(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAccelerations(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAccelerations(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, relativeTo: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    def getAugMassMatrix(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getBodyNode(self, index: int) -> BodyNode:
        ...
    @typing.overload
    def getBodyNode(self, treeIndex: str) -> BodyNode:
        ...
    @typing.overload
    def getBodyNodes(self, name: str) -> list[BodyNode]:
        ...
    @typing.overload
    def getBodyNodes(self, name: str) -> list[BodyNode]:
        ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobian(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    @typing.overload
    def getCommands(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCommands(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getConstraintForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getCoriolisAndGravityForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getCoriolisForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getDof(self, index: int) -> DegreeOfFreedom:
        ...
    def getDofs(self) -> list[DegreeOfFreedom]:
        ...
    def getExternalForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForce(self, index: int) -> float:
        ...
    def getForceLowerLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getForceLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getForceLowerLimits(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForceUpperLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getForceUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getForceUpperLimits(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getForces(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getGravityForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode) -> int:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom, warning: bool) -> int:
        ...
    def getInvMassMatrix(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJoint(self, index: int) -> Joint:
        ...
    @typing.overload
    def getJoint(self, name: str) -> Joint:
        ...
    def getJointConstraintImpulses(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJoints(self, name: str) -> list[Joint]:
        ...
    @typing.overload
    def getJoints(self, name: str) -> list[Joint]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, relativeTo: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    def getLockableReference(self) -> ...:
        ...
    def getMass(self) -> float:
        ...
    def getMassMatrix(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]:
        ...
    def getName(self) -> str:
        ...
    def getNumBodyNodes(self) -> int:
        ...
    def getNumDofs(self) -> int:
        ...
    def getNumJoints(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getPositionLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getPositionLowerLimits(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getPositionUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getPositionUpperLimits(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getPositions(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getVelocities(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChanges(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getVelocityLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getVelocityLowerLimits(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getVelocityUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getVelocityUpperLimits(self, indices: list[int]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def hasBodyNode(self, bodyNode: BodyNode) -> bool:
        ...
    def hasJoint(self, joint: Joint) -> bool:
        ...
    def resetAccelerations(self) -> None_:
        ...
    def resetCommands(self) -> None_:
        ...
    def resetGeneralizedForces(self) -> None_:
        ...
    def resetPositions(self) -> None_:
        ...
    def resetVelocities(self) -> None_:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None_:
        ...
    @typing.overload
    def setAccelerationLowerLimits(self, accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setAccelerationLowerLimits(self, indices: list[int], accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None_:
        ...
    @typing.overload
    def setAccelerationUpperLimits(self, accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setAccelerationUpperLimits(self, indices: list[int], accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setAccelerations(self, accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setAccelerations(self, indices: list[int], accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAlpha(self, alpha: float) -> None_:
        ...
    @typing.overload
    def setColor(self, color: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setColor(self, color: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setCommand(self, index: int, command: float) -> None_:
        ...
    @typing.overload
    def setCommands(self, commands: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setCommands(self, indices: list[int], commands: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForce(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimit(self, index: int, force: float) -> None_:
        ...
    @typing.overload
    def setForceLowerLimits(self, forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setForceLowerLimits(self, indices: list[int], forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForceUpperLimit(self, index: int, force: float) -> None_:
        ...
    @typing.overload
    def setForceUpperLimits(self, forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setForceUpperLimits(self, indices: list[int], forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setForces(self, forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setForces(self, index: list[int], forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setJointConstraintImpulses(self, impulses: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setName(self, name: str) -> str:
        ...
    def setPosition(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None_:
        ...
    @typing.overload
    def setPositionLowerLimits(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setPositionLowerLimits(self, indices: list[int], positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None_:
        ...
    @typing.overload
    def setPositionUpperLimits(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setPositionUpperLimits(self, indices: list[int], positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setPositions(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setPositions(self, indices: list[int], positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setVelocities(self, velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setVelocities(self, indices: list[int], velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocity(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None_:
        ...
    @typing.overload
    def setVelocityLowerLimits(self, velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setVelocityLowerLimits(self, indices: list[int], velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None_:
        ...
    @typing.overload
    def setVelocityUpperLimits(self, velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setVelocityUpperLimits(self, indices: list[int], velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class MimicDofProperties:
    mConstraintType: MimicConstraintType
    mMultiplier: float
    mOffset: float
    mReferenceDofIndex: int
    mReferenceJoint: ...
    def __init__(self) -> None_:
        ...
class MultiSphereConvexHullShape(Shape):
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, spheres: list[tuple[float, numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]]]) -> None_:
        ...
    @typing.overload
    def addSphere(self, sphere: tuple[float, numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]]) -> None_:
        ...
    @typing.overload
    def addSphere(self, radius: float, position: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def addSpheres(self, spheres: list[tuple[float, numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]]]) -> None_:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getNumSpheres(self) -> int:
        ...
    def getType(self) -> str:
        ...
    def removeAllSpheres(self) -> None_:
        ...
class Node(dartpy.common.Subject):
    def getBodyNode(self) -> ...:
        ...
    @typing.overload
    def getBodyNodePtr(self) -> ...:
        ...
    @typing.overload
    def getBodyNodePtr(self) -> ...:
        ...
    def getName(self) -> str:
        ...
    def getNodeProperties(self) -> ...:
        ...
    def getNodeState(self) -> ...:
        ...
    @typing.overload
    def getSkeleton(self) -> ...:
        ...
    @typing.overload
    def getSkeleton(self) -> ...:
        ...
    def isRemoved(self) -> bool:
        ...
    def setName(self, newName: str) -> str:
        ...
    def setNodeProperties(self, properties: ...) -> None_:
        ...
    def setNodeState(self, otherState: ...) -> None_:
        ...
class PlanarJoint(EmbedPropertiesOnTopOf_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: PlanarJoint) -> None_:
        ...
    def getPlanarJointProperties(self) -> PlanarJointProperties:
        ...
    def getPlaneType(self) -> ...:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getRotationalAxis(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getTranslationalAxis1(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getTranslationalAxis2(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getType(self) -> str:
        ...
    def hasPlanarJointAspect(self) -> bool:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def releasePlanarJointAspect(self) -> ...:
        ...
    def removePlanarJointAspect(self) -> None_:
        ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], transAxis2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], transAxis2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], renameDofs: bool) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_27: ...) -> None_:
        ...
    def setPlanarJointAspect(self, aspect: ..., dart_param_28: ...) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: PlanarJointProperties) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: PlanarJointUniqueProperties) -> None_:
        ...
    @typing.overload
    def setXYPlane(self) -> None_:
        ...
    @typing.overload
    def setXYPlane(self, renameDofs: bool) -> None_:
        ...
    @typing.overload
    def setYZPlane(self) -> None_:
        ...
    @typing.overload
    def setYZPlane(self, renameDofs: bool) -> None_:
        ...
    @typing.overload
    def setZXPlane(self) -> None_:
        ...
    @typing.overload
    def setZXPlane(self, renameDofs: bool) -> None_:
        ...
class PlanarJointProperties(GenericJointProperties_R3, PlanarJointUniqueProperties):
    mPlaneType: ...
    mRotAxis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mTransAxis1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mTransAxis2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R3) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R3, uniqueProperties: PlanarJointUniqueProperties) -> None_:
        ...
class PlanarJointUniqueProperties:
    def __init__(self) -> None_:
        ...
class PlaneShape(Shape):
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self, normal: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], offset: float) -> None_:
        ...
    @typing.overload
    def __init__(self, normal: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], point: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def computeDistance(self, point: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> float:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def computeSignedDistance(self, point: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> float:
        ...
    def getNormal(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getOffset(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def setNormal(self, normal: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setNormalAndOffset(self, normal: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], offset: float) -> None_:
        ...
    def setNormalAndPoint(self, normal: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], point: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setOffset(self, offset: float) -> None_:
        ...
class PointCloudShape(Shape):
    class ColorMode:
        """
        Members:
        
          USE_SHAPE_COLOR
        
          BIND_OVERALL
        
          BIND_PER_POINT
        """
        BIND_OVERALL: typing.ClassVar[PointCloudShape.ColorMode]  # value = <ColorMode.BIND_OVERALL: 1>
        BIND_PER_POINT: typing.ClassVar[PointCloudShape.ColorMode]  # value = <ColorMode.BIND_PER_POINT: 2>
        USE_SHAPE_COLOR: typing.ClassVar[PointCloudShape.ColorMode]  # value = <ColorMode.USE_SHAPE_COLOR: 0>
        __members__: typing.ClassVar[dict[str, PointCloudShape.ColorMode]]  # value = {'USE_SHAPE_COLOR': <ColorMode.USE_SHAPE_COLOR: 0>, 'BIND_OVERALL': <ColorMode.BIND_OVERALL: 1>, 'BIND_PER_POINT': <ColorMode.BIND_PER_POINT: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None_:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None_:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class PointShapeType:
        """
        Members:
        
          BOX
        
          BILLBOARD_SQUARE
        
          BILLBOARD_CIRCLE
        """
        BILLBOARD_CIRCLE: typing.ClassVar[PointCloudShape.PointShapeType]  # value = <PointShapeType.BILLBOARD_CIRCLE: 2>
        BILLBOARD_SQUARE: typing.ClassVar[PointCloudShape.PointShapeType]  # value = <PointShapeType.BILLBOARD_SQUARE: 1>
        BOX: typing.ClassVar[PointCloudShape.PointShapeType]  # value = <PointShapeType.BOX: 0>
        __members__: typing.ClassVar[dict[str, PointCloudShape.PointShapeType]]  # value = {'BOX': <PointShapeType.BOX: 0>, 'BILLBOARD_SQUARE': <PointShapeType.BILLBOARD_SQUARE: 1>, 'BILLBOARD_CIRCLE': <PointShapeType.BILLBOARD_CIRCLE: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None_:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None_:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    BILLBOARD_CIRCLE: typing.ClassVar[PointCloudShape.PointShapeType]  # value = <PointShapeType.BILLBOARD_CIRCLE: 2>
    BILLBOARD_SQUARE: typing.ClassVar[PointCloudShape.PointShapeType]  # value = <PointShapeType.BILLBOARD_SQUARE: 1>
    BIND_OVERALL: typing.ClassVar[PointCloudShape.ColorMode]  # value = <ColorMode.BIND_OVERALL: 1>
    BIND_PER_POINT: typing.ClassVar[PointCloudShape.ColorMode]  # value = <ColorMode.BIND_PER_POINT: 2>
    BOX: typing.ClassVar[PointCloudShape.PointShapeType]  # value = <PointShapeType.BOX: 0>
    USE_SHAPE_COLOR: typing.ClassVar[PointCloudShape.ColorMode]  # value = <ColorMode.USE_SHAPE_COLOR: 0>
    def __init__(self, visualSize: float = 0.01) -> None_:
        ...
    @typing.overload
    def addPoint(self, point: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def addPoint(self, points: list[numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]]) -> None_:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getColorMode(self) -> ...:
        ...
    def getColors(self) -> list[numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]]:
        ...
    def getNumPoints(self) -> int:
        ...
    def getOverallColor(self) -> numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPointShapeType(self) -> ...:
        ...
    def getPoints(self) -> list[numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]]:
        ...
    def getType(self) -> str:
        ...
    def getVisualSize(self) -> float:
        ...
    def notifyColorUpdated(self, color: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def removeAllPoints(self) -> None_:
        ...
    def reserve(self, size: int) -> None_:
        ...
    def setColorMode(self, mode: ...) -> None_:
        ...
    def setColors(self, colors: list[numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]]) -> None_:
        ...
    def setOverallColor(self, color: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPoint(self, points: list[numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]]) -> None_:
        ...
    def setPointShapeType(self, type: ...) -> None_:
        ...
    def setVisualSize(self, size: float) -> None_:
        ...
class PrismaticJoint(EmbedPropertiesOnTopOf_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: PrismaticJoint) -> None_:
        ...
    def getAxis(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPrismaticJointProperties(self) -> PrismaticJointProperties:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getType(self) -> str:
        ...
    def hasPrismaticJointAspect(self) -> bool:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def releasePrismaticJointAspect(self) -> ...:
        ...
    def removePrismaticJointAspect(self) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_29: ...) -> None_:
        ...
    def setAxis(self, axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPrismaticJointAspect(self, aspect: ..., dart_param_30: ...) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: PrismaticJointProperties) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: PrismaticJointUniqueProperties) -> None_:
        ...
class PrismaticJointProperties(GenericJointProperties_R1, PrismaticJointUniqueProperties):
    mAxis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R1) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R1, revoluteProperties: PrismaticJointUniqueProperties) -> None_:
        ...
class PrismaticJointUniqueProperties:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class ReferentialSkeleton(MetaSkeleton):
    def clearExternalForces(self) -> None_:
        ...
    def clearInternalForces(self) -> None_:
        ...
    def computeKineticEnergy(self) -> float:
        ...
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getBodyNodes(self, name: str) -> ...:
        ...
    @typing.overload
    def getBodyNodes(self, name: str) -> ...:
        ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobian(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getDofs(self) -> ...:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode) -> int:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom, warning: bool) -> int:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJoints(self, name: str) -> ...:
        ...
    @typing.overload
    def getJoints(self, name: str) -> ...:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    def getLockableReference(self) -> ...:
        ...
    def getMass(self) -> float:
        ...
    def getName(self) -> str:
        ...
    def getNumBodyNodes(self) -> int:
        ...
    def getNumDofs(self) -> int:
        ...
    def getNumJoints(self) -> int:
        ...
    def getNumSkeletons(self) -> int:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def hasBodyNode(self, bodyNode: BodyNode) -> bool:
        ...
    def hasJoint(self, joint: Joint) -> bool:
        ...
    def hasSkeleton(self, skel: ...) -> bool:
        ...
    def setName(self, name: str) -> str:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_Joint_JointProperties(SpecializedForAspect_EmbeddedPropertiesAspect_Joint_JointProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None_:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None_:
        ...
class RevoluteJoint(EmbedPropertiesOnTopOf_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: RevoluteJoint) -> None_:
        ...
    def getAxis(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRevoluteJointProperties(self) -> RevoluteJointProperties:
        ...
    def getType(self) -> str:
        ...
    def hasRevoluteJointAspect(self) -> bool:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def releaseRevoluteJointAspect(self) -> ...:
        ...
    def removeRevoluteJointAspect(self) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_31: ...) -> None_:
        ...
    def setAxis(self, axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: RevoluteJointProperties) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: RevoluteJointUniqueProperties) -> None_:
        ...
    def setRevoluteJointAspect(self, aspect: ..., dart_param_32: ...) -> None_:
        ...
class RevoluteJointProperties(GenericJointProperties_R1, RevoluteJointUniqueProperties):
    mAxis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R1) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R1, uniqueProperties: RevoluteJointUniqueProperties) -> None_:
        ...
class RevoluteJointUniqueProperties:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class ScrewJoint(EmbedPropertiesOnTopOf_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: ScrewJoint) -> None_:
        ...
    def getAxis(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPitch(self) -> float:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[1], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getScrewJointProperties(self) -> ScrewJointProperties:
        ...
    def getType(self) -> str:
        ...
    def hasScrewJointAspect(self) -> bool:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def releaseScrewJointAspect(self) -> ...:
        ...
    def removeScrewJointAspect(self) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_33: ...) -> None_:
        ...
    def setAxis(self, axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPitch(self, pitch: float) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: ScrewJointProperties) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: ScrewJointUniqueProperties) -> None_:
        ...
    def setScrewJointAspect(self, aspect: ..., dart_param_34: ...) -> None_:
        ...
class ScrewJointProperties(GenericJointProperties_R1, ScrewJointUniqueProperties):
    mAxis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]
    mPitch: float
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R1) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R1, revoluteProperties: ScrewJointUniqueProperties) -> None_:
        ...
class ScrewJointUniqueProperties:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], pitch: float) -> None_:
        ...
class Shape(dartpy.common.Subject):
    class DataVariance:
        """
        Members:
        
          STATIC
        
          DYNAMIC_TRANSFORM
        
          DYNAMIC_PRIMITIVE
        
          DYNAMIC_COLOR
        
          DYNAMIC_VERTICES
        
          DYNAMIC_ELEMENTS
        
          DYNAMIC
        """
        DYNAMIC: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC: 255>
        DYNAMIC_COLOR: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC_COLOR: 8>
        DYNAMIC_ELEMENTS: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC_ELEMENTS: 32>
        DYNAMIC_PRIMITIVE: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC_PRIMITIVE: 4>
        DYNAMIC_TRANSFORM: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC_TRANSFORM: 2>
        DYNAMIC_VERTICES: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC_VERTICES: 16>
        STATIC: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.STATIC: 0>
        __members__: typing.ClassVar[dict[str, Shape.DataVariance]]  # value = {'STATIC': <DataVariance.STATIC: 0>, 'DYNAMIC_TRANSFORM': <DataVariance.DYNAMIC_TRANSFORM: 2>, 'DYNAMIC_PRIMITIVE': <DataVariance.DYNAMIC_PRIMITIVE: 4>, 'DYNAMIC_COLOR': <DataVariance.DYNAMIC_COLOR: 8>, 'DYNAMIC_VERTICES': <DataVariance.DYNAMIC_VERTICES: 16>, 'DYNAMIC_ELEMENTS': <DataVariance.DYNAMIC_ELEMENTS: 32>, 'DYNAMIC': <DataVariance.DYNAMIC: 255>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None_:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None_:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class ShapeType:
        """
        Members:
        
          SPHERE
        
          BOX
        
          ELLIPSOID
        
          CYLINDER
        
          CAPSULE
        
          CONE
        
          PLANE
        
          MULTISPHERE
        
          MESH
        
          SOFT_MESH
        
          LINE_SEGMENT
        
          HEIGHTMAP
        
          UNSUPPORTED
        """
        BOX: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.BOX: 1>
        CAPSULE: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.CAPSULE: 4>
        CONE: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.CONE: 5>
        CYLINDER: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.CYLINDER: 3>
        ELLIPSOID: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.ELLIPSOID: 2>
        HEIGHTMAP: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.HEIGHTMAP: 13>
        LINE_SEGMENT: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.LINE_SEGMENT: 12>
        MESH: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.MESH: 10>
        MULTISPHERE: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.MULTISPHERE: 9>
        PLANE: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.PLANE: 8>
        SOFT_MESH: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.SOFT_MESH: 11>
        SPHERE: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.SPHERE: 0>
        UNSUPPORTED: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.UNSUPPORTED: 14>
        __members__: typing.ClassVar[dict[str, Shape.ShapeType]]  # value = {'SPHERE': <ShapeType.SPHERE: 0>, 'BOX': <ShapeType.BOX: 1>, 'ELLIPSOID': <ShapeType.ELLIPSOID: 2>, 'CYLINDER': <ShapeType.CYLINDER: 3>, 'CAPSULE': <ShapeType.CAPSULE: 4>, 'CONE': <ShapeType.CONE: 5>, 'PLANE': <ShapeType.PLANE: 8>, 'MULTISPHERE': <ShapeType.MULTISPHERE: 9>, 'MESH': <ShapeType.MESH: 10>, 'SOFT_MESH': <ShapeType.SOFT_MESH: 11>, 'LINE_SEGMENT': <ShapeType.LINE_SEGMENT: 12>, 'HEIGHTMAP': <ShapeType.HEIGHTMAP: 13>, 'UNSUPPORTED': <ShapeType.UNSUPPORTED: 14>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None_:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None_:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    BOX: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.BOX: 1>
    CAPSULE: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.CAPSULE: 4>
    CONE: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.CONE: 5>
    CYLINDER: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.CYLINDER: 3>
    DYNAMIC: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC: 255>
    DYNAMIC_COLOR: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC_COLOR: 8>
    DYNAMIC_ELEMENTS: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC_ELEMENTS: 32>
    DYNAMIC_PRIMITIVE: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC_PRIMITIVE: 4>
    DYNAMIC_TRANSFORM: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC_TRANSFORM: 2>
    DYNAMIC_VERTICES: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.DYNAMIC_VERTICES: 16>
    ELLIPSOID: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.ELLIPSOID: 2>
    HEIGHTMAP: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.HEIGHTMAP: 13>
    LINE_SEGMENT: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.LINE_SEGMENT: 12>
    MESH: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.MESH: 10>
    MULTISPHERE: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.MULTISPHERE: 9>
    PLANE: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.PLANE: 8>
    SOFT_MESH: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.SOFT_MESH: 11>
    SPHERE: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.SPHERE: 0>
    STATIC: typing.ClassVar[Shape.DataVariance]  # value = <DataVariance.STATIC: 0>
    UNSUPPORTED: typing.ClassVar[Shape.ShapeType]  # value = <ShapeType.UNSUPPORTED: 14>
    def addDataVariance(self, variance: int) -> None_:
        ...
    def checkDataVariance(self, type: ...) -> bool:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def computeInertiaFromDensity(self, density: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def computeInertiaFromMass(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getBoundingBox(self) -> ...:
        ...
    def getDataVariance(self) -> int:
        ...
    def getID(self) -> int:
        ...
    def getType(self) -> str:
        ...
    def getVolume(self) -> float:
        ...
    def incrementVersion(self) -> int:
        ...
    def notifyAlphaUpdated(self, alpha: float) -> None_:
        ...
    def notifyColorUpdated(self, color: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def refreshData(self) -> None_:
        ...
    def removeDataVariance(self, variance: int) -> None_:
        ...
    def setDataVariance(self, variance: int) -> None_:
        ...
    @property
    def onVersionChanged(self) -> ...:
        ...
class ShapeFrame(Frame):
    @typing.overload
    def asShapeNode(self) -> ...:
        """
        Convert to a ShapeNode pointer if ShapeFrame is a ShapeNode, otherwise return None.
        """
    @typing.overload
    def asShapeNode(self) -> ...:
        """
        Convert to a ShapeNode pointer if ShapeFrame is a ShapeNode, otherwise return None.
        """
    def createCollisionAspect(self) -> ...:
        ...
    def createDynamicsAspect(self) -> ...:
        ...
    def createVisualAspect(self) -> ...:
        ...
    @typing.overload
    def getCollisionAspect(self) -> ...:
        ...
    @typing.overload
    def getCollisionAspect(self, createIfNull: bool) -> ...:
        ...
    @typing.overload
    def getDynamicsAspect(self) -> ...:
        ...
    @typing.overload
    def getDynamicsAspect(self, createIfNull: bool) -> ...:
        ...
    @typing.overload
    def getShape(self) -> Shape:
        ...
    @typing.overload
    def getShape(self) -> Shape:
        ...
    @typing.overload
    def getVisualAspect(self) -> ...:
        ...
    @typing.overload
    def getVisualAspect(self, createIfNull: bool) -> ...:
        ...
    def hasCollisionAspect(self) -> bool:
        ...
    def hasDynamicsAspect(self) -> bool:
        ...
    def hasVisualAspect(self) -> bool:
        ...
    def isShapeNode(self) -> bool:
        ...
    def releaseCollisionAspect(self) -> ...:
        ...
    def releaseDynamicsAspect(self) -> ...:
        ...
    def releaseVisualAspect(self) -> ...:
        ...
    def removeCollisionAspect(self) -> None_:
        ...
    def removeDynamicsAspect(self) -> None_:
        ...
    def removeVisualAspect(self) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_35: ...) -> None_:
        ...
    def setCollisionAspect(self, aspect: ...) -> None_:
        ...
    def setDynamicsAspect(self, aspect: ...) -> None_:
        ...
    def setProperties(self, properties: ..., dart_param_36: ...) -> None_:
        ...
    def setShape(self, shape: Shape) -> None_:
        ...
    def setVisualAspect(self, aspect: ...) -> None_:
        ...
class ShapeNode(JacobianNode, ShapeFrame, Node):
    def computeTransformedInertia(self, mass: float) -> Inertia:
        ...
    def computeTransformedInertiaFromDensity(self, density: float) -> Inertia:
        ...
    def copy(self, other: ShapeNode) -> None_:
        ...
    def getOffset(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeRotation(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeTranslation(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getShapeNodeProperties(self) -> ...:
        ...
    def setOffset(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setProperties(self, properties: ..., std_param_30: ..., std_param_31: ..., std_param_32: ..., std_param_33: ..., std_param_34: ..., std_param_35: ..., dart_param_37: ...) -> None_:
        ...
    def setRelativeRotation(self, rotation: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setRelativeTransform(self, transform: dartpy.math.Isometry3) -> None_:
        ...
    def setRelativeTranslation(self, translation: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class SimpleFrame(ShapeFrame, Detachable):
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, refFrame: Frame) -> None_:
        ...
    @typing.overload
    def __init__(self, refFrame: Frame, name: str) -> None_:
        ...
    @typing.overload
    def __init__(self, refFrame: Frame, name: str, relativeTransform: dartpy.math.Isometry3) -> None_:
        ...
    @typing.overload
    def clone(self) -> SimpleFrame:
        ...
    @typing.overload
    def clone(self, refFrame: Frame) -> SimpleFrame:
        ...
    @typing.overload
    def copy(self, otherFrame: Frame) -> None_:
        ...
    @typing.overload
    def copy(self, otherFrame: Frame, refFrame: Frame) -> None_:
        ...
    @typing.overload
    def copy(self, otherFrame: Frame, refFrame: Frame, copyProperties: bool) -> None_:
        ...
    def getName(self) -> str:
        ...
    @typing.overload
    def setClassicDerivatives(self) -> None_:
        ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], angularVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], angularVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], linearAcceleration: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], angularVelocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], linearAcceleration: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], angularAcceleration: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setName(self, name: str) -> str:
        ...
    def setRelativeRotation(self, newRotation: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> None_:
        ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> None_:
        ...
    def setRelativeTransform(self, newRelTransform: dartpy.math.Isometry3) -> None_:
        ...
    def setRelativeTranslation(self, newTranslation: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setRotation(self, newRotation: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setRotation(self, newRotation: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]], withRespectTo: Frame) -> None_:
        ...
    @typing.overload
    def setTransform(self, newTransform: dartpy.math.Isometry3) -> None_:
        ...
    @typing.overload
    def setTransform(self, newTransform: dartpy.math.Isometry3, withRespectTo: Frame) -> None_:
        ...
    @typing.overload
    def setTranslation(self, newTranslation: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setTranslation(self, newTranslation: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], withRespectTo: Frame) -> None_:
        ...
    @typing.overload
    def spawnChildSimpleFrame(self) -> SimpleFrame:
        ...
    @typing.overload
    def spawnChildSimpleFrame(self, name: str) -> SimpleFrame:
        ...
    @typing.overload
    def spawnChildSimpleFrame(self, name: str, relativeTransform: dartpy.math.Isometry3) -> SimpleFrame:
        ...
class Skeleton(MetaSkeleton):
    mUnionIndex: int
    mUnionRootSkeleton: ...
    mUnionSize: int
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, name: str) -> None_:
        ...
    @typing.overload
    def __init__(self, properties: ...) -> None_:
        ...
    def checkIndexingConsistency(self) -> bool:
        ...
    def clearConstraintImpulses(self) -> None_:
        ...
    def clearExternalForces(self) -> None_:
        ...
    def clearIK(self) -> None_:
        ...
    def clearInternalForces(self) -> None_:
        ...
    @typing.overload
    def clone(self) -> Skeleton:
        ...
    @typing.overload
    def clone(self, cloneName: str) -> Skeleton:
        ...
    def computeForwardDynamics(self) -> None_:
        ...
    @typing.overload
    def computeForwardKinematics(self) -> None_:
        ...
    @typing.overload
    def computeForwardKinematics(self, updateTransforms: bool) -> None_:
        ...
    @typing.overload
    def computeForwardKinematics(self, updateTransforms: bool, updateVels: bool) -> None_:
        ...
    @typing.overload
    def computeForwardKinematics(self, updateTransforms: bool, updateVels: bool, updateAccs: bool) -> None_:
        ...
    def computeImpulseForwardDynamics(self) -> None_:
        ...
    @typing.overload
    def computeInverseDynamics(self) -> None_:
        ...
    @typing.overload
    def computeInverseDynamics(self, withExternalForces: bool) -> None_:
        ...
    @typing.overload
    def computeInverseDynamics(self, withExternalForces: bool, withDampingForces: bool) -> None_:
        ...
    @typing.overload
    def computeInverseDynamics(self, withExternalForces: bool, withDampingForces: bool, withSpringForces: bool) -> None_:
        ...
    def computeKineticEnergy(self) -> float:
        ...
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self) -> tuple[BallJoint, BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, parent: BodyNode) -> tuple[BallJoint, BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, parent: BodyNode, jointProperties: BallJointProperties) -> tuple[BallJoint, BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, parent: BodyNode, jointProperties: BallJointProperties, bodyProperties: BodyNodeProperties) -> tuple[BallJoint, BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self) -> tuple[EulerJoint, BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, parent: BodyNode) -> tuple[EulerJoint, BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, parent: BodyNode, jointProperties: EulerJointProperties) -> tuple[EulerJoint, BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, parent: BodyNode, jointProperties: EulerJointProperties, bodyProperties: BodyNodeProperties) -> tuple[EulerJoint, BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self) -> tuple[FreeJoint, BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, parent: BodyNode) -> tuple[FreeJoint, BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, parent: BodyNode, jointProperties: FreeJointProperties) -> tuple[FreeJoint, BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, parent: BodyNode, jointProperties: FreeJointProperties, bodyProperties: BodyNodeProperties) -> tuple[FreeJoint, BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self) -> tuple[PlanarJoint, BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, parent: BodyNode) -> tuple[PlanarJoint, BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PlanarJointProperties) -> tuple[PlanarJoint, BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PlanarJointProperties, bodyProperties: BodyNodeProperties) -> tuple[PlanarJoint, BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self) -> tuple[PrismaticJoint, BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, parent: BodyNode) -> tuple[PrismaticJoint, BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PrismaticJointProperties) -> tuple[PrismaticJoint, BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PrismaticJointProperties, bodyProperties: BodyNodeProperties) -> tuple[PrismaticJoint, BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self) -> tuple[RevoluteJoint, BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, parent: BodyNode) -> tuple[RevoluteJoint, BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, parent: BodyNode, jointProperties: RevoluteJointProperties) -> tuple[RevoluteJoint, BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, parent: BodyNode, jointProperties: RevoluteJointProperties, bodyProperties: BodyNodeProperties) -> tuple[RevoluteJoint, BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self) -> tuple[ScrewJoint, BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, parent: BodyNode) -> tuple[ScrewJoint, BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, parent: BodyNode, jointProperties: ScrewJointProperties) -> tuple[ScrewJoint, BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, parent: BodyNode, jointProperties: ScrewJointProperties, bodyProperties: BodyNodeProperties) -> tuple[ScrewJoint, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self) -> tuple[TranslationalJoint2D, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, parent: BodyNode) -> tuple[TranslationalJoint2D, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJoint2DProperties) -> tuple[TranslationalJoint2D, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJoint2DProperties, bodyProperties: BodyNodeProperties) -> tuple[TranslationalJoint2D, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self) -> tuple[TranslationalJoint, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, parent: BodyNode) -> tuple[TranslationalJoint, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJointProperties) -> tuple[TranslationalJoint, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJointProperties, bodyProperties: BodyNodeProperties) -> tuple[TranslationalJoint, BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self) -> tuple[UniversalJoint, BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, parent: BodyNode) -> tuple[UniversalJoint, BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: UniversalJointProperties) -> tuple[UniversalJoint, BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: UniversalJointProperties, bodyProperties: BodyNodeProperties) -> tuple[UniversalJoint, BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self) -> tuple[WeldJoint, BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, parent: BodyNode) -> tuple[WeldJoint, BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, parent: BodyNode, jointProperties: ...) -> tuple[WeldJoint, BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, parent: BodyNode, jointProperties: ..., bodyProperties: BodyNodeProperties) -> tuple[WeldJoint, BodyNode]:
        ...
    def dirtyArticulatedInertia(self, treeIdx: int) -> None_:
        ...
    def dirtySupportPolygon(self, treeIdx: int) -> None_:
        ...
    def disableAdjacentBodyCheck(self) -> None_:
        ...
    def disableSelfCollisionCheck(self) -> None_:
        ...
    def enableAdjacentBodyCheck(self) -> None_:
        ...
    def enableSelfCollisionCheck(self) -> None_:
        ...
    def getAdjacentBodyCheck(self) -> bool:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAugMassMatrix(self, arg0: int) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAugMassMatrix(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getBodyNodes(self, name: str) -> list[BodyNode]:
        ...
    @typing.overload
    def getBodyNodes(self, name: str) -> list[BodyNode]:
        ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobian(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getConfiguration(self) -> ...:
        ...
    @typing.overload
    def getConfiguration(self, flags: int) -> ...:
        ...
    @typing.overload
    def getConfiguration(self, indices: list[int]) -> ...:
        ...
    @typing.overload
    def getConfiguration(self, indices: list[int], flags: int) -> ...:
        ...
    @typing.overload
    def getConstraintForces(self, arg0: int) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getConstraintForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCoriolisAndGravityForces(self, arg0: int) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCoriolisAndGravityForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCoriolisForces(self, arg0: int) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getCoriolisForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getDof(self, index: int) -> DegreeOfFreedom:
        ...
    @typing.overload
    def getDof(self, name: str) -> DegreeOfFreedom:
        ...
    def getDofs(self) -> list[DegreeOfFreedom]:
        ...
    @typing.overload
    def getExternalForces(self, arg0: int) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getExternalForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getGravity(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getGravityForces(self, arg0: int) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getGravityForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getIK(self) -> ...:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode) -> int:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom, warning: bool) -> int:
        ...
    @typing.overload
    def getInvMassMatrix(self, arg0: int) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getInvMassMatrix(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJoint(self, idx: int) -> Joint:
        ...
    @typing.overload
    def getJoint(self, name: str) -> Joint:
        ...
    @typing.overload
    def getJoints(self, name: str) -> list[Joint]:
        ...
    @typing.overload
    def getJoints(self, name: str) -> list[Joint]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    def getLockableReference(self) -> ...:
        ...
    def getMass(self) -> float:
        ...
    @typing.overload
    def getMassMatrix(self, arg0: int) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getMassMatrix(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]:
        ...
    def getName(self) -> str:
        ...
    def getNumBodyNodes(self) -> int:
        ...
    def getNumDofs(self) -> int:
        ...
    @typing.overload
    def getNumEndEffectors(self) -> int:
        ...
    @typing.overload
    def getNumEndEffectors(self, treeIndex: int) -> int:
        ...
    def getNumJoints(self) -> int:
        ...
    @typing.overload
    def getNumMarkers(self) -> int:
        ...
    @typing.overload
    def getNumMarkers(self, treeIndex: int) -> int:
        ...
    def getNumRigidBodyNodes(self) -> int:
        ...
    @typing.overload
    def getNumShapeNodes(self) -> int:
        ...
    @typing.overload
    def getNumShapeNodes(self, treeIndex: int) -> int:
        ...
    def getNumSoftBodyNodes(self) -> int:
        ...
    def getNumTrees(self) -> int:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getProperties(self) -> ...:
        ...
    @typing.overload
    def getPtr(self) -> Skeleton:
        ...
    @typing.overload
    def getPtr(self) -> Skeleton:
        ...
    @typing.overload
    def getRootBodyNode(self) -> BodyNode:
        ...
    @typing.overload
    def getRootBodyNode(self, treeIndex: int) -> BodyNode:
        ...
    @typing.overload
    def getRootJoint(self) -> Joint:
        ...
    @typing.overload
    def getRootJoint(self, treeIndex: int) -> Joint:
        ...
    def getSelfCollisionCheck(self) -> bool:
        ...
    @typing.overload
    def getShapeNode(self, index: int) -> ShapeNode:
        ...
    @typing.overload
    def getShapeNode(self, name: str) -> ShapeNode:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    def getState(self) -> ...:
        ...
    @typing.overload
    def getSupportVersion(self) -> int:
        ...
    @typing.overload
    def getSupportVersion(self, treeIdx: int) -> int:
        ...
    def getTimeStep(self) -> float:
        ...
    def getTreeBodyNodes(self, treeIdx: int) -> list[BodyNode]:
        ...
    def getVelocityDifferences(self, dq2: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], dq1: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    def hasBodyNode(self, bodyNode: BodyNode) -> bool:
        ...
    def hasJoint(self, joint: Joint) -> bool:
        ...
    def integratePositions(self, dt: float) -> None_:
        ...
    def integrateVelocities(self, dt: float) -> None_:
        ...
    def isEnabledAdjacentBodyCheck(self) -> bool:
        ...
    def isEnabledSelfCollisionCheck(self) -> bool:
        ...
    def isImpulseApplied(self) -> bool:
        ...
    def isMobile(self) -> bool:
        ...
    def resetUnion(self) -> None_:
        ...
    def setAdjacentBodyCheck(self, enable: bool) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_38: ...) -> None_:
        ...
    def setConfiguration(self, configuration: ...) -> None_:
        ...
    def setGravity(self, gravity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setImpulseApplied(self, val: bool) -> None_:
        ...
    def setMobile(self, isMobile: bool) -> None_:
        ...
    def setName(self, name: str) -> str:
        ...
    @typing.overload
    def setProperties(self, properties: ..., std_param_36: ..., std_param_37: ..., std_param_38: ..., std_param_39: ..., std_param_40: ..., std_param_41: ..., dart_param_39: ...) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: ..., dart_param_40: ...) -> None_:
        ...
    def setSelfCollisionCheck(self, enable: bool) -> None_:
        ...
    def setState(self, state: ..., std_param_42: ..., std_param_43: ..., std_param_44: ..., std_param_45: ..., std_param_46: ..., std_param_47: ..., dart_param_41: ...) -> None_:
        ...
    def setTimeStep(self, timeStep: float) -> None_:
        ...
    @typing.overload
    def updateBiasImpulse(self, bodyNode: BodyNode) -> None_:
        ...
    @typing.overload
    def updateBiasImpulse(self, bodyNode: BodyNode, imp: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def updateBiasImpulse(self, bodyNode1: BodyNode, imp1: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]], bodyNode2: BodyNode, imp2: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def updateBiasImpulse(self, softBodyNode: ..., pointMass: ..., imp: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def updateVelocityChange(self) -> None_:
        ...
class SoftMeshShape(Shape):
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, softBodyNode: ...) -> None_:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getType(self) -> str:
        ...
    def update(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_Joint_JointProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties(dartpy.common.Composite):
    def __init__(self) -> None_:
        ...
class SphereShape(Shape):
    @staticmethod
    def computeInertiaOf(radius: float, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @staticmethod
    def computeVolumeOf(radius: float) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, radius: float) -> None_:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getRadius(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def setRadius(self, radius: float) -> None_:
        ...
class TemplatedJacobianBodyNode(JacobianNode):
    @typing.overload
    def getAngularJacobian(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], inCoordinatesOf: Frame) -> numpy.ndarray[tuple[typing.Literal[3], N], numpy.dtype[numpy.float64]]:
        ...
    def getWorldJacobian(self, offset: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], N], numpy.dtype[numpy.float64]]:
        ...
class TranslationalJoint(GenericJoint_R3):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    def getTranslationalJointProperties(self) -> TranslationalJointProperties:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
class TranslationalJoint2D(EmbedPropertiesOnTopOf_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: TranslationalJoint2D) -> None_:
        ...
    def getPlaneType(self) -> ...:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[2]], numpy.dtype[numpy.float64]]:
        ...
    def getTranslationalAxis1(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getTranslationalAxis2(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getTranslationalJoint2DProperties(self) -> TranslationalJoint2DProperties:
        ...
    def getType(self) -> str:
        ...
    def hasTranslationalJoint2DAspect(self) -> bool:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def releaseTranslationalJoint2DAspect(self) -> ...:
        ...
    def removeTranslationalJoint2DAspect(self) -> None_:
        ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], transAxis2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], transAxis2: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], renameDofs: bool) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_42: ...) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: TranslationalJoint2DProperties) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: TranslationalJoint2DUniqueProperties) -> None_:
        ...
    def setTranslationalJoint2DAspect(self, aspect: ..., dart_param_43: ...) -> None_:
        ...
    @typing.overload
    def setXYPlane(self) -> None_:
        ...
    @typing.overload
    def setXYPlane(self, renameDofs: bool) -> None_:
        ...
    @typing.overload
    def setYZPlane(self) -> None_:
        ...
    @typing.overload
    def setYZPlane(self, renameDofs: bool) -> None_:
        ...
    @typing.overload
    def setZXPlane(self) -> None_:
        ...
    @typing.overload
    def setZXPlane(self, renameDofs: bool) -> None_:
        ...
class TranslationalJoint2DProperties(GenericJointProperties_R2, TranslationalJoint2DUniqueProperties):
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R2) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R2, uniqueProperties: TranslationalJoint2DUniqueProperties) -> None_:
        ...
class TranslationalJoint2DUniqueProperties:
    def __init__(self) -> None_:
        ...
class TranslationalJointProperties:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, properties: GenericJointProperties_R3) -> None_:
        ...
class UniversalJoint(EmbedPropertiesOnTopOf_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: UniversalJoint) -> None_:
        ...
    def getAxis1(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAxis2(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[2]], numpy.dtype[numpy.float64]]:
        ...
    def getType(self) -> str:
        ...
    def getUniversalJointProperties(self) -> UniversalJointProperties:
        ...
    def hasUniversalJointAspect(self) -> bool:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def releaseUniversalJointAspect(self) -> ...:
        ...
    def removeUniversalJointAspect(self) -> None_:
        ...
    def setAspectProperties(self, properties: ..., dart_param_44: ...) -> None_:
        ...
    def setAxis1(self, axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAxis2(self, axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: UniversalJointProperties) -> None_:
        ...
    @typing.overload
    def setProperties(self, properties: UniversalJointUniqueProperties) -> None_:
        ...
    def setUniversalJointAspect(self, aspect: ..., dart_param_45: ...) -> None_:
        ...
class UniversalJointProperties(GenericJointProperties_R2, UniversalJointUniqueProperties):
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R2) -> None_:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: GenericJointProperties_R2, uniqueProperties: UniversalJointUniqueProperties) -> None_:
        ...
    @property
    def mAxis(self) -> ...:
        ...
    @mAxis.setter
    def mAxis(*args, **kwargs):
        """
        (self: dartpy.dynamics.UniversalJointProperties, arg0: std_array<Eigen_Matrix<double, 3, 1, 0, 3, 1>, 2ul>) -> None
        """
class UniversalJointUniqueProperties:
    def __init__(self) -> None_:
        ...
class VisualAspect:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, properties: ...) -> None_:
        ...
    def getAlpha(self) -> float:
        ...
    def getColor(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getHidden(self) -> bool:
        ...
    def getRGB(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRGBA(self) -> numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getShadowed(self) -> bool:
        ...
    def hide(self) -> None_:
        ...
    def isHidden(self) -> bool:
        ...
    def setAlpha(self, alpha: float) -> None_:
        ...
    @typing.overload
    def setColor(self, color: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    @typing.overload
    def setColor(self, color: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setHidden(self, value: bool) -> None_:
        ...
    def setRGB(self, rgb: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setRGBA(self, color: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setShadowed(self, value: bool) -> None_:
        ...
    def show(self) -> None_:
        ...
class WeldJoint(ZeroDofJoint):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getType(self) -> str:
        ...
    def getWeldJointProperties(self) -> ...:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def setTransformFromChildBodyNode(self, T: dartpy.math.Isometry3) -> None_:
        ...
    def setTransformFromParentBodyNode(self, T: dartpy.math.Isometry3) -> None_:
        ...
class ZeroDofJoint(Joint):
    def computePotentialEnergy(self) -> float:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, arg0_: int) -> str:
        ...
    def getForce(self, index: int) -> float:
        ...
    def getForceLowerLimit(self, index: int) -> float:
        ...
    def getForceLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForceUpperLimit(self, index: int) -> float:
        ...
    def getForceUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getForces(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]], q1: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getPositions(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def getZeroDofJointProperties(self) -> ZeroDofJointProperties:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None_:
        ...
    def integrateVelocities(self, dt: float) -> None_:
        ...
    def isDofNamePreserved(self, arg0_: int) -> bool:
        ...
    def preserveDofName(self, arg0_: int, arg1_: bool) -> None_:
        ...
    def resetAccelerations(self) -> None_:
        ...
    def resetCommands(self) -> None_:
        ...
    def resetConstraintImpulses(self) -> None_:
        ...
    def resetForces(self) -> None_:
        ...
    def resetPosition(self, index: int) -> None_:
        ...
    def resetPositions(self) -> None_:
        ...
    def resetVelocities(self) -> None_:
        ...
    def resetVelocity(self, index: int) -> None_:
        ...
    def resetVelocityChanges(self) -> None_:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None_:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setCommand(self, index: int, command: float) -> None_:
        ...
    def setCommands(self, commands: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None_:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None_:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None_:
        ...
    def setDofName(self, arg0_: int, arg1_: str, arg2_: bool) -> str:
        ...
    def setForce(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimit(self, index: int, force: float) -> None_:
        ...
    def setForceLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForceUpperLimit(self, index: int, force: float) -> None_:
        ...
    def setForceUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setForces(self, forces: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None_:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None_:
        ...
    def setPosition(self, arg0_: int, arg1_: float) -> None_:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None_:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setPositions(self, positions: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setRestPosition(self, index: int, q0: float) -> None_:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None_:
        ...
    def setVelocities(self, velocities: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocity(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None_:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None_:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None_:
        ...
class ZeroDofJointProperties:
    @typing.overload
    def __init__(self) -> None_:
        ...
    @typing.overload
    def __init__(self, properties: JointProperties) -> None_:
        ...
ACCELERATION: ActuatorType  # value = <ActuatorType.ACCELERATION: 4>
DefaultActuatorType: ActuatorType  # value = <ActuatorType.FORCE: 0>
FORCE: ActuatorType  # value = <ActuatorType.FORCE: 0>
LOCKED: ActuatorType  # value = <ActuatorType.LOCKED: 6>
MIMIC: ActuatorType  # value = <ActuatorType.MIMIC: 3>
PASSIVE: ActuatorType  # value = <ActuatorType.PASSIVE: 1>
SERVO: ActuatorType  # value = <ActuatorType.SERVO: 2>
VELOCITY: ActuatorType  # value = <ActuatorType.VELOCITY: 5>
