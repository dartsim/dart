# SOME DESCRIPTIVE TITLE.
# Copyright (C) Copyright (c) 2011, The DART development contributors
# This file is distributed under the same license as the DART: Dynamic
# Animation and Robotics Toolkit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: DART: Dynamic Animation and Robotics Toolkit 7.0.0-alpha0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-26 00:39-0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: ko <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.11.0\n"

#: ../../user_guide/tutorials/collisions.md:1 854ccce1c28f42338b4bcfe446745314
msgid "Collisions"
msgstr "충돌"

#: ../../user_guide/tutorials/collisions.md:3 ab0e7dd1cf0f487f9f958ece778cc792
msgid "Overview"
msgstr "개요"

#: ../../user_guide/tutorials/collisions.md:4 f0f01075941d4212a136d7259d0dd5e2
msgid ""
"This tutorial will show you how to programmatically create different kinds "
"of bodies and set initial conditions for Skeletons. It will also demonstrate"
" some use of DART's Frame Semantics."
msgstr ""
"이 튜토리얼에서는 프로그래밍 방식으로 다양한 종류의 몸체를 생성하고 스켈레톤의 초기 조건을 설정하는 방법을 보여줍니다. 또한 DART의 "
"프레임 의미론의 일부 사용을 보여줍니다."

#: ../../user_guide/tutorials/collisions.md:8 a78bfd56c36c4c37903b49971447689a
msgid "The tutorial consists of five Lessons covering the following topics:"
msgstr "이 튜토리얼은 다음 주제를 다루는 5개의 단원으로 구성됩니다."

#: ../../user_guide/tutorials/collisions.md:10
#: bd42ccdad2a34a458c434fdeef54c17d
msgid "Creating a rigid body"
msgstr "강체 만들기"

#: ../../user_guide/tutorials/collisions.md:11
#: e86edec66d1747efa7b4fb6db9c33803
msgid "Creating a soft body"
msgstr "부드러운 몸 만들기"

#: ../../user_guide/tutorials/collisions.md:12
#: 17d2fc47fd84452a9784a028e9536279
msgid "Setting initial conditions and taking advantage of Frames"
msgstr "초기 조건 설정 및 프레임 활용"

#: ../../user_guide/tutorials/collisions.md:13
#: 9990bff5ca424cdfad23a25acc5620a7
msgid "Setting joint spring and damping properties"
msgstr "조인트 스프링 및 감쇠 속성 설정"

#: ../../user_guide/tutorials/collisions.md:14
#: b8d69ec0b8ad48c084e6b8c2b99ff61e
msgid "Creating a closed kinematic chain"
msgstr "닫힌 운동학적 체인 만들기"

#: ../../user_guide/tutorials/collisions.md:16
#: e435c76f92594306867ea75877271275
msgid ""
"Please reference the source code in "
"[**tutorials/tutorial_collisions/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_collisions/main.cpp)"
" and [**tutorialCollisions-"
"Finished.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorialCollisions-"
"Finished.cpp)."
msgstr ""
"[**tutorials/tutorial_collisions/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_collisions/main.cpp)"
" 및 [**tutorialCollisions-"
"Finished.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorialCollisions-"
"Finished.cpp)의 소스 코드를 참조하세요."

#: ../../user_guide/tutorials/collisions.md:18
#: 6ed2ccaf3dd94a8581c06209e90723f0
msgid "Lesson 1: Creating a rigid body"
msgstr "단원 1: 강체 만들기"

#: ../../user_guide/tutorials/collisions.md:20
#: 047ebdab87b14520b9c4e6bc8e7a09f0
msgid ""
"Start by going opening the Skeleton code "
"[tutorials/tutorial_collisions/main.cpp](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_collisions/main.cpp)."
" Find the function named ``addRigidBody``. You will notice that this is a "
"templated function. If you're not familiar with templates, that's okay; we "
"won't be doing anything too complicated with them. Different Joint types in "
"DART are managed by a bunch of different classes, so we need to use "
"templates if we want the same function to work with a variety of Joint "
"types."
msgstr ""
"스켈레톤 코드 "
"[tutorials/tutorial_collisions/main.cpp](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_collisions/main.cpp)를"
" 여는 것부터 시작하세요. addRigidBody라는 함수를 찾으세요. 이것이 템플릿화된 함수라는 것을 알 수 있습니다. 템플릿에 "
"익숙하지 않아도 괜찮습니다. 우리는 그들에게 너무 복잡한 일은 하지 않을 것입니다. DART의 다양한 조인트 유형은 다양한 클래스에 의해"
" 관리되므로 동일한 기능이 다양한 조인트 유형에서 작동하도록 하려면 템플릿을 사용해야 합니다."

#: ../../user_guide/tutorials/collisions.md:27
#: 41fdb10487f34a7b8a45bdd1363e9d33
msgid "Lesson 1a: Setting joint properties"
msgstr "1a단원: 접합 속성 설정"

#: ../../user_guide/tutorials/collisions.md:29
#: 88984386ec3a46b1bdd66ee6e7ce7ad8
msgid ""
"The first thing we'll want to do is set the Joint properties for our new "
"body. Whenever we create a BodyNode, we must also create a parent Joint for "
"it. A BodyNode needs a parent Joint, even if that BodyNode is the root of "
"the Skeleton, because we need its parent Joint to describe how it's attached"
" to the world. A root BodyNode could be attached to the world by any kind of"
" Joint. Most often, it will be attached by either a FreeJoint (if the body "
"should be completely free to move with respect to the world) or a WeldJoint "
"(if the body should be rigidly attached to the world, unable to move at "
"all), but *any* Joint type is permissible."
msgstr ""
"가장 먼저 해야 할 일은 새 몸체의 관절 속성을 설정하는 것입니다. BodyNode를 생성할 때마다 이에 대한 상위 조인트도 생성해야 "
"합니다. BodyNode가 스켈레톤의 루트인 경우에도 BodyNode에는 상위 조인트가 필요합니다. 세계에 어떻게 연결되는지 설명하려면 "
"상위 조인트가 필요하기 때문입니다. 루트 BodyNode는 모든 종류의 조인트를 통해 월드에 연결될 수 있습니다. 대부분의 경우 "
"FreeJoint(신체가 월드에 대해 완전히 자유롭게 움직여야 하는 경우) 또는 WeldJoint(신체가 월드에 단단히 부착되어 전혀 "
"움직일 수 없는 경우)에 의해 연결되지만 *모든* 조인트 유형이 허용됩니다."

#: ../../user_guide/tutorials/collisions.md:39
#: 93783e0fc83d4d29a5fb9606e59fc22f
msgid ""
"Joint properties are managed in a nested class, which means it's a class "
"which is defined inside of another class. For example, ``RevoluteJoint`` "
"properties are managed in a class called ``RevoluteJoint::Properties`` while"
" ``PrismaticJoint`` properties are managed in a class called "
"``PrismaticJoint::Properties``. However, both ``RevoluteJoint`` and "
"``PrismaticJoint`` inherit the ``SingleDofJoint`` class so the "
"``RevoluteJoint::Properties`` and ``PrismaticJoint::Properties`` classes "
"both inherit the ``SingleDofJoint::Properties`` class. The difference is "
"that ``RevoluteJoint::Properties`` also inherits "
"``RevoluteJoint::UniqueProperties`` whereas ``PrismaticJoint::Properties`` "
"inherits ``PrismaticJoint::UniqueProperties`` instead. Many DART classes "
"contain nested ``Properties`` classes like this which are compositions of "
"their base class's nested ``Properties`` class and their own "
"``UniqueProperties`` class. As you'll see later, this is useful for "
"providing a consistent API that works cleanly for fundamentally different "
"types of classes."
msgstr ""
"조인트 속성은 중첩 클래스에서 관리됩니다. 즉, 다른 클래스 내부에 정의된 클래스라는 뜻입니다. 예를 들어, "
"``RevoluteJoint`` 속성은 ``RevoluteJoint::Properties``라는 클래스에서 관리되는 반면 "
"``PrismaticJoint`` 속성은 ``PrismaticJoint::Properties``라는 클래스에서 관리됩니다. 그러나 "
"``RevoluteJoint``와 ``PrismaticJoint``는 모두 ``SingleDofJoint`` 클래스를 상속하므로 "
"``RevoluteJoint::Properties``와 ``PrismaticJoint::Properties`` 클래스는 모두 "
"``SingleDofJoint::Properties`` 클래스를 상속합니다. 차이점은 "
"``RevoluteJoint::Properties``도 ``RevoluteJoint::UniqueProperties``를 상속하는 반면 "
"``PrismaticJoint::Properties``는 ``PrismaticJoint::UniqueProperties``를 상속한다는 "
"것입니다. 많은 DART 클래스에는 기본 클래스의 중첩된 ``Properties`` 클래스와 자체 ``UniqueProperties`` "
"클래스의 구성인 이와 같은 중첩된 ``Properties`` 클래스가 포함되어 있습니다. 나중에 보게 되겠지만 이는 근본적으로 다른 "
"유형의 클래스에 대해 깔끔하게 작동하는 일관된 API를 제공하는 데 유용합니다."

#: ../../user_guide/tutorials/collisions.md:53
#: 0e9cbf0175d64a8183498dcc09dbb727
msgid "To create a ``Properties`` class for our Joint type, we'll want to say"
msgstr "Joint 유형에 대한 ``Properties`` 클래스를 생성하려면 다음과 같이 말하고 싶습니다."

#: ../../user_guide/tutorials/collisions.md:58
#: dfb8b07aa4f8482190bed02cb4816448
msgid ""
"We need to include the ``typename`` keywords because of how the syntax works"
" for templated functions. Leaving it out should make your compiler complain."
msgstr ""
"템플릿 함수에 대해 구문이 작동하는 방식 때문에 ``typename`` 키워드를 포함해야 합니다. 이를 그대로 두면 컴파일러가 불평을 "
"하게 됩니다."

#: ../../user_guide/tutorials/collisions.md:61
#: dc8ce9208566435a93e87dcdd95f3526
msgid ""
"From here, we can set the Joint properties in any way we'd like. There are "
"only a few things we care about right now: First, the Joint's name. Every "
"Joint in a Skeleton needs to have a non-empty unique name. Those are the "
"only restrictions that are placed on Joint names. If you try to make a "
"Joint's name empty, it will be given a default name. If you try to make a "
"Joint's name non-unique, DART will append a number tag to the end of the "
"name in order to make it unique. It will also print out a warning during run"
" time, which can be an eyesore (because it wants you to be aware when you "
"are being negligent about naming things). For the sake of simplicity, let's "
"just give it a name based off its child BodyNode:"
msgstr ""
"여기에서 원하는 방식으로 조인트 속성을 설정할 수 있습니다. 지금 당장 우리가 관심을 갖는 것은 몇 가지뿐입니다. 첫째, 조인트의 "
"이름입니다. 스켈레톤의 모든 조인트에는 비어 있지 않은 고유 이름이 있어야 합니다. 이는 공동 이름에 적용되는 유일한 제한 사항입니다. "
"조인트 이름을 비워두려고 하면 기본 이름이 지정됩니다. 조인트 이름을 고유하지 않게 만들려고 하면 DART는 이름 끝에 숫자 태그를 "
"추가하여 이름을 고유하게 만듭니다. 또한 런타임 중에 경고를 인쇄하는데, 이는 눈에 거슬리는 일이 될 수 있습니다(왜냐하면 이름 지정에 "
"소홀할 때 이를 알 수 있기를 원하기 때문입니다). 단순화를 위해 하위 BodyNode를 기반으로 이름을 지정하겠습니다."

#: ../../user_guide/tutorials/collisions.md:75
#: 03aa9f3cf45e4b5592f6c3d1b3c4ae95
msgid "Don't forget to uncomment the function arguments."
msgstr "함수 인수의 주석 처리를 제거하는 것을 잊지 마십시오."

#: ../../user_guide/tutorials/collisions.md:77
#: 508ddabb8d664b2eada2b9ea9316fb65
msgid ""
"Next we'll want to deal with offsetting the new BodyNode from its parent "
"BodyNode. We can use the following to check if there is a parent BodyNode:"
msgstr ""
"다음으로 우리는 상위 BodyNode에서 새 BodyNode를 오프셋하는 작업을 처리하려고 합니다. 다음을 사용하여 상위 "
"BodyNode가 있는지 확인할 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:87
#: 5d2621d3a1a84e32a0fb0743241e189f
msgid "Inside the brackets, we'll want to create the offset between bodies:"
msgstr "괄호 안에 몸체 사이의 오프셋을 생성하려고 합니다."

#: ../../user_guide/tutorials/collisions.md:93
#: 0f2f7f44475e44dd8e2b4ec4720d897b
msgid ""
"An ``math::Isometry3d`` is the Eigen library's version of a homogeneous "
"transformation matrix. Here we are initializing it to an Identity matrix to "
"start out. This is almost always something you should do when creating an "
"math::Isometry3d, because otherwise its contents will be completely "
"arbitrary trash."
msgstr ""
"``math::Isometry3d``는 Eigen 라이브러리 버전의 동종 변환 행렬입니다. 여기서는 시작하기 위해 Identity 행렬로"
" 초기화하고 있습니다. 이는 math::Isometry3d를 생성할 때 거의 항상 수행해야 하는 작업입니다. 그렇지 않으면 해당 내용이 "
"완전히 임의의 쓰레기가 되기 때문입니다."

#: ../../user_guide/tutorials/collisions.md:99
#: e0dfe5fea7eb43b5a3179a8fdcf9e3e5
msgid ""
"We can easily compute the center point between the origins of the two bodies"
" using our default height value:"
msgstr "기본 높이 값을 사용하여 두 몸체의 원점 사이의 중심점을 쉽게 계산할 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:106
#: 2306386f058e4c8bb0a04c839657b4a9
msgid ""
"We can then offset the parent and child BodyNodes of this Joint using this "
"transform:"
msgstr "그런 다음 이 변환을 사용하여 이 조인트의 상위 및 하위 BodyNode를 오프셋할 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:114
#: fbd8791f81bc464eaddd030df7ed1f23
msgid ""
"Remember that all of that code should go inside the ``if(parent)`` "
"condition. We do not want to create this offset for root BodyNodes, because "
"later on we will rely on the assumption that the root Joint origin is lined "
"up with the root BodyNode origin."
msgstr ""
"해당 코드는 모두 ``if(parent)`` 조건 안에 들어가야 한다는 점을 기억하세요. 나중에 루트 관절 원점이 루트 BodyNode "
"원점과 정렬된다는 가정에 의존하기 때문에 루트 BodyNode에 대해 이 오프셋을 생성하고 싶지 않습니다."

#: ../../user_guide/tutorials/collisions.md:119
#: e5b965580c944e05a5eb4aceffe0b22b
msgid "Lesson 1b: Create a Joint and BodyNode pair"
msgstr "1b단원: Joint 및 BodyNode 쌍 생성"

#: ../../user_guide/tutorials/collisions.md:121
#: 51acc4ef72014d5081656a99a11b31f5
msgid ""
"A single function is used to simultaneously create a new Joint and its child"
" BodyNode. It's important to note that a Joint cannot be created without a "
"child BodyNode to accompany it, and a BodyNode cannot be created with parent"
" Joint to attach it to something. A parent Joint without a child BodyNode or"
" vice-versa would be non-physical and nonsensical, so we don't allow it."
msgstr ""
"단일 함수는 새로운 조인트와 그 하위 BodyNode를 동시에 생성하는 데 사용됩니다. 동반할 하위 BodyNode가 없으면 조인트를 "
"생성할 수 없으며, 무언가에 연결하기 위해 상위 조인트를 사용하여 BodyNode를 생성할 수 없다는 점을 기억하는 것이 중요합니다. "
"하위 BodyNode가 없는 상위 조인트 또는 그 반대의 경우는 비물리적이고 무의미하므로 허용하지 않습니다."

#: ../../user_guide/tutorials/collisions.md:127
#: 22ba6fa546cd449e9cdd033ef3fa438d
msgid ""
"Use the following to create a new Joint & BodyNode, and obtain a pointer to "
"that new BodyNode:"
msgstr "다음을 사용하여 새 Joint & BodyNode를 만들고 해당 새 BodyNode에 대한 포인터를 얻습니다."

#: ../../user_guide/tutorials/collisions.md:135
#: e1aa41db4a0647feb6b402821fbde370
msgid ""
"There's a lot going on in this function, so let's break it down for a "
"moment:"
msgstr "이 함수에는 많은 일이 일어나고 있으므로 잠시 분석해 보겠습니다."

#: ../../user_guide/tutorials/collisions.md:141
#: d037512b704f4cc2b6579a68c1e8750f
msgid ""
"This is a Skeleton member function that takes template arguments. The first "
"template argument specifies the type of Joint that you want to create. In "
"our case, the type of Joint we want to create is actually a template "
"argument of our current function, so we just pass that argument along. The "
"second template argument of ``createJointAndBodyNodePair`` allows us to "
"specify the BodyNode type that we want to create, but the default argument "
"is a standard rigid  BodyNode, so we can leave the second argument blank."
msgstr ""
"이것은 템플릿 인수를 취하는 Skeleton 멤버 함수입니다. 첫 번째 템플릿 인수는 생성하려는 조인트 유형을 지정합니다. 우리의 경우,"
" 우리가 생성하려는 조인트 유형은 실제로 현재 함수의 템플릿 인수이므로 해당 인수를 전달하기만 하면 됩니다. "
"``createJointAndBodyNodePair``의 두 번째 템플릿 인수를 사용하면 생성하려는 BodyNode 유형을 지정할 수 "
"있지만 기본 인수는 표준 강체 BodyNode이므로 두 번째 인수를 비워 둘 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:153
#: ab7b8e2a73734063a1c6ae8d2880e29d
msgid ""
"Now for the function arguments: The first specifies the parent BodyNode. In "
"the event that you want to create a root BodyNode, you can simply pass in a "
"nullptr as the parent. The second argument is a ``JointType::Properties`` "
"struct, so we pass in the ``joint_properties`` object that we created "
"earlier. The third argument is a ``BodyNode::Properties`` struct, but we're "
"going to set the BodyNode properties later, so we'll just toss the name in "
"by wrapping it up in a ``BodyNode::AspectProperties`` object and leave the "
"rest as default values."
msgstr ""
"이제 함수 인수에 대해 설명합니다. 첫 번째 인수는 상위 BodyNode를 지정합니다. 루트 BodyNode를 생성하려는 경우 "
"nullptr을 부모로 전달하기만 하면 됩니다. 두 번째 인수는 ``JointType::Properties`` 구조체이므로 이전에 생성한"
" ``joint_properties`` 개체를 전달합니다. 세 번째 인수는 ``BodyNode::Properties`` 구조체이지만 "
"BodyNode 속성은 나중에 설정할 것이므로 이름을 ``BodyNode::AspectProperties`` 객체로 감싸서 넣고 나머지는"
" 기본값으로 두겠습니다."

#: ../../user_guide/tutorials/collisions.md:161
#: 5e32c1af4a7a42009f6231358e08c9da
msgid "Now notice the very last thing on this line of code:"
msgstr "이제 이 코드 줄의 마지막 내용을 확인하세요."

#: ../../user_guide/tutorials/collisions.md:167
#: 9e4532dd7aba4e8e9c59ab155f1ff8bb
msgid ""
"The function actually returns a ``std::pair`` of pointers to the new Joint "
"and new BodyNode that were just created, but we only care about grabbing the"
"  BodyNode once the function is finished, so we can append ``.second`` to "
"the end of the line so that we just grab the BodyNode pointer and ignore the"
" Joint  pointer. The joint will of course still be created; we just have no "
"need to  access it at this point."
msgstr ""
"함수는 실제로 방금 생성된 새 Joint 및 새 BodyNode에 대한 포인터의 ``std::pair``를 반환하지만 함수가 완료된 후에"
" BodyNode를 잡는 것에만 관심이 있으므로 줄 끝에 ``.second``를 추가하여 BodyNode 포인터를 잡고 Joint "
"포인터를 무시할 수 있습니다. 물론 조인트는 계속 생성됩니다. 지금은 액세스할 필요가 없습니다."

#: ../../user_guide/tutorials/collisions.md:174
#: 6119a2b2f1cd4fc3ade99b7729bedf53
msgid "Lesson 1c: Make a shape for the body"
msgstr "1c단원: 몸체 모양 만들기"

#: ../../user_guide/tutorials/collisions.md:176
#: 3c2ed6700c09494c87525b49a3fbdeb5
msgid ""
"We'll take advantage of the Shape::ShapeType enumeration to specify what "
"kind of Shape we want to produce for the body. In particular, we'll allow "
"the user to specify three types of Shapes: ``Shape::BOX``, "
"``Shape::CYLINDER``, and ``Shape::ELLIPSOID``."
msgstr ""
"Shape::ShapeType 열거형을 활용하여 몸체에 대해 어떤 종류의 Shape를 생성할지 지정합니다. 특히, 사용자는 "
"``Shape::BOX``, ``Shape::CYLINDER`` 및 ``Shape::ELLIPSOID``의 세 가지 유형의 모양을 지정할"
" 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:197
#: c1342b281e2e45ae822c61ca417e9be1
msgid ""
"``ShapePtr`` is simply a typedef for ``std::shared_ptr<Shape>``. DART has "
"this typedef in order to improve space usage and readability, because this "
"type gets used very often."
msgstr ""
"``ShapePtr``은 단순히 ``std::shared_ptr<Shape>``에 대한 형식 정의입니다. DART에는 공간 활용과 "
"가독성을 높이기 위해 이 유형 정의가 있습니다. 이 유형은 매우 자주 사용되기 때문입니다."

#: ../../user_guide/tutorials/collisions.md:201
#: 81f872b436814615ba67354585c3b4e0
msgid ""
"Now we want to construct each of the Shape types within their conditional "
"statements. Each constructor is a bit different."
msgstr "이제 조건문 내에서 각 Shape 유형을 구성하려고 합니다. 생성자마다 조금씩 다릅니다."

#: ../../user_guide/tutorials/collisions.md:204
#: dbb640cf0bdc4e6abbe3af749c83d84a
msgid ""
"For box we pass in an math::Vector3d that contains the three dimensions of "
"the box:"
msgstr "상자의 경우 상자의 세 가지 차원을 포함하는 math::Vector3d를 전달합니다."

#: ../../user_guide/tutorials/collisions.md:213
#: baa84319ea964953a8d4212eee2d9b5b
msgid "For cylinder we pass in a radius and a height:"
msgstr "원통의 경우 반경과 높이를 전달합니다."

#: ../../user_guide/tutorials/collisions.md:220
#: c54ff2af4ab44206a6990f3219a5afee
msgid ""
"For ellipsoid we pass in an math::Vector3d that contains the lengths of the "
"three axes:"
msgstr "타원체의 경우 세 축의 길이를 포함하는 math::Vector3d를 전달합니다."

#: ../../user_guide/tutorials/collisions.md:227
#: 268b2f25d296438592b4b8903b982f11
msgid ""
"Since we actually want a sphere, all three axis lengths will be equal, so we"
" can create an math::Vector3d filled with ones by using "
"``math::Vector3d::Ones()`` and then multiply it by the length that we "
"actually want for the three components."
msgstr ""
"실제로 구를 원하기 때문에 세 축 길이가 모두 같으므로 ``math::Vector3d::Ones()``를 사용하여 1로 채워진 "
"math::Vector3d를 만든 다음 여기에 세 구성 요소에 대해 실제로 원하는 길이를 곱할 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:231
#: e443d7871dad40bfb3fd31ac5ee7830e
msgid ""
"Finally, we want to add this shape as a visualization **and** collision "
"shape for the BodyNode:"
msgstr "마지막으로 이 모양을 BodyNode의 시각화 **및** 충돌 모양으로 추가하려고 합니다."

#: ../../user_guide/tutorials/collisions.md:239
#: ab326ed9c1c6403e82d94e71c34af471
msgid ""
"We want to do this no matter which type was selected, so those two lines of "
"code should be after all the condition statements."
msgstr "어떤 유형을 선택했는지에 관계없이 이 작업을 수행하기를 원하므로 해당 두 줄의 코드는 모든 조건문 뒤에 있어야 합니다."

#: ../../user_guide/tutorials/collisions.md:242
#: f5ff093666324356b7459f590c73742e
msgid "Lesson 1d: Set up the inertia properties for the body"
msgstr "1d단원: 몸체의 관성 속성 설정"

#: ../../user_guide/tutorials/collisions.md:244
#: 8805b86acdb64a22beac7de67ba02f4c
msgid ""
"For the simulations to be physically accurate, it's important for the "
"inertia properties of the body to match up with the geometric properties of "
"the shape. We can create an ``Inertia`` object and set its values based on "
"the shape's geometry, then give that ``Inertia`` to the BodyNode."
msgstr ""
"시뮬레이션이 물리적으로 정확하려면 몸체의 관성 속성이 모양의 기하학적 속성과 일치하는 것이 중요합니다. ``관성`` 개체를 만들고 모양의"
" 기하학적 구조에 따라 값을 설정한 다음 해당 ``관성``을 BodyNode에 제공할 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:257
#: 913d238fc3694eae8cee77c8190fda3b
msgid "Lesson 1e: Set the coefficient of restitution"
msgstr "1e단원: 복원 계수 설정"

#: ../../user_guide/tutorials/collisions.md:259
#: 7bc7a7506dbc43b68fe7231f0152e559
msgid "This is very easily done with the following function:"
msgstr "이는 다음 기능을 사용하면 매우 쉽게 수행됩니다."

#: ../../user_guide/tutorials/collisions.md:265
#: 405ef3e595a147599eaf8af07f806b60
msgid "Lesson 1f: Set the damping coefficient"
msgstr "레슨 1f: 감쇠 계수 설정"

#: ../../user_guide/tutorials/collisions.md:267
#: 03b4b73740bb4cab800cb76d34c19fbb
msgid ""
"In real life, joints have friction. This pulls energy out of systems over "
"time, and makes those systems more stable. In our simulation, we'll ignore "
"air friction, but we'll add friction in the joints between bodies in order "
"to have better numerical and dynamic stability:"
msgstr ""
"실생활에서 관절에는 마찰이 있습니다. 이는 시간이 지남에 따라 시스템에서 에너지를 끌어내고 해당 시스템을 더욱 안정적으로 만듭니다. "
"시뮬레이션에서는 공기 마찰을 무시하지만 더 나은 수치적 및 동적 안정성을 얻기 위해 몸체 사이의 관절에 마찰을 추가할 것입니다."

#: ../../user_guide/tutorials/collisions.md:281
#: 1f17932e7ac54391be639245509870b8
msgid ""
"If this BodyNode has a parent BodyNode, then we set damping coefficients of "
"its Joint to a default value."
msgstr "이 BodyNode에 상위 BodyNode가 있는 경우 해당 조인트의 감쇠 계수를 기본값으로 설정합니다."

#: ../../user_guide/tutorials/collisions.md:284
#: 771f5ad6f3914acab4c2fc314e2da344
msgid "Lesson 2: Creating a soft body"
msgstr "단원 2: 부드러운 몸체 만들기"

#: ../../user_guide/tutorials/collisions.md:286
#: f953a803bc9c4f4baa5195155af1a23e
msgid ""
"Find the templated function named ``addSoftBody``. This function will have a"
" role identical to the ``addRigidBody`` function from earlier."
msgstr ""
"``addSoftBody``라는 템플릿 함수를 찾으세요. 이 함수는 이전의 ``addRigidBody`` 함수와 동일한 역할을 합니다."

#: ../../user_guide/tutorials/collisions.md:289
#: 9c2900a17a264ceb9cad051f2e1efed9
msgid "Lesson 2a: Set the Joint properties"
msgstr "2a단원: 접합 속성 설정"

#: ../../user_guide/tutorials/collisions.md:291
#: f3766dca61a84720952c905647afa128
msgid ""
"This portion is exactly the same as Lesson 1a. You can even copy the code "
"directly from there if you'd like to."
msgstr "이 부분은 Lesson 1a와 완전히 동일합니다. 원하는 경우 거기에서 직접 코드를 복사할 수도 있습니다."

#: ../../user_guide/tutorials/collisions.md:294
#: eecb806587e8426d83145fb26a621768
msgid "Lesson 2b: Set the properties of the soft body"
msgstr "2b단원: 연체의 속성 설정"

#: ../../user_guide/tutorials/collisions.md:296
#: e15eb5313a2e44639a75206360b4b47d
msgid ""
"Last time we set the BodyNode properties after creating it, but this time "
"we'll set them beforehand."
msgstr "지난번에는 BodyNode 속성을 생성한 후 설정했지만 이번에는 미리 설정해 보겠습니다."

#: ../../user_guide/tutorials/collisions.md:299
#: aa62abfbba5842398072c07d08e5815f
msgid ""
"First, let's create a struct for the properties that are unique to "
"SoftBodyNodes:"
msgstr "먼저 SoftBodyNodes에 고유한 속성에 대한 구조체를 만들어 보겠습니다."

#: ../../user_guide/tutorials/collisions.md:305
#: 9460267dc4954c8ea810f934f338dfd4
msgid ""
"Later we will combine this with a standard ``BodyNode::Properties`` struct, "
"but for now let's fill it in. Up above we defined an enumeration for a "
"couple different SoftBodyNode types. There is no official DART-native "
"enumeration for this, we created our own to use for this function. We'll "
"want to fill in the ``SoftBodyNode::UniqueProperties`` struct based off of "
"this enumeration:"
msgstr ""
"나중에 이를 표준 ``BodyNode::Properties`` 구조체와 결합할 것이지만 지금은 이를 채워 보겠습니다. 위에서는 몇 가지 "
"다른 SoftBodyNode 유형에 대한 열거형을 정의했습니다. 이에 대한 공식 DART 기본 열거는 없으며, 이 기능에 사용하기 위해 "
"자체 열거를 만들었습니다. 우리는 이 열거형을 기반으로 ``SoftBodyNode::UniqueProperties`` 구조체를 채우고 "
"싶을 것입니다:"

#: ../../user_guide/tutorials/collisions.md:326
#: 341258c6dcf144d794b08e7063caa6ae
msgid ""
"Each of these types has a static function in the ``SoftBodyNodeHelper`` "
"class that will set up your ``UniqueProperties`` for you. The arguments for "
"each of the functions are a bit complicated, so here is how to call it for "
"each type:"
msgstr ""
"이러한 각 유형에는 ``SoftBodyNodeHelper`` 클래스에 ``UniqueProperties``를 설정하는 정적 함수가 "
"있습니다. 각 함수에 대한 인수는 약간 복잡하므로 각 유형에 대해 호출하는 방법은 다음과 같습니다."

#: ../../user_guide/tutorials/collisions.md:330
#: 84142c8b0e30484eaea4e507a086a2a5
msgid "For the SOFT_BOX:"
msgstr "SOFT_BOX의 경우:"

#: ../../user_guide/tutorials/collisions.md:342
#: b75cb2fc60584910a6904356deb0dfda
msgid "For the SOFT_CYLINDER:"
msgstr "SOFT_CYLINDER의 경우:"

#: ../../user_guide/tutorials/collisions.md:357
#: 6555b97cd2334dfea091f033ef880395
msgid "And for the SOFT_ELLIPSOID:"
msgstr "SOFT_ELLIPSOID의 경우:"

#: ../../user_guide/tutorials/collisions.md:367
#: d0a7c4d670bf4da2a42b2d3e7d3d501c
msgid ""
"Feel free to play around with the different parameters, like number of "
"slices and number of stacks. However, be aware that some of those parameters"
" have a minimum value, usually of 2 or 3. During runtime, you should be "
"warned if you try to create one with a parameter that's too small."
msgstr ""
"슬라이스 수, 스택 수 등 다양한 매개변수를 자유롭게 사용해 보세요. 그러나 이러한 매개변수 중 일부에는 일반적으로 2 또는 3의 "
"최소값이 있다는 점에 유의하십시오. 런타임 중에 너무 작은 매개변수를 사용하여 매개변수를 생성하려고 하면 경고를 받아야 합니다."

#: ../../user_guide/tutorials/collisions.md:372
#: 0bf9be7229af4b969a932270cdd0e697
msgid "Lastly, we'll want to fill in the softness coefficients:"
msgstr "마지막으로 부드러움 계수를 입력하겠습니다."

#: ../../user_guide/tutorials/collisions.md:380
#: 19977711a0514ecb95ae301cd7e2c668
msgid "Lesson 2c: Create the Joint and Soft Body pair"
msgstr "단원 2c: 조인트 및 소프트 바디 쌍 만들기"

#: ../../user_guide/tutorials/collisions.md:382
#: 4e8f8812950a49a79419828c7482d90b
msgid ""
"This step is very similar to Lesson 1b, except now we'll want to specify "
"that we're creating a soft BodyNode. First, let's create a full  "
"``SoftBodyNode::Properties``:"
msgstr ""
"이 단계는 소프트 BodyNode를 생성한다는 점을 지정한다는 점을 제외하고는 1b과와 매우 유사합니다. 먼저 전체 "
"``SoftBodyNode::Properties``를 만들어 보겠습니다."

#: ../../user_guide/tutorials/collisions.md:391
#: e112d84732c94c64a4046e9693357a9f
msgid ""
"This will combine the ``UniqueProperties`` of the SoftBodyNode with the "
"standard properties of a BodyNode. Now we can pass the whole thing into the "
"creation function:"
msgstr ""
"이는 SoftBodyNode의 ``UniqueProperties``를 BodyNode의 표준 속성과 결합합니다. 이제 모든 것을 생성 "
"함수에 전달할 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:400
#: 356ef6b0f2304165943c8074760b7a95
msgid ""
"Notice that this time it will return a ``SoftBodyNode`` pointer rather than "
"a normal ``BodyNode`` pointer. This is one of the advantages of templates!"
msgstr ""
"이번에는 일반적인 ``BodyNode`` 포인터가 아닌 ``SoftBodyNode`` 포인터를 반환한다는 점에 유의하세요. 템플릿의 장점"
" 중 하나죠!"

#: ../../user_guide/tutorials/collisions.md:403
#: c864444fb13e421ca5b3562b8b7344c0
msgid "Lesson 2d: Zero out the BodyNode inertia"
msgstr "2d단원: BodyNode 관성 제로화"

#: ../../user_guide/tutorials/collisions.md:405
#: 37ca195a86a641dfbea3a23636be4604
msgid ""
"A SoftBodyNode has two sources of inertia: the underlying inertia of the "
"standard BodyNode class, and the point mass inertias of its soft skin. In "
"our case, we only want the point mass inertias, so we should zero out the "
"standard BodyNode inertia. However, zeroing out inertia values can be very "
"dangerous, because it can easily result in singularities. So instead of "
"completely zeroing them out, we will just make them small enough that they "
"don't impact the simulation:"
msgstr ""
"SoftBodyNode에는 두 가지 관성 소스, 즉 표준 BodyNode 클래스의 기본 관성과 소프트 스킨의 점질량 관성이 있습니다. "
"우리의 경우에는 점 질량 관성만 원하므로 표준 BodyNode 관성을 0으로 설정해야 합니다. 그러나 관성 값을 0으로 만드는 것은 쉽게"
" 특이점을 초래할 수 있으므로 매우 위험할 수 있습니다. 따라서 완전히 0으로 만드는 대신 시뮬레이션에 영향을 주지 않을 만큼 작게 "
"만듭니다."

#: ../../user_guide/tutorials/collisions.md:420
#: 4e550d1d1dff49acbb8603ba6c9e067c
msgid "Lesson 2e: Make the shape transparent"
msgstr "2e단원: 모양을 투명하게 만들기"

#: ../../user_guide/tutorials/collisions.md:422
#: c37a1686e9204595a9643ed3810eacf4
msgid ""
"To help us visually distinguish between the soft and rigid portions of a "
"body, we can make the soft part of the shape transparent. Upon creation, a "
"SoftBodyNode will have exactly one visualization shape: the soft shape "
"visualizer. We can grab that shape and reduce the value of its alpha "
"channel:"
msgstr ""
"몸체의 부드러운 부분과 단단한 부분을 시각적으로 구별하는 데 도움이 되도록 모양의 부드러운 부분을 투명하게 만들 수 있습니다. 생성 시 "
"SoftBodyNode는 정확히 하나의 시각화 모양, 즉 부드러운 모양 시각화 도구를 갖게 됩니다. 해당 모양을 잡고 알파 채널의 값을 "
"줄일 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:434
#: 63b2091f756f4a3ea95eff91a73534be
msgid "Lesson 2f: Give a hard bone to the SoftBodyNode"
msgstr "2f단원: SoftBodyNode에 단단한 뼈대 제공"

#: ../../user_guide/tutorials/collisions.md:436
#: 3968a11a23fe4f2dabbc084668b337dd
msgid ""
"SoftBodyNodes are intended to be used as soft skins that are attached to "
"rigid bones. We can create a rigid shape, place it in the SoftBodyNode, and "
"give some inertia to the SoftBodyNode's base BodyNode class, to act as the "
"inertia of the bone."
msgstr ""
"SoftBodyNodes는 단단한 뼈에 부착된 부드러운 스킨으로 사용되도록 만들어졌습니다. 고정된 모양을 만들어 SoftBodyNode에"
" 배치한 다음 SoftBodyNode의 기본 BodyNode 클래스에 약간의 관성을 부여하여 뼈의 관성 역할을 할 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:441
#: 878f117c7c0a4fcc93e3bc2e1fb726b9
msgid ""
"Find the function ``createSoftBody()``. Underneath the call to "
"``addSoftBody``, we can create a box shape that matches the dimensions of "
"the soft box, but scaled down:"
msgstr ""
"``createSoftBody()`` 함수를 찾으세요. ``addSoftBody`` 호출 아래에서 소프트 박스의 크기와 일치하지만 크기가"
" 축소된 상자 모양을 만들 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:452
#: 0d57879879464d8bb1b58aeb7125ed35
msgid ""
"And then we can add that shape to the visualization and collision shapes of "
"the SoftBodyNode, just like normal:"
msgstr "그런 다음 평소와 같이 SoftBodyNode의 시각화 및 충돌 모양에 해당 모양을 추가할 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:459
#: ae11b94f68f6480794de1677e3c9f2c0
msgid ""
"And we'll want to make sure that we set the inertia of the underlying "
"BodyNode, or else the behavior will not be realistic:"
msgstr "그리고 기본 BodyNode의 관성을 설정했는지 확인해야 합니다. 그렇지 않으면 동작이 현실적이지 않습니다."

#: ../../user_guide/tutorials/collisions.md:469
#: 90a32e7c9cf24171a78a00744b9e8602
msgid ""
"Note that the inertia of the inherited BodyNode is independent of the "
"inertia of the SoftBodyNode's skin."
msgstr "상속된 BodyNode의 관성은 SoftBodyNode 스킨의 관성과 무관합니다."

#: ../../user_guide/tutorials/collisions.md:472
#: d6b547edeead452eb25e7f86f639298f
msgid "Lesson 2g: Add a rigid body attached by a WeldJoint"
msgstr "2g단원: WeldJoint로 연결된 강체 추가"

#: ../../user_guide/tutorials/collisions.md:474
#: dea6ed6029ed4bd49f3ee99ddda9e3d0
msgid ""
"To make a more interesting hybrid shape, we can attach a protruding rigid "
"body to a SoftBodyNode using a WeldJoint. Find the ``createHybridBody()`` "
"function and see where we call the ``addSoftBody`` function. Just below "
"this, we'll create a new rigid body with a WeldJoint attachment:"
msgstr ""
"보다 흥미로운 하이브리드 모양을 만들기 위해 WeldJoint를 사용하여 돌출된 강체를 SoftBodyNode에 연결할 수 있습니다. "
"``createHybridBody()`` 함수를 찾아 ``addSoftBody`` 함수를 호출하는 위치를 확인하세요. 바로 아래에 "
"WeldJoint가 부착된 새 강체를 만듭니다."

#: ../../user_guide/tutorials/collisions.md:484
#: 46f1f1aa4de24d8e87d47c4b710c18e7
msgid "Now we can give the new rigid BodyNode a regular box shape:"
msgstr "이제 새로운 강체 BodyNode에 일반 상자 모양을 지정할 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:494
#: 68727917352c46e9b396dd0f94edb639
msgid ""
"To make the box protrude, we'll shift it away from the center of its parent:"
msgstr "상자를 돌출시키려면 상자를 부모의 중심에서 멀리 이동시킵니다."

#: ../../user_guide/tutorials/collisions.md:502
#: 35b937212ae94db198e6a3f019d57215
msgid ""
"And be sure to set its inertia, or else the simulation will not be "
"realistic:"
msgstr "관성을 설정해야 합니다. 그렇지 않으면 시뮬레이션이 현실적이지 않습니다."

#: ../../user_guide/tutorials/collisions.md:511
#: e310f75f133144c0b7d92a28612e1d1f
msgid "Lesson 3: Setting initial conditions and taking advantage of Frames"
msgstr "학습 3: 초기 조건 설정 및 프레임 활용"

#: ../../user_guide/tutorials/collisions.md:513
#: 9546ee1aedb141d2b2f8ee9839cd626c
msgid ""
"Find the ``addObject`` function in the ``MyWorld`` class. This function will"
" be called whenever the user requests for an object to be added to the "
"world. In this function, we want to set up the initial conditions for the "
"object so that it gets thrown at the wall. We also want to make sure that "
"it's not in collision with anything at the time that it's added, because "
"that would result in problems for the simulation."
msgstr ""
"``MyWorld`` 클래스에서 ``addObject`` 함수를 찾으세요. 이 함수는 사용자가 객체를 세계에 추가하도록 요청할 때마다 "
"호출됩니다. 이 함수에서는 물체가 벽에 던져질 수 있도록 물체의 초기 조건을 설정하려고 합니다. 또한 추가할 때 어떤 것과도 충돌하지 "
"않는지 확인하고 싶습니다. 그렇게 하면 시뮬레이션에 문제가 발생할 수 있기 때문입니다."

#: ../../user_guide/tutorials/collisions.md:520
#: 0a35a0d653e44e4395a14e9d953715a9
msgid "Lesson 3a: Set the starting position for the object"
msgstr "학습 3a: 개체의 시작 위치 설정"

#: ../../user_guide/tutorials/collisions.md:522
#: ba63c30d662f4074ba6c8e8eb3d2d30e
msgid ""
"We want to position the object in a reasonable place for us to throw it at "
"the wall. We also want to have the ability to randomize its location along "
"the y-axis."
msgstr ""
"우리는 벽에 던질 수 있는 적당한 위치에 물체를 배치하고 싶습니다. 우리는 또한 y축을 따라 위치를 무작위로 지정하는 기능을 원합니다."

#: ../../user_guide/tutorials/collisions.md:525
#: 010fd2aef0d742709d071aa7711a0dad
msgid "First, let's create a zero vector for the position:"
msgstr "먼저 위치에 대한 0 벡터를 만들어 보겠습니다."

#: ../../user_guide/tutorials/collisions.md:530
#: cfb6c52f51d541e783316ed50efe8100
msgid ""
"You'll notice that this is an math::Vector**6**d rather than the usual "
"math::Vector**3**d. This vector has six components because the root BodyNode"
" has 6 degrees of freedom: three for orientation and three for translation. "
"Because we follow Roy Featherstone's Spatial Vector convention, the "
"**first** three components are for **orientation** using a logmap (also "
"known as angle-axis) and the **last** three components are for "
"**translation**."
msgstr ""
"이것은 일반적인 math::Vector**3**d가 아니라 math::Vector**6**d라는 것을 알 수 있습니다. 루트 "
"BodyNode에는 6개의 자유도(방향에 3개, 변환에 3개)가 있으므로 이 벡터에는 6개의 구성요소가 있습니다. Roy "
"Featherstone의 공간 벡터 규칙을 따르기 때문에 **처음** 세 구성요소는 로그맵(각도 축이라고도 함)을 사용한 "
"**방향**용이고 **마지막** 세 구성요소는 **변환**용입니다."

#: ../../user_guide/tutorials/collisions.md:537
#: 1453580309e841d68a390efc4af86427
msgid ""
"First, if randomness is turned on, we'll set the y-translation to a "
"randomized value:"
msgstr "먼저 무작위성이 켜져 있으면 y-변환을 무작위 값으로 설정합니다."

#: ../../user_guide/tutorials/collisions.md:545
#: aa38403927e140efb17bf3f07ef0dae5
msgid ""
"``mDistribution(mMT)`` will generate a random value in the range \\[-1, 1\\]"
"  inclusive because of how we initialized the classes in the constructor of "
"``MyWindow``."
msgstr ""
"``mDistribution(mMT)``는 ``MyWindow`` 생성자에서 클래스를 초기화한 방식으로 인해 \\[-1, 1\\] "
"범위에서 임의의 값을 생성합니다."

#: ../../user_guide/tutorials/collisions.md:549
#: fc87e4354b3f4386952b7671bd224679
msgid "Then we always set the height to the default value:"
msgstr "그런 다음 항상 높이를 기본값으로 설정합니다."

#: ../../user_guide/tutorials/collisions.md:554
#: c1f92341f8f6484ea52d16e06c68fd55
msgid "Finally, we use this vector to set the positions of the root Joint:"
msgstr "마지막으로 이 벡터를 사용하여 루트 관절의 위치를 ​​설정합니다."

#: ../../user_guide/tutorials/collisions.md:559
#: 3802d3ef1cfa4d219b9c067b4deff5b9
msgid ""
"We trust that the root Joint is a FreeJoint with 6 degrees of freedom "
"because of how we constructed all the objects that are going to be thrown at"
" the wall: They were all given a FreeJoint between the world and the root "
"BodyNode."
msgstr ""
"우리는 벽에 던져질 모든 객체를 어떻게 구성했는가로 인해 루트 관절이 6 자유도를 가진 FreeJoint라고 믿습니다. 객체는 모두 "
"월드와 루트 BodyNode 사이에 FreeJoint가 주어졌습니다."

#: ../../user_guide/tutorials/collisions.md:563
#: cb81874897fd47059663e14ec58efb57
msgid "Lesson 3b: Set the object's name"
msgstr "3b단원: 개체 이름 설정"

#: ../../user_guide/tutorials/collisions.md:565
#: a51b6c8980fe486abfdf6e48d4628256
msgid ""
"Every object in the world is required to have a non-empty unique name. Just "
"like Joint names in a Skeleton, if we pass a Skeleton into a world with a "
"non-unique name, the world will print out a complaint to us and then rename "
"it. So avoid the ugly printout, we'll make sure the new object has a unique "
"name ahead of time:"
msgstr ""
"전 세계의 모든 객체에는 비어 있지 않은 고유 이름이 있어야 합니다. 스켈레톤의 공동 이름과 마찬가지로, 고유하지 않은 이름을 가진 "
"스켈레톤을 월드에 전달하면 월드는 우리에게 불만 사항을 인쇄한 다음 이름을 바꿉니다. 따라서 보기 흉한 인쇄 결과를 방지하고 새 개체에 "
"고유한 이름이 있는지 미리 확인하겠습니다."

#: ../../user_guide/tutorials/collisions.md:574
#: d1bf783d73744be092685ad999c231e5
msgid "Lesson 3c: Add the object to the world without collisions"
msgstr "3c단원: 충돌 없이 월드에 개체 추가"

#: ../../user_guide/tutorials/collisions.md:576
#: 5acaeb73eef744fc9bdb8c081fcbbf08
msgid ""
"Before we add the Skeleton to the world, we want to make sure that it isn't "
"actually placed inside of something accidentally. If an object in a  "
"simulation starts off inside of another object, it can result in extremely "
"non-physical simulations, perhaps even breaking the simulation entirely. We "
"can access the world's collision detector directly to check make sure the "
"new object is collision-free:"
msgstr ""
"스켈레톤을 월드에 추가하기 전에, 실제로 뭔가의 내부에 실수로 배치되지 않았는지 확인하고 싶습니다. 시뮬레이션의 객체가 다른 객체 "
"내부에서 시작되면 극도로 비물리적인 시뮬레이션이 발생할 수 있으며 심지어 시뮬레이션이 완전히 중단될 수도 있습니다. 우리는 새로운 객체가"
" 충돌이 없는지 확인하기 위해 세계의 충돌 감지기에 직접 접근할 수 있습니다:"

#: ../../user_guide/tutorials/collisions.md:588
#: 6ca30476112a4516ba06c342b7c3d918
msgid ""
"Now we shouldn't be surprised if the *other* objects are in collision with "
"each other, so we'll need to check whether our new object overlaps with any "
"existing objects.  First, we use the collision engine to create a group "
"which contains our object. Then,  we get a group containing the existing "
"objects in the world and use it to check for  collisions."
msgstr ""
"이제 *다른* 개체가 서로 충돌하더라도 놀라지 않아도 됩니다. 따라서 새 개체가 기존 개체와 겹치는지 확인해야 합니다.  먼저 충돌 "
"엔진을 사용하여 개체를 포함하는 그룹을 만듭니다. 그런 다음 세계에 있는 기존 객체를 포함하는 그룹을 가져와 이를 사용하여 충돌을 "
"확인합니다."

#: ../../user_guide/tutorials/collisions.md:603
#: 212bf87f15db49768d7d1d5059803c27
msgid ""
"If the new skeleton doesn't overlap an existing object, we can add it to the"
" world without any complaints:"
msgstr "새 스켈레톤이 기존 객체와 겹치지 않으면 아무런 불만 없이 월드에 추가할 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:619
#: 91ae2eb3d51845019c30070f5026c579
msgid ""
"Of course we should also print out a message so that user understands why we"
" didn't throw a new object."
msgstr "물론 우리는 왜 우리가 새 객체를 던지지 않았는지 사용자가 이해할 수 있도록 메시지를 인쇄해야 합니다."

#: ../../user_guide/tutorials/collisions.md:622
#: 6ad0bc6c42c6463ea7df1cc7b79b2321
msgid "Lesson 3d: Creating reference frames"
msgstr "3d과: 기준 좌표계 생성"

#: ../../user_guide/tutorials/collisions.md:624
#: f74a3281a5ed4b6c9bf4d9354f15246f
msgid ""
"DART has a unique feature that we call Frame Semantics. The Frame Semantics "
"of DART allow you to create reference frames and use them to get and set "
"data relative to arbitrary frames. There are two crucial Frame types "
"currently used in DART: ``BodyNode``s and ``SimpleFrame``s."
msgstr ""
"DART에는 프레임 의미론이라는 고유한 기능이 있습니다. DART의 프레임 의미 체계를 사용하면 참조 프레임을 생성하고 이를 사용하여 "
"임의 프레임과 관련된 데이터를 가져오고 설정할 수 있습니다. 현재 DART에는 ``BodyNode``와 ``SimpleFrame``이라는"
" 두 가지 중요한 프레임 유형이 사용됩니다."

#: ../../user_guide/tutorials/collisions.md:629
#: d38e1922e1624e08a556175065a0ce18
msgid ""
"The BodyNode class does not allow you to explicitly set its transform, "
"velocity, or acceleration properties, because those are all strictly "
"functions of the degrees of freedom that the BodyNode depends on. Because of"
" this, the BodyNode is not a very convenient class if you want to create an "
"arbitrary frame of reference. Instead, DART offers the ``SimpleFrame`` class"
" which gives you the freedom of arbitrarily attaching it to any parent Frame "
"and setting its transform, velocity, and acceleration to whatever you'd "
"like. This makes SimpleFrame useful for specifying arbitrary reference "
"frames."
msgstr ""
"BodyNode 클래스에서는 변형, 속도 또는 가속도 속성을 명시적으로 설정할 수 없습니다. 이는 모두 BodyNode가 의존하는 "
"자유도의 함수이기 때문입니다. 이 때문에 BodyNode는 임의의 참조 프레임을 생성하려는 경우 매우 편리한 클래스가 아닙니다. 대신 "
"DART는 상위 프레임에 임의로 연결하고 변환, 속도 및 가속도를 원하는 대로 설정할 수 있는 ``SimpleFrame`` 클래스를 "
"제공합니다. 따라서 SimpleFrame은 임의의 참조 프레임을 지정하는 데 유용합니다."

#: ../../user_guide/tutorials/collisions.md:638
#: e670e8c5909145acaf537a028f1321fb
msgid ""
"We're going to set up a couple SimpleFrames and use them to easily specify "
"the velocity properties that we want the Skeleton to have. First, we'll "
"place a SimpleFrame at the Skeleton's center of mass:"
msgstr ""
"우리는 몇 개의 SimpleFrame을 설정하고 이를 사용하여 Skeleton에 원하는 속도 속성을 쉽게 지정할 것입니다. 먼저 "
"Skeleton의 질량 중심에 SimpleFrame을 배치합니다."

#: ../../user_guide/tutorials/collisions.md:648
#: 74fcd078d71943d2ae1dc21f3b4b65c2
msgid ""
"Calling ``object->getCOM()`` will tell us the center of mass location with "
"respect to the World Frame. We use that to set the translation of the "
"SimpleFrame's relative transform so that the origin of the SimpleFrame will "
"be located at the object's center of mass."
msgstr ""
"``object->getCOM()``을 호출하면 월드 프레임에 대한 질량 중심 위치를 알려줍니다. 이를 사용하여 SimpleFrame의 "
"원점이 개체의 질량 중심에 위치하도록 SimpleFrame의 상대 변환 변환을 설정합니다."

#: ../../user_guide/tutorials/collisions.md:653
#: 99aed49822934e88bef419e391f163f3
msgid ""
"Now we'll set what we want the object's angular and linear speeds to be:"
msgstr "이제 객체의 각속도와 선형 속도를 원하는 대로 설정하겠습니다."

#: ../../user_guide/tutorials/collisions.md:671
#: 5d7be4f19e5747b7bbad4b0f94c97e68
msgid "We just use the default values unless randomization is turned on."
msgstr "무작위화가 활성화되어 있지 않으면 기본값을 사용합니다."

#: ../../user_guide/tutorials/collisions.md:673
#: 268301fc6df84faebbe6b0e86f1cbe16
msgid "Now we'll convert those speeds into directional velocities:"
msgstr "이제 해당 속도를 방향 속도로 변환하겠습니다."

#: ../../user_guide/tutorials/collisions.md:680
#: 887285f7d3d14634990ecb49f78f8d91
msgid ""
"And now we'll use those vectors to set the velocity properties of the "
"SimpleFrame:"
msgstr "이제 이러한 벡터를 사용하여 SimpleFrame의 속도 속성을 설정하겠습니다."

#: ../../user_guide/tutorials/collisions.md:686
#: eb7b248977c0416392dc24dbce785d26
msgid ""
"The ``SimpleFrame::setClassicDerivatives()`` allows you to set the classic "
"linear and angular velocities and accelerations of a SimpleFrame with "
"respect to its parent Frame, which in this case is the World Frame. In DART,"
" classic velocity and acceleration vectors are explicitly differentiated "
"from spatial velocity and acceleration vectors. If you are unfamiliar with "
"the term \"spatial vector\", then you'll most likely want to work in terms "
"of classic velocity and acceleration."
msgstr ""
"``SimpleFrame::setClassicDerivatives()``를 사용하면 상위 프레임(이 경우에는 월드 프레임)에 대해 "
"SimpleFrame의 일반적인 선형 및 각속도와 가속도를 설정할 수 있습니다. DART에서는 일반적인 속도 및 가속도 벡터가 공간 속도"
" 및 가속도 벡터와 명시적으로 구분됩니다. \"공간 벡터\"라는 용어에 익숙하지 않다면 고전적인 속도와 가속도 측면에서 작업하고 싶을 "
"것입니다."

#: ../../user_guide/tutorials/collisions.md:693
#: 47a2ed9422ce43c88afe9a747e31c1dc
msgid ""
"Now we want to create a new SimpleFrame that will be a child of the previous"
" one:"
msgstr "이제 이전 SimpleFrame의 자식이 될 새로운 SimpleFrame을 생성하려고 합니다."

#: ../../user_guide/tutorials/collisions.md:699
#: e408470d48d0478fa3d54021a768ebab
msgid ""
"And we want the origin of this new Frame to line up with the root BodyNode "
"of our object:"
msgstr "그리고 우리는 이 새로운 프레임의 원점이 우리 객체의 루트 BodyNode와 일치하기를 원합니다."

#: ../../user_guide/tutorials/collisions.md:706
#: f355c9e38be24c7e80e9063d95aff8f2
msgid ""
"Now we'll use this reference frame to set the velocity of the root BodyNode."
" By setting the velocity of the root BodyNode equal to the velocity of this "
"reference frame, we will ensure that the overall velocity of Skeleton's "
"center of mass is equal to the velocity of the ``center`` Frame from "
"earlier."
msgstr ""
"이제 이 참조 프레임을 사용하여 루트 BodyNode의 속도를 설정하겠습니다. 루트 BodyNode의 속도를 이 참조 프레임의 속도와 "
"동일하게 설정함으로써 스켈레톤 질량 중심의 전체 속도가 이전의 ``중심`` 프레임 속도와 동일하도록 보장합니다."

#: ../../user_guide/tutorials/collisions.md:715
#: 2e028e32b9fd4bdbb387dfed75dea4eb
msgid ""
"Note that the FreeJoint uses spatial velocity and spatial acceleration for "
"its degrees of freedom."
msgstr "FreeJoint는 자유도를 위해 공간 속도와 공간 가속도를 사용합니다."

#: ../../user_guide/tutorials/collisions.md:718
#: 1858af509c8e43a88f06c1a896b0c766
msgid "Now we're ready to toss around objects!"
msgstr "이제 객체를 던질 준비가 되었습니다!"

#: ../../user_guide/tutorials/collisions.md:720
#: a90d627e0367466c94757ebe3448cf57
msgid "Lesson 4: Setting joint spring and damping properties"
msgstr "학습 4: 접합 스프링 및 감쇠 속성 설정"

#: ../../user_guide/tutorials/collisions.md:722
#: 1f67d7db745d4d98aa51b374cdb17984
msgid ""
"Find the ``setupRing`` function. This is where we'll setup a chain of "
"BodyNodes so that it behaves more like a closed ring."
msgstr "``setupRing`` 기능을 찾으세요. 여기서는 닫힌 링처럼 작동하도록 BodyNodes 체인을 설정합니다."

#: ../../user_guide/tutorials/collisions.md:725
#: db358321137f47a19b5a313cba17cc4a
msgid "Lesson 4a: Set the spring and damping coefficients"
msgstr "4a단원: 스프링 및 감쇠 계수 설정"

#: ../../user_guide/tutorials/collisions.md:727
#: 597efd527cc0455f9e31101740ec1d15
msgid ""
"We'll want to set the stiffness and damping coefficients of only the "
"DegreesOfFreedom that are **between** two consecutive BodyNodes. The first "
"six degrees of freedom are between the root BodyNode and the World, so we "
"don't want to change the stiffness of them, or else the object will hover "
"unnaturally in the air. But all the rest of the degrees of freedom should be"
" set:"
msgstr ""
"두 개의 연속 BodyNodes **사이**에 있는 DegreesOfFreedom의 강성과 감쇠 계수만 설정하려고 합니다. 처음 6개의 "
"자유도는 루트 BodyNode와 World 사이에 있으므로 이들의 강성을 변경하고 싶지 않습니다. 그렇지 않으면 개체가 부자연스럽게 "
"공중에 떠 있게 됩니다. 하지만 나머지 모든 자유도는 다음과 같이 설정되어야 합니다."

#: ../../user_guide/tutorials/collisions.md:742
#: 1aa91a90395e4b4da5cec06c53ffe62f
msgid "Lesson 4b: Set the rest positions of the joints"
msgstr "4b단원: 관절의 나머지 위치 설정"

#: ../../user_guide/tutorials/collisions.md:744
#: a7c6928643854aa5adc185367b7659f8
msgid ""
"We want to make sure that the ring's rest position works well for the "
"structure it has. Using basic geometry, we know we can compute the exterior "
"angle on each edge of a polygon like so:"
msgstr ""
"우리는 링의 정지 위치가 그 구조에 잘 맞는지 확인하고 싶습니다. 기본 기하학을 사용하여 다음과 같이 다각형의 각 가장자리에 대한 외부 "
"각도를 계산할 수 있다는 것을 알고 있습니다."

#: ../../user_guide/tutorials/collisions.md:753
#: b85d2afe9f7d428294e269468aac41a9
msgid ""
"Now it's important to remember that the joints we have between the BodyNodes"
" are BallJoints, which use logmaps (a.k.a. angle-axis) to represent their "
"positions. The BallJoint class provides a convenience function for "
"converting rotations into a position vector for a BallJoint. A similar "
"function also exists for EulerJoint and FreeJoint."
msgstr ""
"이제 BodyNode 사이에 있는 조인트는 로그맵(일명 각도 축)을 사용하여 위치를 나타내는 BallJoint라는 점을 기억하는 것이 "
"중요합니다. BallJoint 클래스는 회전을 BallJoint의 위치 벡터로 변환하는 편리한 함수를 제공합니다. EulerJoint 및"
" FreeJoint에도 유사한 기능이 있습니다."

#: ../../user_guide/tutorials/collisions.md:771
#: 9133c9a469f449eca701434904213f47
msgid "Now we can set the rest positions component-wise:"
msgstr "이제 나머지 위치를 구성요소별로 설정할 수 있습니다."

#: ../../user_guide/tutorials/collisions.md:778
#: 653a6beab3864a239313cfe119d4c7be
msgid "Lesson 4c: Set the Joints to be in their rest positions"
msgstr "4c단원: 관절이 휴지 위치에 있도록 설정"

#: ../../user_guide/tutorials/collisions.md:780
#: 66854d853db54e6fb22d6082aafda1e9
msgid ""
"Finally, we should set the ring so that all the degrees of freedom (past the"
" root BodyNode) start out in their rest positions:"
msgstr "마지막으로 모든 자유도(루트 BodyNode를 지나)가 정지 위치에서 시작되도록 링을 설정해야 합니다."

#: ../../user_guide/tutorials/collisions.md:791
#: 427abad9255b4a6e9f4cfbabd66a92f0
msgid "Lesson 5: Create a closed kinematic chain"
msgstr "5단원: 닫힌 운동학적 체인 생성"

#: ../../user_guide/tutorials/collisions.md:793
#: ccb90de95dd040d8a06852676e23f79a
msgid ""
"Find the ``addRing`` function in ``MyWindow``. In here, we'll want to create"
" a dynamic constraint that attaches the first and last BodyNodes of the "
"chain together by a BallJoint-style constraint."
msgstr ""
"``MyWindow``에서 ``addRing`` 기능을 찾으세요. 여기서는 BallJoint 스타일 제약 조건을 통해 체인의 첫 번째 "
"BodyNodes와 마지막 BodyNodes를 함께 연결하는 동적 제약 조건을 생성하려고 합니다."

#: ../../user_guide/tutorials/collisions.md:797
#: 67dc4c300697435595aa3d1dae051a8d
msgid "First we'll grab the BodyNodes that we care about:"
msgstr "먼저 관심 있는 BodyNodes를 가져옵니다."

#: ../../user_guide/tutorials/collisions.md:804
#: 8c19e5ebd46f4348baeb99a6abfc3875
msgid ""
"Now we want to compute the offset where the BallJoint constraint should be "
"located:"
msgstr "이제 BallJoint 제약 조건이 위치해야 하는 오프셋을 계산하려고 합니다."

#: ../../user_guide/tutorials/collisions.md:811
#: ac80cec3947049099db843895ef0e9dc
msgid ""
"The offset will be located half the default height up from the center of the"
" tail BodyNode."
msgstr "오프셋은 꼬리 BodyNode 중심에서 위쪽으로 기본 높이의 절반 위치에 위치합니다."

#: ../../user_guide/tutorials/collisions.md:814
#: 371de317845b4efc909a77610781d562
msgid "Now we have everything we need to construct the constraint:"
msgstr "이제 제약 조건을 구성하는 데 필요한 모든 것이 준비되었습니다."

#: ../../user_guide/tutorials/collisions.md:821
#: 3b054ccb4c5b4b7da8d62dea03cb7758
msgid ""
"In order for the constraint to work, we'll need to add it to the world's "
"constraint solver:"
msgstr "제약 조건이 작동하려면 이를 월드의 제약 조건 솔버에 추가해야 합니다."

#: ../../user_guide/tutorials/collisions.md:828
#: 5218b7e768ff4c029c844e7559933f82
msgid ""
"And in order to properly clean up the constraint when removing BodyNodes, "
"we'll want to add it to our list of constraints:"
msgstr "BodyNodes를 제거할 때 제약 조건을 적절하게 정리하려면 이를 제약 조건 목록에 추가해야 합니다."

#: ../../user_guide/tutorials/collisions.md:835
#: 8fa5507c96194c80a863c9b53a7c4310
msgid ""
"And that's it! You're ready to run the full tutorialCollisions application!"
msgstr "그리고 그게 다야! 전체 튜토리얼Collisions 애플리케이션을 실행할 준비가 되었습니다!"

#: ../../user_guide/tutorials/collisions.md:837
#: 8091be163e984bd38e47f84f61d1e656
msgid ""
"**When running the application, keep in mind that the dynamics of collisions"
" are finnicky, so you may see some unstable and even completely non-physical"
" behavior. If the application freezes, you may need to force quit out of "
"it.**"
msgstr ""
"**애플리케이션을 실행할 때 충돌의 역학은 매우 까다롭기 때문에 일부 불안정하고 심지어 완전히 비물리적인 동작을 볼 수도 있다는 점을 "
"염두에 두십시오. 애플리케이션이 정지되면 강제로 종료해야 할 수도 있습니다.**"
