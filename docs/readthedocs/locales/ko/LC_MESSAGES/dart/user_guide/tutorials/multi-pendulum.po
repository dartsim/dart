# SOME DESCRIPTIVE TITLE.
# Copyright (C) Copyright (c) 2011, The DART development contributors
# This file is distributed under the same license as the DART: Dynamic
# Animation and Robotics Toolkit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: DART: Dynamic Animation and Robotics Toolkit 7.0.0-alpha0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-26 00:39-0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: ko <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.11.0\n"

#: ../../user_guide/tutorials/multi-pendulum.md:1
#: 46eb16e45884458fbf226bac709f20f8
msgid "Multi Pendulum"
msgstr "다중 진자"

#: ../../user_guide/tutorials/multi-pendulum.md:3
#: 14c12d7fe7a94934a6cd69456fd59cb7
msgid "Overview"
msgstr "개요"

#: ../../user_guide/tutorials/multi-pendulum.md:5
#: 78d58e7e1afc4abaa87f708fdbc252a8
msgid ""
"This tutorial will demonstrate some basic interaction with DART's dynamics "
"API during simulation. This will show you how to:"
msgstr "이 튜토리얼은 시뮤레이션 동안 DART의 동역학 API와의 기본적인 상호작용을 보여줍니다. 다음의 방법들을 알려드립니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:8
#: 458e9396a24548f7823c79cd8b1dd5df
msgid "Create a basic program to simulate a dynamic system"
msgstr "동적 시스템을 시뮤레이션하는 기본 프로그램 만들기"

#: ../../user_guide/tutorials/multi-pendulum.md:9
#: 288518f74997452ab72c41c3a96eddf6
msgid "Change the colors of shapes"
msgstr "도형의 색상 변경"

#: ../../user_guide/tutorials/multi-pendulum.md:10
#: 66af8ccf036f4580af00f80c8a1b547f
msgid "Add/remove shapes from visualization"
msgstr "시각화에서 도형 추가/제거"

#: ../../user_guide/tutorials/multi-pendulum.md:11
#: 7c1a3787227f4d97ba2130ffe6e331a2
msgid "Apply internal forces in the joints"
msgstr "조인트에 내부 힘을 가하기"

#: ../../user_guide/tutorials/multi-pendulum.md:12
#: 2088cbc2201e41fe9b5f68c33702243a
msgid "Apply external forces to the bodies"
msgstr "바디에 외력을 적용하기"

#: ../../user_guide/tutorials/multi-pendulum.md:13
#: 41d347efdfc241dc97c9e469873dac77
msgid "Alter the implicit spring and damping properties of joints"
msgstr "조인트의 내재된 스프링/감쇠 특성 조정하기"

#: ../../user_guide/tutorials/multi-pendulum.md:14
#: 4daf47394b2f4fae9df17034b8608f91
msgid "Add/remove dynamic constraints"
msgstr "동적 제약 조건 추가/제거"

#: ../../user_guide/tutorials/multi-pendulum.md:16
#: 780a73b9ebf54b9693d5875f11ec1eef
msgid ""
"Please reference the source code in "
"[**tutorials/tutorial_multi_pendulum/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_multi_pendulum/main.cpp)"
" and [**tutorialMultiPendulum-"
"Finished.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorialMultiPendulum-"
"Finished.cpp)."
msgstr ""
"자세한 구현은 "
"[**tutorials/tutorial_multi_pendulum/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_multi_pendulum/main.cpp)"
" 및 [**tutorialMultiPendulum-"
"Finished.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorialMultiPendulum-"
"Finished.cpp) 를 참고하세요."

#: ../../user_guide/tutorials/multi-pendulum.md:18
#: 9b834efc9ce04f98a00eefd55b300347
msgid "Lesson 0: Simulate a passive multi-pendulum"
msgstr "Lesson 0: 수동 다중 진자 시뮬레이션"

#: ../../user_guide/tutorials/multi-pendulum.md:20
#: fd03ce798d164f08b6cd2caf38c48488
msgid ""
"This is a warmup lesson that demonstrates how to set up a simulation program"
" in DART. The example we will use throughout this tutorial is a pendulum "
"with five rigid bodies swinging under gravity. DART allows the user to build"
" various articulated rigid/soft body systems from scratch. It also loads "
"models in URDF, SDF, and SKEL formats as demonstrated in the later "
"tutorials."
msgstr ""
"이 워밍업 단계에서는 DART에서 시뮬레이션 프로그램을 구성하는 방법을 설명합니다. 튜토리얼 전반에 사용할 예제는 중력 하에서 움직이는 "
"다섯 개의 강체로 구성된 진자입니다. DART를 사용하면 사용자 정의 관절 강체/연성체 시스템을 처음부터 만들 수 있습니다. 이후 "
"튜토리얼에서 다루듯 URDF, SDF, SKEL 형식의 모델도 불러올 수 있습니다."

#: ../../user_guide/tutorials/multi-pendulum.md:27
#: 88562a8fcb5a430e834db39603e031b3
msgid ""
"In DART, an articulated dynamics model is represented by a ``Skeleton``. In "
"the ``main`` function, we first create an empty skeleton named *pendulum*."
msgstr ""
"DART에서는 관절 구조의 동역학 모델을 ``Skeleton`` 으로 표현합니다. ``main`` 함수에서 먼저 *pendulum* "
"이라는 빈 스켈레톤을 생성합니다."

#: ../../user_guide/tutorials/multi-pendulum.md:35
#: 97c1aaf10a8e4b2b8c89e3fac3498fd8
msgid ""
"A Skeleton is a structure that consists of ``BodyNode``s (bodies) which are"
"  connected by ``Joint``s. Every Joint has a child BodyNode, and every "
"BodyNode  has a parent Joint. Even the root BodyNode has a Joint that "
"attaches it to the  World. In the function ``makeRootBody``, we create a "
"pair of a ``BallJoint``  and a BodyNode, and attach this pair to the "
"currently empty pendulum skeleton."
msgstr ""
"Skeleton은 서로 ``Joint`` 로 연결된 여러 ``BodyNode``(바디)로 이루어집니다. 모든 조인트는 자식 "
"BodyNode를 하나 가지며, 모든 BodyNode는 부모 조인트를 가집니다. 루트 BodyNode 역시 월드에 연결되는 조인트를 "
"갖습니다. ``makeRootBody`` 함수에서는 ``BallJoint`` 와 BodyNode 한 쌍을 만들고, 이를 비어 있는 "
"pendulum 스켈레톤에 붙입니다."

#: ../../user_guide/tutorials/multi-pendulum.md:47
#: bfde1ffca96344a3aa14c87d1c10430e
msgid ""
"Note that the first parameters is a nullptr, which indicates that this new "
"BodyNode is the root of the pendulum. If we wish to append the new BodyNode "
"to an existing BodyNode in the pendulum, we can do so by passing the pointer"
" of the existing BodyNode as the first parameter. In fact, this is how we "
"add more BodyNodes to the pendulum in the function ``addBody``:"
msgstr ""
"첫 번째 인자가 nullptr인 것은 새 BodyNode가 펜듈럼의 루트임을 의미합니다. 기존 BodyNode에 이어 붙이고 싶다면 첫 "
"번째 인수로 그 BodyNode의 포인터를 넘기면 됩니다. 실제로 ``addBody`` 함수에서 추가 BodyNode를 붙일 때 이렇게 "
"동작합니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:58
#: f442138b3cc44ac8b902bf2403638ee7
msgid ""
"The simplest way to set up a simulation program in DART is to use "
"``SimWindow`` class. A SimWindow owns an instance of ``World``  and "
"simulates all the Skeletons in the World. In this example, we create a World"
" with the pendulum skeleton in it, and assign the World to an instance of "
"``MyWindow``, a subclass derived from SimWindow."
msgstr ""
"DART에서 가장 간단하게 시뮬레이션 프로그램을 구성하는 방법은 ``SimWindow`` 클래스를 사용하는 것입니다. SimWindow는"
" ``World`` 인스턴스를 하나 소유하며 월드 안의 모든 스켈레톤을 시뮬레이션합니다. 이 예제에서는 펜듈럼 스켈레톤을 포함한 월드를 "
"만들고, SimWindow를 상속한 ``MyWindow`` 인스턴스에 할당합니다."

#: ../../user_guide/tutorials/multi-pendulum.md:70
#: eeea1c1b2dd3403890e22b98769488d2
msgid ""
"Every single time step, the ``MyWindow::timeStepping`` function will be "
"called and the state of the World will be simulated. The user can override "
"the default timeStepping function to customize the simulation routine. For "
"example, one can incorporate sensors, actuators, or user interaction in the "
"forward simulation."
msgstr ""
"매 타임스텝마다 ``MyWindow::timeStepping`` 함수가 호출되어 월드의 상태를 갱신합니다. 기본 timeStepping "
"함수를 오버라이드하면 시뮬레이션 루틴을 원하는 대로 확장할 수 있습니다. 예를 들어 전방 시뮬레이션에 센서, 액추에이터 또는 사용자 "
"상호작용을 포함할 수 있습니다."

#: ../../user_guide/tutorials/multi-pendulum.md:77
#: 97040db0a9e946f190139f5e5641afab
msgid "Lesson 1: Change shapes and applying forces"
msgstr "Lesson 1: 도형 변경 및 힘 적용"

#: ../../user_guide/tutorials/multi-pendulum.md:79
#: d8b5cb2bd71f4deba2a8f39a170c9677
msgid ""
"We have a pendulum with five bodies, and we want to be able to apply forces "
"to them during simulation. Additionally, we want to visualize these forces "
"so we can more easily interpret what is happening in the simulation. For "
"this reason, we'll discuss visualizing and forces at the same time."
msgstr ""
"우리는 다섯 개의 바디로 이루어진 펜듈럼에 시뮬레이션 도중 힘을 가할 수 있기를 원합니다. 또한 이 힘들을 시각화해 시뮬레이션 상태를 더"
" 쉽게 파악하고자 합니다. 따라서 시각화와 힘 처리를 함께 다룹니다."

#: ../../user_guide/tutorials/multi-pendulum.md:84
#: b778cf14c9e443f6ba38ddfa65b2f2e1
msgid "Lesson 1a: Reset everything to default appearance"
msgstr "Lesson 1a: 기본 외관으로 초기화"

#: ../../user_guide/tutorials/multi-pendulum.md:86
#: a1d659a3b15a40838aa81a65d990ac7d
msgid ""
"At each step, we'll want to make sure that everything starts out with its "
"default appearance. The default is for everything to be blue and there not "
"to be any arrow attached to any body."
msgstr ""
"각 단계에서 모든 요소가 기본 외관으로 시작하도록 해야 합니다. 기본값은 모든 도형이 파란색이며 어떠한 바디에도 화살표가 붙어 있지 않은"
" 상태입니다."

#: ../../user_guide/tutorials/multi-pendulum.md:90
#: 58e1412a011a48e48665c5124b063027
msgid ""
"Find the function named ``timeStepping`` in the ``MyWindow`` class. The top "
"of this function is where we will want to reset everything to the default "
"appearance."
msgstr ""
"``MyWindow`` 클래스에서 ``timeStepping`` 함수를 찾습니다. 이 함수의 앞부분에서 모든 외관을 기본값으로 되돌릴 "
"것입니다."

#: ../../user_guide/tutorials/multi-pendulum.md:93
#: d77eaba2437b418ea55fca002d9a768c
msgid ""
"Each BodyNode contains visualization ``Shape``s that will be rendered during"
" simulation. In our case, each BodyNode has two shapes:"
msgstr ""
"각 BodyNode에는 시뮬레이션 중 렌더링되는 시각화 ``Shape`` 가 들어 있습니다. 우리의 예제 BodyNode마다 두 개의 "
"Shape가 있습니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:96
#: ea8c8cbcf8be4ea697686ac22d8cef0e
msgid "One shape to visualize the parent joint"
msgstr "부모 조인트를 표현하는 Shape 하나"

#: ../../user_guide/tutorials/multi-pendulum.md:97
#: f48bec4f13de48d7ba1490379a9dd76f
msgid "One shape to visualize the body"
msgstr "바디를 표현하는 Shape 하나"

#: ../../user_guide/tutorials/multi-pendulum.md:99
#: d178020ce1ee439a8407e7303a9e3a66
msgid ""
"The default appearance for everything is to be colored blue, so we'll want "
"to iterate through these two Shapes in each BodyNode, setting their colors "
"to blue."
msgstr "모든 요소의 기본 색상은 파란색이므로 각 BodyNode의 두 Shape를 순회하며 색상을 파란색으로 바꿔 줍니다."

#: ../../user_guide/tutorials/multi-pendulum.md:116
#: fb89ba42ac2d4c428c82ed5769dc9a53
msgid ""
"Additionally, there is the possibility that some BodyNodes will have an "
"arrow shape attached if the user had been applying an external body force to"
" it. By default, this arrow should not be attached, so in the outer for-"
"loop, we should check for arrows and remove them:"
msgstr ""
"또한 사용자가 외력을 가했다면 일부 BodyNode에 화살표 Shape가 붙어 있을 수 있습니다. 기본 상태에서는 화살표가 없어야 하므로"
" 바깥 for 루프에서 이러한 화살표를 확인해 제거합니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:128
#: 46123cdfcc8f4715ba007da033649494
msgid "Now everything will be reset to the default appearance."
msgstr "이제 모든 요소가 기본 외관으로 초기화됩니다."

#: ../../user_guide/tutorials/multi-pendulum.md:130
#: a18342ab364642e6a4eed034cfee9115
msgid "Lesson 1b: Apply joint torques based on user input"
msgstr "Lesson 1b: 사용자 입력에 따라 조인트 토크 적용"

#: ../../user_guide/tutorials/multi-pendulum.md:132
#: a987d1fe97124f4eb4b31ec6c798eb58
msgid ""
"The ``MyWindow`` class in this tutorial has a variable called "
"``mForceCountDown`` which is a ``std::vector<int>`` whose entries get set to"
" a value of ``default_countdown`` each time the user presses a number key. "
"If an entry in ``mForceCountDown`` is greater than zero, then that implies "
"that the user wants a force to be applied for that entry."
msgstr ""
"이 튜토리얼의 ``MyWindow`` 클래스에는 ``mForceCountDown`` 이라는 ``std::vector<int>`` 변수가 "
"있습니다. 사용자가 숫자 키를 누를 때마다 해당 요소가 ``default_countdown`` 값으로 설정됩니다. "
"``mForceCountDown`` 의 항목이 0보다 크면 그 항목에 힘을 적용하고자 함을 의미합니다."

#: ../../user_guide/tutorials/multi-pendulum.md:138
#: d2c7409e13794727b230e6b7c974bc8b
msgid "There are two ways that forces can be applied:"
msgstr "힘을 적용하는 방법은 두 가지입니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:140
#: 417b9ab8fde14335b80cbb9c09e61926
msgid "As an internal joint force"
msgstr "조인트 내부 힘으로 적용"

#: ../../user_guide/tutorials/multi-pendulum.md:141
#: 0f902d0972b343e592089b50b4cf545a
msgid "As an external body force"
msgstr "바디 외력으로 적용"

#: ../../user_guide/tutorials/multi-pendulum.md:143
#: 068c8cdce82a401491c6725fb0ed2bb6
msgid ""
"First we'll consider applying a Joint force. Inside the for-loop that goes "
"through each ``DegreeOfFreedom`` using ``getNumDofs()``, there is an  if-"
"statement for ``mForceCountDown``. In that if-statement, we'll grab the "
"relevant DegreeOfFreedom and set its generalized (joint) force:"
msgstr ""
"먼저 조인트 힘 적용을 살펴보겠습니다. ``getNumDofs()`` 로 각 ``DegreeOfFreedom`` 을 순회하는 for 루프"
" 내부에 ``mForceCountDown`` 을 확인하는 if 문이 있습니다. 이 안에서 해당 자유도를 가져와 그 일반화(조인트) 힘을 "
"설정합니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:153
#: 0b9f9c7806b54e25b6881b90a4f1d9f0
msgid ""
"The ``mPositiveSign`` boolean gets toggled when the user presses the minus "
"sign '-' key. We use this boolean to decide whether the applied force should"
" be positive or negative."
msgstr ""
"사용자가 '-' 키를 누르면 ``mPositiveSign`` 불리언 값이 토글됩니다. 이 값을 사용해 적용할 힘의 부호를 결정합니다."

#: ../../user_guide/tutorials/multi-pendulum.md:157
#: 8acc3ccb210d40e3a01092fb4c4dcb10
msgid ""
"Now we'll want to visualize the fact that a Joint force is being applied. "
"We'll do this by highlighting the joint with the color red. First we'll grab"
" the Shape that corresponds to this Joint:"
msgstr ""
"이제 조인트 힘이 적용 중임을 시각화하려 합니다. 조인트를 빨간색으로 강조 표시하면 됩니다. 먼저 해당 조인트에 대응하는 Shape를 "
"가져옵니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:166
#: 598daba15ce148898fa759a020338544
msgid ""
"Because of the way the pendulum bodies were constructed, we trust that the "
"zeroth indexed visualization shape will be the shape that depicts the joint."
" So now we will color it red:"
msgstr ""
"펜듈럼 바디의 구성 방식을 고려하면 0번 인덱스 Shape가 조인트를 나타낸다고 가정할 수 있습니다. 따라서 이 Shape를 빨간색으로 "
"칠합니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:174
#: 52c72327e12b451d94f6ff274d67c14f
msgid "Lesson 1c: Apply body forces based on user input"
msgstr "Lesson 1c: 사용자 입력에 따라 바디 외력 적용"

#: ../../user_guide/tutorials/multi-pendulum.md:176
#: 3a97c567e7a94434a092077c57a914d1
msgid ""
"If mBodyForce is true, we'll want to apply an external force to the body "
"instead of an internal force in the joint. First, inside the for-loop that "
"iterates through each ``BodyNode`` using ``getNumBodyNodes()``, there is an "
"if-statement for ``mForceCountDown``. In that if-statement, we'll grab the "
"relevant BodyNode:"
msgstr ""
"mBodyForce가 true이면 조인트 내부 힘 대신 바디 외력을 적용합니다. ``getNumBodyNodes()`` 로 각 "
"``BodyNode`` 를 순회하는 for 루프 안에 ``mForceCountDown`` 을 확인하는 if 문이 있습니다. 그 안에서 "
"해당 BodyNode를 가져옵니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:185
#: ed63872a287a440abbb9f96259cb6850
msgid ""
"Now we'll create an ``math::Vector3d`` that describes the force and another "
"one that describes the location for that force. An ``math::Vector3d`` is the"
" Eigen C++ library's version of a three-dimensional mathematical vector. "
"Note that the ``d`` at the end of the name stands for ``double``, not for "
"\"dimension\". An math::Vector3f would be a three-dimensional vector of "
"floats, and an math::Vector3i would be a three-dimensional vector of "
"integers."
msgstr ""
"이제 힘을 표현하는 ``math::Vector3d`` 와, 힘이 작용할 위치를 나타내는 또 다른 벡터를 만듭니다. "
"``math::Vector3d`` 는 Eigen C++ 라이브러리에서 제공하는 3차원 수학 벡터 타입입니다. 이름 끝의 ``d`` 는 "
"\"차원\"이 아니라 ``double`` 을 의미합니다. ``math::Vector3f`` 는 float 벡터, "
"``math::Vector3i`` 는 정수 벡터입니다."

#: ../../user_guide/tutorials/multi-pendulum.md:197
#: b46669ba512242e385883df4776548d1
msgid ""
"The force will have a magnitude of ``default_force`` and it will point in "
"the positive x-direction. The location of the force will be in the center of"
" the negative x side of the body, as if a finger on the negative side is "
"pushing the body in the positive direction. However, we need to account for "
"sign changes:"
msgstr ""
"힘의 크기는 ``default_force`` 이며 양의 x 방향을 가리킵니다. 힘의 위치는 바디의 음의 x 면 중심으로, 음의 방향에서 "
"양의 방향으로 누르는 손가락을 상상하면 됩니다. 단, 부호가 바뀔 수 있으므로 다음과 같이 처리합니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:210
#: ad0a30ea91884af7970d90ad45a10711
msgid ""
"That will flip the signs whenever the user is requesting a negative force."
msgstr "이렇게 하면 사용자가 음의 힘을 요청할 때마다 부호가 뒤집힙니다."

#: ../../user_guide/tutorials/multi-pendulum.md:212
#: d57d3f05c8a542099970be2f6279769a
msgid "Now we can add the external force:"
msgstr "이제 외력을 추가할 수 있습니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:218
#: bdf2572fc93a472eae95d671db6d6049
msgid ""
"The two ``true`` booleans at the end are indicating to DART that both the "
"force and the location vectors are being expressed with respect to the body "
"frame."
msgstr "마지막에 있는 두 개의 ``true`` 값은 힘과 위치 벡터가 모두 바디 좌표계 기준임을 DART에 알려줍니다."

#: ../../user_guide/tutorials/multi-pendulum.md:221
#: 64e2f94a40194e1780b391a16bc13129
msgid ""
"Now we'll want to visualize the force being applied to the body. First, "
"we'll grab the Shape for the body and color it red:"
msgstr "이제 바디에 적용된 힘을 시각화합니다. 먼저 해당 바디 Shape를 가져와 빨간색으로 색칠합니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:229
#: 05114826ddb34bc9a164672ae0ecabd0
msgid ""
"Last time we grabbed the 0-index visualization shape, because we trusted "
"that it was the shape that represented the parent Joint. This time we're "
"grabbing the 1-index visualization shape, because we trust that it is the "
"shape for the body."
msgstr ""
"이전에 우리는 부모 조인트를 나타낸다고 믿는 0번 인덱스 Shape를 사용했습니다. 이번에는 바디를 나타낸다고 믿는 1번 인덱스 "
"Shape를 가져옵니다."

#: ../../user_guide/tutorials/multi-pendulum.md:234
#: 5e0aad2241284583a2e1813a2497f10b
msgid ""
"Now we'll want to add an arrow to the visualization shapes of the body to "
"represent the applied force. The ``MyWindow`` class already provides the "
"arrow shape; we just need to add it:"
msgstr ""
"이제 바디 시각화 Shape에 화살표를 추가해 적용된 힘을 표현하겠습니다. ``MyWindow`` 클래스에는 이미 화살표 Shape가 "
"있으므로 가져오기만 하면 됩니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:242
#: db2be6088b114287991ccb8c4f8a7cc1
msgid "Lesson 2: Set spring and damping properties for joints"
msgstr "Lesson 2: 조인트 스프링과 감쇠 특성 설정"

#: ../../user_guide/tutorials/multi-pendulum.md:244
#: 1581b921e88c4502bcbb85dd0c3de5e9
msgid ""
"DART allows Joints to have implicit spring and damping properties. By "
"default, these properties are zeroed out, so a joint will only exhibit the "
"forces that are given to it by the ``Joint::setForces`` function. However, "
"you can give a non-zero spring coefficient to a joint so that it behaves "
"according to Hooke's Law, and you can give a non-zero damping coefficient to"
" a joint which will result in linear damping. These forces are computed "
"using implicit methods in order to improve numerical stability."
msgstr ""
"DART의 조인트는 내재된 스프링 및 감쇠 특성을 가질 수 있습니다. 기본적으로 이 값들은 0이어서 조인트는 "
"``Joint::setForces`` 로 전달된 힘만 생성합니다. 하지만 스프링 계수를 0이 아닌 값으로 설정하면 조인트가 훅의 법칙에 "
"따라 작동하며, 감쇠 계수를 0이 아닌 값으로 설정하면 선형 감쇠가 적용됩니다. 이러한 힘은 수치적 안정성을 높이기 위해 암시적 방식으로"
" 계산됩니다."

#: ../../user_guide/tutorials/multi-pendulum.md:252
#: ed42a042d58d48bca54c543cf108b7b1
msgid "Lesson 2a: Set joint spring rest position"
msgstr "Lesson 2a: 조인트 스프링 평형 위치 설정"

#: ../../user_guide/tutorials/multi-pendulum.md:254
#: bc8c43942da648cab0009aff2e8f8b86
msgid "First let's see how to get and set the rest positions."
msgstr "먼저 평형 위치를 가져오고 설정하는 방법을 살펴보겠습니다."

#: ../../user_guide/tutorials/multi-pendulum.md:256
#: 021c9a06d09641a2b18341d471e7efba
msgid ""
"Find the function named ``changeRestPosition`` in the ``MyWindow`` class. "
"This function will be called whenever the user presses the 'q' or 'a' "
"button. We want those buttons to curl and uncurl the rest positions for the "
"pendulum. To start, we'll go through all the generalized coordinates and "
"change their rest positions by ``delta``:"
msgstr ""
"``MyWindow`` 클래스에서 ``changeRestPosition`` 함수를 찾습니다. 사용자가 'q' 또는 'a' 키를 누를 "
"때마다 이 함수가 호출됩니다. 해당 키로 펜듈럼의 평형 위치를 감고 펼 수 있도록 합니다. 먼저 모든 일반화 좌표를 순회하며 평형 위치에"
" ``delta`` 만큼 변화를 줍니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:272
#: 63f22e9bd1e246fa9865d4ba8b29198f
msgid ""
"However, it's important to note that the system can become somewhat unstable"
" if we allow it to curl up too much, so let's put a limit on the magnitude "
"of the rest angle. Right before ``dof->setRestPosition(q0);`` we can put:"
msgstr ""
"하지만 너무 많이 감기도록 허용하면 시스템이 다소 불안정해질 수 있으니 평형 각도의 크기에 제한을 둡니다. "
"``dof->setRestPosition(q0);`` 호출 직전에 다음 코드를 넣습니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:281
#: 3b554b4f28d3460c9c18509cada557e0
msgid ""
"And there's one last thing to consider: the first joint of the pendulum is a"
" BallJoint. BallJoints have three degrees of freedom, which means if we "
"alter the rest positions of *all* of the pendulum's degrees of freedom, then"
" the pendulum will end up curling out of the x-z plane. You can allow this "
"to happen if you want, or you can prevent it from happening by zeroing out "
"the rest positions of the BallJoint's other two degrees of freedom:"
msgstr ""
"마지막으로 고려할 점이 있습니다. 펜듈럼의 첫 번째 조인트는 BallJoint이며 세 개의 자유도를 가집니다. 모든 자유도의 평형 위치를"
" 변경하면 펜듈럼이 x-z 평면 밖으로 꼬입니다. 원하는 경우 그렇게 두어도 되지만, BallJoint의 나머지 두 자유도의 평형 위치를"
" 0으로 유지하면 이를 방지할 수 있습니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:293
#: 7e101389b96f4b30b9f361dce92b1f1a
msgid "Lesson 2b: Set joint spring stiffness"
msgstr "Lesson 2b: 조인트 스프링 강성 설정"

#: ../../user_guide/tutorials/multi-pendulum.md:295
#: eb86ef9838684d238d12c89963e49f60
msgid ""
"Changing the rest position does not accomplish anything without having any "
"spring stiffness. We can change the spring stiffness as follows:"
msgstr "스프링 강성이 없으면 평형 위치를 바꿔도 효과가 없습니다. 다음과 같이 스프링 강성을 설정할 수 있습니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:307
#: 01aa5d5c40e5438c8a7fe24327a27beb
msgid ""
"However, it's important to realize that if the spring stiffness were ever to"
" become negative, we would get some very nasty explosive behavior. It's also"
" a bad idea to just trust the user to avoid decrementing it into being "
"negative. So before the line ``dof->setSpringStiffness(stiffness);`` you'll "
"want to put:"
msgstr ""
"다만 스프링 강성이 음수가 되면 폭발적인 거동이 나타나므로 주의해야 합니다. 사용자가 실수로 음수로 줄이지 않을 것이라고 믿는 것도 좋지"
" 않습니다. 따라서 ``dof->setSpringStiffness(stiffness);`` 앞에 다음을 넣어야 합니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:317
#: 3ae2d3a1bb1d41798871835b1d1340c8
msgid "Lesson 2c: Set joint damping"
msgstr "Lesson 2c: 조인트 감쇠 설정"

#: ../../user_guide/tutorials/multi-pendulum.md:319
#: 2cae9d33952a40be8feb7e048ff44c33
msgid ""
"Joint damping can be thought of as friction inside the joint actuator. It "
"applies a resistive force to the joint which is proportional to the "
"generalized velocities of the joint. This draws energy out of the system and"
" generally results in more stable behavior."
msgstr ""
"조인트 감쇠는 조인트 액추에이터 내부의 마찰로 생각할 수 있습니다. 일반화 속도에 비례하는 저항력을 조인트에 가해 시스템에서 에너지를 "
"빼앗고 전체적으로 더 안정적인 거동을 유도합니다."

#: ../../user_guide/tutorials/multi-pendulum.md:324
#: 9b6fad5289244fb8805bb434ce1e07a6
msgid ""
"The API for getting and setting the damping is just like the API for "
"stiffness:"
msgstr "감쇠 값을 가져오고 설정하는 API는 강성 API와 동일합니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:337
#: 06fffed601dc4ac387214db3cb24c429
msgid ""
"Again, we want to make sure that the damping coefficient is never negative. "
"In fact, a negative damping coefficient would be far more harmful than a "
"negative stiffness coefficient."
msgstr "감쇠 계수 역시 절대 음수가 되지 않도록 해야 합니다. 실제로 음의 감쇠 계수는 음의 강성보다 훨씬 더 위험합니다."

#: ../../user_guide/tutorials/multi-pendulum.md:341
#: 5105b5b141cf4bfb9aa4204be00839f4
msgid "Lesson 3: Add and remove dynamic constraints"
msgstr "Lesson 3: 동적 제약 추가 및 제거"

#: ../../user_guide/tutorials/multi-pendulum.md:343
#: 1f2ce123d19f46b688ce6f819cbb641e
msgid ""
"Dynamic constraints in DART allow you to attach two BodyNodes together "
"according to a selection of a few different Joint-style constraints. This "
"allows you to create closed loop constraints, which is not possible using "
"standard Joints. You can also create a dynamic constraint that attaches a "
"BodyNode to the World instead of to another BodyNode."
msgstr ""
"DART의 동적 제약은 여러 유형의 조인트 방식 제약 중 하나를 선택해 두 BodyNode를 연결할 수 있게 합니다. 이를 통해 일반 "
"조인트로는 만들 수 없는 폐루프 제약을 구성할 수 있습니다. 또한 다른 BodyNode가 아닌 월드에 BodyNode를 연결하는 동적 "
"제약도 만들 수 있습니다."

#: ../../user_guide/tutorials/multi-pendulum.md:349
#: 73708b81185a4baeb53a6d6ec42fa16a
msgid ""
"In our case, we want to attach the last BodyNode to the World with a "
"BallJoint style constraint whenever the function ``addConstraint()`` gets "
"called. First, let's grab the last BodyNode in the pendulum:"
msgstr ""
"우리 예제에서는 ``addConstraint()`` 가 호출될 때마다 마지막 BodyNode를 BallJoint 스타일 제약으로 월드에 "
"연결하려 합니다. 먼저 펜듈럼의 마지막 BodyNode를 얻습니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:357
#: 4355f11860aa48f49b7240129be7a424
msgid ""
"Now we'll want to compute the location that the constraint should have. We "
"want to connect the very end of the tip to the world, so the location would "
"be:"
msgstr "이제 제약이 위치해야 할 지점을 계산합니다. 끝단을 월드에 연결하고자 하므로 위치는 다음과 같습니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:365
#: 5ce5273c83dc4e3f87e39ed60aa89455
msgid "Now we can create the BallJointConstraint:"
msgstr "이제 BallJointConstraint를 생성합니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:372
#: 380abc0c9c1f4b0692d8aaf43dfe5b10
msgid "And then add it to the world:"
msgstr "그리고 월드에 추가합니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:378
#: d39289430991460992ffeaac0fe52d31
msgid ""
"Now we also want to be able to remove this constraint. In the function "
"``removeConstraint()``, we can put the following code:"
msgstr "이제 이 제약을 제거할 수도 있어야 합니다. ``removeConstraint()`` 함수에 다음 코드를 넣습니다:"

#: ../../user_guide/tutorials/multi-pendulum.md:386
#: 323f9b24986b4b568cbf682e2ef15c62
msgid ""
"Setting mBallConstraint to a nullptr will allow its smart pointer to delete "
"it."
msgstr "mBallConstraint를 nullptr로 설정하면 스마트 포인터가 제약을 삭제할 수 있습니다."

#: ../../user_guide/tutorials/multi-pendulum.md:388
#: 1040411d104446068298b2098264ac8f
msgid "**Now you are ready to run the demo!**"
msgstr "**이제 데모를 실행할 준비가 되었습니다!**"
