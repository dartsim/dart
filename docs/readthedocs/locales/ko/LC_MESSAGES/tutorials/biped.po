# SOME DESCRIPTIVE TITLE.
# Copyright (C) Copyright (c) 2011-2025, The DART development contributors
# This file is distributed under the same license as the DART: Dynamic
# Animation and Robotics Toolkit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: DART: Dynamic Animation and Robotics Toolkit "
"7.0.0-alpha0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-23 06:06-0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ko\n"
"Language-Team: ko <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../tutorials/biped.md:1 2547f515f49e44fe89eb3596263c71f6
msgid "Biped"
msgstr "이족 보행"

#: ../../tutorials/biped.md:3 e3bd29b9be5c4d27b47bece670701249
msgid "Overview"
msgstr "개요"

#: ../../tutorials/biped.md:4 f41d5e0be1d0493384ca9463610627cb
msgid ""
"This tutorial demonstrates the dynamic features in DART useful for "
"developing controllers for bipedal or wheel-based robots. The tutorial "
"consists of seven Lessons covering the following topics:"
msgstr ""
"이 튜토리얼은 이족 보행 혹은 바퀴 기반 로봇의 제어기를 개발할 때 유용한 DART의 동역학 기능을 "
"소개합니다. 총 일곱 개 Lesson으로 구성되어 있으며 다음 주제를 다룹니다:"

#: ../../tutorials/biped.md:8 a1dedac556824c9aa00e5e1755cfe952
msgid "Joint limits and self-collision."
msgstr "조인트 제한과 자충돌"

#: ../../tutorials/biped.md:9 6c5e9f6ad2c14b86a918407fcbc1f5f7
msgid "Actuators types and management."
msgstr "액추에이터 유형과 관리"

#: ../../tutorials/biped.md:10 ba88ad2e74aa4ea7acdefadb772f13b3
msgid "APIs for Jacobian matrices and other kinematic quantities."
msgstr "자코비안 및 기타 운동학량 API"

#: ../../tutorials/biped.md:11 4860a513296e498481ff94f77cdaad0a
msgid "APIs for dynamic quantities."
msgstr "동역학량 API"

#: ../../tutorials/biped.md:12 16e4c7a6dd4049789385e03b19e67184
msgid "Skeleton editing."
msgstr "스켈레톤 편집"

#: ../../tutorials/biped.md:14 8aeaa3a4d9f24f0a962f941423a197f1
msgid ""
"Please reference the source code in "
"[**tutorialBiped.cpp**](https://github.com/dartsim/dart/blob/release-5.1/tutorials/tutorialBiped.cpp)"
" and [**tutorialBiped-"
"Finished.cpp**](https://github.com/dartsim/dart/blob/release-5.1/tutorials"
"/tutorialBiped-Finished.cpp)."
msgstr ""
"자세한 구현은 "
"[**tutorialBiped.cpp**](https://github.com/dartsim/dart/blob/release-5.1/tutorials/tutorialBiped.cpp)"
" 와 "
"[**tutorialBiped-Finished.cpp**](https://github.com/dartsim/dart/blob/release-5.1/tutorials/tutorialBiped-Finished.cpp)"
" 를 참고하세요."

#: ../../tutorials/biped.md:16 6a1e709324b943bda38250999077b9fe
msgid "Lesson 1: Joint limits and self-collision"
msgstr "Lesson 1: 조인트 제한과 자충돌"

#: ../../tutorials/biped.md:17 fad6e5b3e7344c4ba5f8d6086a2242ed
msgid ""
"Let's start by locating the ``main`` function in tutorialBiped.cpp. We "
"first create a floor and call ``loadBiped`` to load a bipedal figure "
"described in SKEL format, which is an XML format representing a robot "
"model. A SKEL file describes a ``World`` with one or more ``Skeleton``s "
"in it. Here we load in a World from "
"[**biped.skel**](https://github.com/dartsim/dart/blob/release-5.1/data/skel/biped.skel)"
" and assign the bipedal figure to a ``Skeleton`` pointer called *biped*."
msgstr ""
"tutorialBiped.cpp에서 ``main`` 함수를 찾아보겠습니다. 먼저 바닥을 생성하고 ``loadBiped``를 "
"호출하여 SKEL 형식(로봇 모델을 표현하는 XML 포맷)으로 정의된 이족 보행 모델을 불러옵니다. SKEL "
"파일은 하나 이상의 ``Skeleton`` 을 포함한 ``World`` 를 묘사합니다. 여기서는 "
"[**biped.skel**](https://github.com/dartsim/dart/blob/release-5.1/data/skel/biped.skel) 에서 "
"World를 로드한 뒤 이족 보행 모델을 *biped* 라는 ``Skeleton`` 포인터에 할당합니다."

#: ../../tutorials/biped.md:34 254e5203e7cf4033bf58ed89114e4da1
msgid ""
"Running the skeleton code (hit the spacebar) without any modification, "
"you should see a human-like character collapse on the ground and fold in "
"on itself. Before we attempt to control the biped, let's first make the "
"biped a bit more realistic by enforcing more human-like joint limits."
msgstr ""
"코드를 수정하지 않고 스켈레톤을 실행(스페이스바)하면 인간형 캐릭터가 바닥에 쓰러지면서 몸이 "
"접히는 모습을 보게 됩니다. 이족 보행자를 제어하기 전에 좀 더 현실적인 인간 관절 제한을 적용해 "
"모델을 다듬겠습니다."

#: ../../tutorials/biped.md:39 ce577bfb2d8c4818853092dab940350b
msgid ""
"DART allows the user to set upper and lower bounds on each degree of "
"freedom in the SKEL file or using provided APIs. For example, you should "
"see the description of the right knee joint in **biped.skel**:"
msgstr ""
"DART에서는 SKEL 파일이나 제공된 API를 사용해 각 자유도에 상한과 하한을 설정할 수 있습니다. "
"예를 들어 **biped.skel** 에서 오른쪽 무릎 조인트 정의를 찾아보면:"

#: ../../tutorials/biped.md:56 c020e15a3ab84bae977d0b00f36cca16
msgid ""
"The &lt;upper> and &lt;lower> tags make sure that the knee can only flex "
"but not extend. Alternatively, you can directly specify the joint limits "
"in the code using ``setPositionUpperLimit`` and "
"``setPositionLowerLimit``."
msgstr ""
"`<upper>` 와 `<lower>` 태그는 무릎이 굽혀지기만 하고 펴지지 않도록 보장합니다. 또는 "
"``setPositionUpperLimit`` 와 ``setPositionLowerLimit`` 을 호출해 코드에서 직접 제한을 "
"설정할 수도 있습니다."

#: ../../tutorials/biped.md:61 c4b89e1939814dfeb118ce03197d2932
msgid ""
"In either case, the joint limits on the biped will not be activated until"
" you call ``setPositionLimited``:"
msgstr ""
"어느 방법이든 ``setPositionLimited`` 를 호출하기 전까지는 이족 보행자의 조인트 제한이 "
"적용되지 않습니다:"

#: ../../tutorials/biped.md:73 378acde01ff24aec80ee697e806826c9
msgid ""
"Once the joint limits are set, the next task is to enforce self-"
"collision. By default, DART does not check self-collision within a "
"skeleton. You can enable self-collision checking on the biped by"
msgstr ""
"조인트 제한을 설정한 다음에는 자충돌을 강제해야 합니다. 기본적으로 DART는 스켈레톤 내부의 자충돌을 "
"검사하지 않으므로, 다음 설정으로 이족 보행자에 대한 자충돌 검사를 활성화합니다:"

#: ../../tutorials/biped.md:84 65b0739d8c8544a09bee73f8c973da22
msgid ""
"This function will enable self-collision on every pair of body nodes. If "
"you wish to disable self-collisions on adjacent body nodes, call the "
"following function"
msgstr ""
"위 함수는 모든 바디 노드 쌍에 대해 자충돌을 활성화합니다. 인접한 바디 노드 간 충돌을 제외하고 "
"싶다면 다음 함수를 호출합니다."

#: ../../tutorials/biped.md:90 705ca38b9cff41e6adb931a709d9b90d
msgid ""
"Running the program again, you should see that the character is still "
"floppy like a ragdoll, but now the joints do not bend backward and the "
"body nodes do not penetrate each other anymore."
msgstr ""
"프로그램을 다시 실행하면 캐릭터가 여전히 인형처럼 부드럽게 움직이지만, 이제 조인트가 뒤로 꺾이지 "
"않고 바디 노드끼리 서로 관통하지 않습니다."

#: ../../tutorials/biped.md:94 37b6ccf8260c4e5b89ea19bbb824dba5
msgid "Lesson 2: Proportional-derivative control"
msgstr "Lesson 2: 비례-미분(PD) 제어"

#: ../../tutorials/biped.md:96 25ac503c810d40afa01fff2de3560660
msgid ""
"To actively control its own motion, the biped must exert internal forces "
"using actuators. In this Lesson, we will design one of the simplest "
"controllers to produce internal forces that make the biped hold a target "
"pose. The proportional-derivative (PD) control computes control force by "
"&Tau; = -k<sub>p</sub> (&theta; - &theta;<sub>target</sub>) - "
"k<sub>d</sub> &theta;&#775;, where &theta; and &theta;&#775; are the "
"current position and velocity of a degree of freedom, "
"&theta;<sub>target</sub> is the target position set by the controller, "
"and k<sub>p</sub> and k<sub>d</sub> are the stiffness and damping "
"coefficients. The detailed description of a PD controller can be found "
"[here](https://en.wikipedia.org/wiki/PID_controller)."
msgstr ""
"이족 보행자가 스스로 움직임을 제어하려면 액추에이터를 통해 내부 힘을 만들어야 합니다. 이번 "
"Lesson에서는 목표 자세를 유지하기 위해 내부 힘을 생성하는 가장 단순한 제어기 중 하나를 설계해 "
"보겠습니다. 비례-미분(PD) 제어는 &Tau; = -k<sub>p</sub> (&theta; - "
"&theta;<sub>target</sub>) - k<sub>d</sub> &theta;&#775; 공식을 사용해 제어력을 계산합니다. "
"&theta; 와 &theta;&#775; 는 특정 자유도의 현재 위치와 속도, &theta;<sub>target</sub> 은 "
"제어기가 지정한 목표 위치, k<sub>p</sub> 와 k<sub>d</sub> 는 강성 및 감쇠 계수입니다. PD "
"제어기에 대한 자세한 설명은 "
"[여기](https://en.wikipedia.org/wiki/PID_controller)에서 확인할 수 있습니다."

#: ../../tutorials/biped.md:108 c8a355775ee34b8884b8973bb9c8d430
msgid ""
"The first task is to set the biped to a particular configuration. You can"
" use ``setPosition`` to set each degree of freedom individually:"
msgstr ""
"첫 번째 작업은 이족 보행자를 특정 자세로 맞추는 것입니다. 각 자유도를 개별적으로 설정하려면 "
"``setPosition`` 을 사용할 수 있습니다:"

#: ../../tutorials/biped.md:119 40b4442448114189baf05d5fe6b6d060
msgid ""
"Here the degree of freedom named \"j_thigh_left_z\" is set to 0.15 "
"radian. Note that each degree of freedom in a skeleton has a numerical "
"index which can be accessed by ``getIndexInSkeleton``. You can also set "
"the entire configuration using a vector that holds the positions of all "
"the degreed of freedoms using ``setPositions``."
msgstr ""
"여기서는 \"j_thigh_left_z\" 자유도를 0.15 라디안으로 설정합니다. 스켈레톤의 각 자유도에는 "
"``getIndexInSkeleton`` 으로 접근할 수 있는 인덱스가 있다는 점에 유의하세요. "
"``setPositions`` 를 사용하면 모든 자유도의 위치를 담은 벡터로 전체 자세를 한 번에 지정할 수도 "
"있습니다."

#: ../../tutorials/biped.md:127 425b6b5ccfd34e60a936c9859582ba9f
msgid ""
"We continue to set more degrees of freedoms in the lower body to create a"
" roughly stable standing pose."
msgstr "이후 하반신의 자유도를 추가로 설정해 대략적인 안정 정지 자세를 구성합니다."

#: ../../tutorials/biped.md:139 6af51d20437a4e42a00d156aa76cbdde
msgid ""
"Now the biped will start in this configuration, but will not maintain "
"this configuration as soon as the simulation starts. We need a controller"
" to make this happen. Let's take a look at the constructor of our "
"``Controller`` in the skeleton code:"
msgstr ""
"이제 이 구성에서 시뮬레이션을 시작하지만, 시뮬레이션이 진행되면 자세가 금방 무너집니다. 이를 유지하려면 "
"제어기가 필요합니다. 스켈레톤 코드의 ``Controller`` 생성자를 살펴보면:"

#: ../../tutorials/biped.md:164 5d8cd6c96d1f40a98fddb43c1af77c01
msgid ""
"Here we arbitrarily define the stiffness and damping coefficients to 1000"
" and 50, except for the first six degrees of freedom. Because the global "
"translation and rotation of the biped are not actuated, the first six "
"degrees of freedom at the root do not exert any internal force. "
"Therefore, we set the stiffness and damping coefficients to zero. At the "
"end of the constructor, we set the target position of the PD controller "
"to the current configuration of the biped."
msgstr ""
"여기서는 첫 여섯 자유도를 제외하고 임의로 강성과 감쇠 계수를 각각 1000과 50으로 둡니다. 전체 "
"병진/회전 자유도는 액추에이터가 없으므로 루트의 처음 여섯 자유도는 내부 힘을 생성하지 않습니다. "
"따라서 해당 계수는 0으로 설정합니다. 생성자 마지막에서는 PD 제어기의 목표 자세를 현재 이족 보행자 "
"구성으로 초기화합니다."

#: ../../tutorials/biped.md:172 df3ecb0f41eb4a1a8fc30b36a0a5b3fe
msgid ""
"With these settings, we can compute the forces generated by the PD "
"controller and add them to the internal forces of biped using "
"``setForces``:"
msgstr ""
"이제 이 설정을 바탕으로 PD 제어기가 생성하는 힘을 계산해 ``setForces`` 를 통해 이족 보행자의 "
"내부 힘에 더할 수 있습니다:"

#: ../../tutorials/biped.md:188 d3752f2112ff49aebde7b0eba30d7c82
msgid ""
"Note that the PD control force is *added* to the current internal force "
"stored in mForces instead of overriding it."
msgstr "PD 제어력이 기존 mForces 값에 덮어쓰이지 않고 *추가* 된다는 점을 기억하세요."

#: ../../tutorials/biped.md:191 cb9e20250dbf4267a122c98a544bd230
msgid ""
"Now try to run the program and see what happens. The skeleton disappears "
"almost immediately as soon as you hit the space bar! This is because our "
"stiffness and damping coefficients are set way too high. As soon as the "
"biped deviates from the target position, huge internal forces are "
"generated to cause the numerical simulation to blow up."
msgstr ""
"프로그램을 다시 실행해 보면 스페이스바를 누르자마자 스켈레톤이 사라집니다! 강성과 감쇠 계수를 너무 "
"크게 설정했기 때문입니다. 목표 자세에서 조금만 벗어나도 엄청난 내부 힘이 발생해 수치 시뮬레이션이 "
"폭발적으로 발산하는 것입니다."

#: ../../tutorials/biped.md:198 6083f91adcdb415d8323a32c70b6bb79
msgid ""
"So let's lower those coefficients a bit. It turns out that each of the "
"degrees of freedom needs to be individually tuned depending on many "
"factors, such as the inertial properties of the body nodes, the type and "
"properties of joints, and the current configuration of the system. "
"Figuring out an appropriate set of coefficients can be a tedious process "
"difficult to generalize across new tasks or different skeletons. In the "
"next Lesson, we will introduce a much more efficient way to stabilize the"
" PD controllers without endless tuning and trial-and-errors."
msgstr ""
"따라서 계수를 조금 낮춰야 합니다. 각 자유도는 바디 노드의 관성, 조인트 형태와 특성, 현재 구성 등 "
"많은 요인에 따라 개별적으로 조정해야 합니다. 적절한 값을 찾는 과정은 새 작업이나 다른 스켈레톤에 "
"일반화하기 어렵고 번거롭습니다. 다음 Lesson에서는 끝없는 튜닝 없이 PD 제어기를 안정화하는 더 "
"효율적인 방법을 소개합니다."

#: ../../tutorials/biped.md:208 4bf3fb25ba0743f2a37995734727018a
msgid "Lesson 3: Stable PD control"
msgstr "Lesson 3: 안정적인 PD 제어"

#: ../../tutorials/biped.md:210 a16308dafd2046279a5758805320f21e
msgid ""
"SPD is a variation of PD control proposed by [Jie "
"Tan](http://www.cc.gatech.edu/~jtan34/project/spd.html). The basic idea "
"of SPD is to compute control force using the predicted state at the next "
"time step, instead of the current state. This Lesson will only "
"demonstrate the implementation of SPD using DART without going into "
"details of SPD derivation."
msgstr ""
"SPD(Stable PD)는 [Jie Tan](http://www.cc.gatech.edu/~jtan34/project/spd.html)이 "
"제안한 PD 제어 변형으로, 현재 상태 대신 다음 타임스텝에서 예측한 상태를 사용해 제어력을 "
"계산합니다. 이 Lesson에서는 SPD의 수학적 유도 대신 DART로 구현하는 방법을 보여줍니다."

#: ../../tutorials/biped.md:217 db157fbd54994361aad8286d64d04510
msgid ""
"The implementation of SPD involves accessing the current dynamic "
"quantities in Lagrange's equations of motion. Fortunately, these "
"quantities are readily available via DART API, which makes the full "
"implementation of SPD simple and concise:"
msgstr ""
"SPD를 구현하려면 라그랑주 운동방정식에 등장하는 동역학량에 접근해야 합니다. DART API가 이러한 "
"값을 제공하므로 구현이 간결해집니다:"

#: ../../tutorials/biped.md:238 d1e75a85366746a4a4152c6334c86372
msgid ""
"You can get mass matrix, Coriolis force, gravitational force, and "
"constraint force projected onto generalized coordinates using function "
"calls ``getMassMatrix``, ``getCoriolisForces``, ``getGravityForces``, and"
" ``getConstraintForces``, respectively. Constraint forces include forces "
"due to contacts, joint limits, and other joint constraints set by the "
"user (e.g. the weld joint constraint in the multi-pendulum tutorial)."
msgstr ""
"``getMassMatrix``, ``getCoriolisForces``, ``getGravityForces``, "
"``getConstraintForces`` 함수를 호출하면 각각 질량 행렬, 코리올리 힘, 중력, 일반화 좌표로 "
"사영된 제약 힘을 얻을 수 있습니다. 제약 힘에는 접촉, 조인트 제한, 사용자가 추가한 다른 "
"제약(예: multi-pendulum 튜토리얼의 용접 제약)이 포함됩니다."

#: ../../tutorials/biped.md:249 90e14cbdab8e4ef0ba9597d095af9c95
msgid ""
"With SPD, a wide range of stiffness and damping coefficients will all "
"result in stable motion. In fact, you can just leave them to our original"
" values: 1000 and 50. By holding the target pose, now the biped can stand"
" on the ground in balance indefinitely. However, if you apply an external"
" push force on the biped (hit ',' or '.' key to apply a backward or "
"forward push), the biped loses its balance quickly. We will demonstrate a"
" more robust feedback controller in the next Lesson."
msgstr ""
"SPD를 사용하면 폭넓은 강성·감쇠 계수 범위에서도 안정적인 움직임을 얻을 수 있으므로 기본값인 "
"1000/50을 그대로 사용해도 됩니다. 목표 자세를 유지하면 이족 보행자는 오랫동안 균형을 유지할 수 "
"있지만 ',' 또는 '.' 키로 외력을 가하면 금방 무너집니다. 다음 Lesson에서는 더 견고한 피드백 "
"제어기를 소개합니다."

#: ../../tutorials/biped.md:258 73235c167e224c9982ebd6035cb0cd68
msgid "Lesson 4: Ankle strategy"
msgstr "Lesson 4: 발목 전략"

#: ../../tutorials/biped.md:260 1a48c5e28cda43bf8d51ec099ad20e4b
msgid ""
"Ankle (or hip) strategy is an effective way to maintain standing balance."
" The idea is to adjust the target position of ankles according to the "
"deviation between the center of mass and the center of pressure projected"
" on the ground. A simple linear feedback rule is used to update the "
"target ankle position: &theta;<sub>a</sub> = -k<sub>p</sub> (x - p) - "
"k<sub>d</sub> (x&#775; - p&#775;), where x and p indicate the center of "
"mass and center of pressure in the anterior-posterior axis. k<sub>p</sub>"
" and k<sub>d</sub> are the feedback gains defined by the user."
msgstr ""
"발목(또는 고관절) 전략은 정지 균형을 유지하는 효과적인 방법입니다. 개념은 질량 중심과 바닥에 "
"투영된 압력 중심 간의 차이를 측정해 발목의 목표 위치를 조정하는 것입니다. 선형 피드백 규칙 "
"&theta;<sub>a</sub> = -k<sub>p</sub> (x - p) - k<sub>d</sub> (x&#775; - p&#775;)을 "
"사용하며, x와 p는 앞뒤 축에서의 질량 중심과 압력 중심을 의미하고 k<sub>p</sub>, k<sub>d</sub> "
"는 사용자가 정하는 피드백 이득입니다."

#: ../../tutorials/biped.md:270 fc6c094d7c2d434ea4795d7affc0d475
msgid ""
"To implement ankle strategy, let's first compute the deviation between "
"the center of mass and an approximated center of pressure in the "
"anterior-posterior axis:"
msgstr ""
"발목 전략을 적용하려면 먼저 앞뒤 축에서 질량 중심과 근사 압력 중심 사이의 편차를 계산합니다:"

#: ../../tutorials/biped.md:285 e268c84e5a774304b09ec76f18d03d14
msgid ""
"DART provides various APIs to access useful kinematic information. For "
"example, ``getCOM`` returns the center of mass of the skeleton and "
"``getTransform`` returns transformation of the body node with respect to "
"any coordinate frame specified by the parameter (world coordinate frame "
"as default). DART APIs also come in handy when computing the derivative "
"term,  -k<sub>d</sub> (x&#775; - p&#775;):"
msgstr ""
"DART는 유용한 운동학 정보를 얻기 위한 다양한 API를 제공합니다. 예를 들어 ``getCOM`` 은 "
"스켈레톤의 질량 중심을 반환하고 ``getTransform`` 은 기본적으로 월드 좌표계에 대한 BodyNode의 "
"변환을 돌려줍니다. 도함수 항  -k<sub>d</sub> (x&#775; - p&#775;) 를 계산할 때도 DART "
"API가 유용합니다:"

#: ../../tutorials/biped.md:303 5bf2fe8920a34f1aa8c449cf35a24886
msgid ""
"The linear/angular velocity/acceleration of any point in any coordinate "
"frame can be easily accessed in DART. The full list of the APIs for "
"accessing various velocities/accelerations can be found in the [API "
"Documentation](http://dartsim.github.io/dart/). The  following table "
"summarizes the essential APIs."
msgstr ""
"DART에서는 어떤 좌표계에서든任의 지점의 선형/각 속도·가속도를 쉽게 얻을 수 있습니다. 관련 API "
"전체 목록은 [API 문서](http://dartsim.github.io/dart/)에서 확인할 수 있으며, 아래 "
"표에는 핵심 API를 정리했습니다."

#: ../../tutorials/biped.md 548bb935c838469a8743489ab41fa7f6
#: 57b66f7869634a4a802e59b4b601c450 7602d2ca13704a50b6fa772052922080
msgid "Function Name"
msgstr "함수 이름"

#: ../../tutorials/biped.md 5eb089a7291f41829d88967b731828e3
#: 69f61a38e00e49a681f02ad0d9e730d9 a7d815505e1241db8a50e3640ab7f4d0
#: f8246d5e34f04affaf47bb2af66db58d
msgid "Description"
msgstr "설명"

#: ../../tutorials/biped.md f522f1e6c8cf46c19361a0f3be41e628
msgid "getSpatialVelocity"
msgstr "getSpatialVelocity"

#: ../../tutorials/biped.md 2362b91aeeeb4937a6a15dba74e0b703
msgid ""
"Return the spatial velocity of this BodyNode in the coordinates of the "
"BodyNode."
msgstr "이 BodyNode 좌표계에서의 공간 속도를 반환합니다."

#: ../../tutorials/biped.md 49f5a0b3e9e844ae9d8abe34169ade70
msgid "getLinearVelocity"
msgstr "getLinearVelocity"

#: ../../tutorials/biped.md 4fce3d6b4ca147969f3a44248f73ab66
msgid ""
"Return the linear portion of classical velocity of the BodyNode relative "
"to some other BodyNode."
msgstr "다른 BodyNode에 대한 고전적 속도의 선형 부분을 반환합니다."

#: ../../tutorials/biped.md 95267a85718e4acd9dafa6c170b64162
msgid "getAngularVelocity"
msgstr "getAngularVelocity"

#: ../../tutorials/biped.md 079c3453f8cf4d4b99b1b7dc9f99597e
msgid ""
"Return the angular portion of classical velocity of this BodyNode "
"relative to some other BodyNode."
msgstr "다른 BodyNode에 대한 고전적 속도의 각 부분을 반환합니다."

#: ../../tutorials/biped.md 4d065fb737de420e8cd23610331bf828
msgid "getSpatialAcceleration"
msgstr "getSpatialAcceleration"

#: ../../tutorials/biped.md f98d48fb9c5b4f62b3a88d836f0122d4
msgid ""
"Return the spatial acceleration of this BodyNode in the coordinates of "
"the BodyNode."
msgstr "해당 BodyNode 좌표계에서의 공간 가속도를 반환합니다."

#: ../../tutorials/biped.md f270b1bb0f36463984fb8fc0c998b7a1
msgid "getLinearAcceleration"
msgstr "getLinearAcceleration"

#: ../../tutorials/biped.md 46d3eab0e575406591ed5a41664ffd24
msgid ""
"Return the linear portion of classical acceleration of the BodyNode "
"relative to some other BodyNode."
msgstr "다른 BodyNode에 대한 고전적 가속도의 선형 부분을 반환합니다."

#: ../../tutorials/biped.md 120aa004c225432e9213f66d5f874023
msgid "getAngularAcceleration"
msgstr "getAngularAcceleration"

#: ../../tutorials/biped.md e6e0ae68c71e4f24b029750721402a90
msgid ""
"Return the angular portion of classical acceleration of this BodyNode "
"relative to some other BodyNode."
msgstr "다른 BodyNode에 대한 고전적 가속도의 각 부분을 반환합니다."

#: ../../tutorials/biped.md:317 d30820d61c594146ba404b589c230b58
msgid ""
"The remaining of the ankle strategy implementation is just the matter of "
"parameters tuning. We found that using different feedback rules for "
"falling forward and backward result in more stable controller."
msgstr ""
"발목 전략 구현의 나머지는 파라미터 조정 문제입니다. 전방/후방으로 넘어질 때 서로 다른 피드백 "
"규칙을 사용하면 제어기가 더 안정적이라는 점을 확인했습니다."

#: ../../tutorials/biped.md:321 9a38fb6d300e4a8bacec5c7c1af19c10
msgid "Lesson 5: Skeleton editing"
msgstr "Lesson 5: 스켈레톤 편집"

#: ../../tutorials/biped.md:323 c8b14a2434584fa7a0b337c3d9ecec0d
msgid ""
"DART provides various functions to copy, delete, split, and merge parts "
"of skeletons to alleviate the pain of building simulation models from "
"scratch. In this Lesson, we will load a skateboard model from a SKEL file"
" and merge our biped with the skateboard to create a wheel-based robot."
msgstr ""
"DART는 스켈레톤 일부를 복사·삭제·분할·병합하는 다양한 기능을 제공해 모델링 작업을 돕습니다. 이번 "
"Lesson에서는 SKEL 파일에서 스케이트보드 모델을 불러와 이족 보행자와 결합해 바퀴 기반 로봇을 "
"만듭니다."

#: ../../tutorials/biped.md:329 c71eb602feb240a392cf9fe3a5138f86
msgid "We first load a skateboard from **skateboard.skel**:"
msgstr "**skateboard.skel** 에서 스케이트보드를 불러옵니다:"

#: ../../tutorials/biped.md:340 2ff0daa6883d4ccaac4af067e71542f3
msgid ""
"Our goal is to make the skateboard Skeleton a subtree of the biped "
"Skeleton connected to the left heel BodyNode via a newly created Euler "
"joint. To do so, you need to first create an instance of "
"``EulerJoint::Properties`` for this new joint."
msgstr ""
"목표는 새 Euler 조인트를 통해 스케이트보드 스켈레톤을 이족 보행자 스켈레톤의 왼발 뒤꿈치 BodyNode "
"아래 서브트리로 만드는 것입니다. 이를 위해 먼저 ``EulerJoint::Properties`` 인스턴스를 "
"생성합니다."

#: ../../tutorials/biped.md:355 0d2e26134ca9473fb0689c371b5c4aec
msgid ""
"Here we increase the vertical distance between the child BodyNode and the"
" joint by 0.1m to give some space between the skateboard and the left "
"foot. Now you can merge the skateboard and the biped using this new Euler"
" joint by"
msgstr ""
"스케이트보드와 왼발 사이에 공간을 두기 위해 자식 BodyNode와 조인트 사이의 수직 거리를 0.1m "
"늘립니다. 그런 다음 아래 코드로 새 Euler 조인트를 이용해 스케이트보드와 이족 보행자를 병합할 수 "
"있습니다:"

#: ../../tutorials/biped.md:368 96f72a82f3e8442eba5687a9e37fb706
msgid ""
"There are many other functions you can use to edit skeletons. Here is a "
"table of some relevant functions for quick references."
msgstr ""
"스켈레톤 편집에 사용할 수 있는 다른 함수도 많습니다. 참고용으로 주요 함수를 표로 정리했습니다."

#: ../../tutorials/biped.md 8c8bd1f1b8b7440b9e80c1ec9dc5fd27
msgid "Example"
msgstr "예시"

#: ../../tutorials/biped.md d1e416dc653f42fdbfdf8cacb105749a
msgid "remove"
msgstr "remove"

#: ../../tutorials/biped.md a72bea0bca01482284ca7dfb25e76efc
msgid "bd1->remove()"
msgstr "bd1->remove()"

#: ../../tutorials/biped.md 65eb7c671e104790a39531d852cdae48
msgid "Remove the BodyNode bd1 and its subtree from their Skeleton."
msgstr "BodyNode bd1과 그 하위 트리를 스켈레톤에서 제거합니다."

#: ../../tutorials/biped.md 5b426894b39647d4a8707d8d59b891ee
msgid "moveTo"
msgstr "moveTo"

#: ../../tutorials/biped.md 334e5eea319c46209add7d67d78d433a
msgid "bd1->moveTo(bd2)"
msgstr "bd1->moveTo(bd2)"

#: ../../tutorials/biped.md 653862075091459599ea70aecf7594dd
msgid "Move the BodyNode bd1 and its subtree under the BodyNode bd2."
msgstr "BodyNode bd1과 그 하위 트리를 BodyNode bd2 아래로 이동합니다."

#: ../../tutorials/biped.md 79bc780ba1e943d1838c630767930a92
msgid "split"
msgstr "split"

#: ../../tutorials/biped.md a0f8c78ad74d4a4dbc6df8950da4dddf
msgid "auto newSkel = bd1->split(\"new skeleton\")`"
msgstr "auto newSkel = bd1->split(\"new skeleton\")`"

#: ../../tutorials/biped.md 7252d2e9833c429897db0299ef69cd89
msgid ""
"Remove the BodyNode bd1 and its subtree from their current Skeleton and "
"move them into a newly created Skeleton with \"new skeleton\" name."
msgstr ""
"BodyNode bd1과 그 하위 트리를 현재 스켈레톤에서 제거한 뒤 \"new skeleton\"이라는 이름의 새 "
"스켈레톤으로 옮깁니다."

#: ../../tutorials/biped.md 64b7a22c9a394275a4c675f96a89309f
msgid "changeParentJointType"
msgstr "changeParentJointType"

#: ../../tutorials/biped.md 3a2192ecd3ee46e9811294afa732a3e4
msgid "bd1->changeParentJointType&lt;BallJoint&gt;()"
msgstr "bd1->changeParentJointType&lt;BallJoint&gt;()"

#: ../../tutorials/biped.md aa8c1b18503c4a11ab7a6911be6dfdae
msgid "Change the Joint type of the BodyNode bd1's parent joint to BallJoint"
msgstr ""

#: ../../tutorials/biped.md 8c18f17e3af84dc4a0eee67b9ef406d5
msgid "copyTo"
msgstr ""

#: ../../tutorials/biped.md 77fac733ba51427ca5a8a61c8903186d
msgid "bd1->copyTo(bd2)"
msgstr ""

#: ../../tutorials/biped.md 876ffed30a2d41fdb6e8bd605d8ab3a3
msgid ""
"Create clones of the BodyNode bd1 and its subtree and attach the clones "
"to the specified the BodyNode bd2."
msgstr ""

#: ../../tutorials/biped.md e109798286bf4716a0bb0c1f7c56577f
msgid "copyAs"
msgstr ""

#: ../../tutorials/biped.md 36b53cf39eb34273b874bdc655101f24
msgid "auto newSkel = bd1->copyAs(\"new skeleton\")"
msgstr ""

#: ../../tutorials/biped.md 83e432b495ed4b278baf9ca8f83b8ab5
msgid ""
"Create clones of the BodyNode bd1 and its subtree and create a new "
"Skeleton with \"new skeleton\" name to attach them to."
msgstr ""

#: ../../tutorials/biped.md:381 7503f4997cca4c05a1fd70622ca2b160
msgid "Lesson 6: Actuator types"
msgstr ""

#: ../../tutorials/biped.md:383 81d56146c1304e3190d95fd2d7d3725f
msgid ""
"DART provides five types of actuator. Each joint can select its own "
"actuator type."
msgstr ""

#: ../../tutorials/biped.md d4563fe20c894990852a8a4612b0cba4
msgid "Type"
msgstr ""

#: ../../tutorials/biped.md fc7a3d5c75654c7898d5a9cc6e3d1c79
msgid "FORCE"
msgstr ""

#: ../../tutorials/biped.md 03918077e7b0426cbaa1a5bd0aaf50e4
msgid "Take joint force and return the resulting joint acceleration."
msgstr ""

#: ../../tutorials/biped.md eeadc62c9aae4df79b8f520396ebb1f1
msgid "PASSIVE"
msgstr ""

#: ../../tutorials/biped.md fc2acb70203841b2b2fb09500a7b2829
msgid ""
"Take nothing (joint force = 0) and return the resulting joint "
"acceleration."
msgstr ""

#: ../../tutorials/biped.md 61d41d5ad03f4f3399f372a5fd1840df
msgid "ACCELERATION"
msgstr ""

#: ../../tutorials/biped.md 708fcd28e6614a018a66c12dc9d08c42
msgid ""
"Take desired joint acceleration and return the joint force to achieve the"
" acceleration."
msgstr "목표 가속도를 입력받아 해당 가속도를 만들 힘을 반환합니다."

#: ../../tutorials/biped.md 473259fa7eb54e43b7e499b19e1ab437
msgid "VELOCITY"
msgstr "VELOCITY"

#: ../../tutorials/biped.md 8f02dfc185ad4cfabd0a9ff8ce7b18a9
msgid ""
"Take desired joint velocity and return the joint force to achieve the "
"velocity."
msgstr "목표 속도를 입력받아 그 속도를 내기 위한 힘을 반환합니다."

#: ../../tutorials/biped.md 51f618bfb5df4920a07b41c09e04d5e1
msgid "LOCKED"
msgstr "LOCKED"

#: ../../tutorials/biped.md 055670a6b46f45c0aee3bd61f30c3e95
msgid ""
"Lock the joint by setting the joint velocity and acceleration to zero and"
" return the joint force to lock the joint."
msgstr "속도와 가속도를 0으로 만들고 조인트를 잠그기 위한 힘을 반환합니다."

#: ../../tutorials/biped.md:394 6374500ce0f9452fb38de4d54aab2d59
msgid ""
"In this Lesson, we will switch the actuator type of the wheels from the "
"default FORCE type to VELOCITY type."
msgstr ""
"이번 Lesson에서는 바퀴 액추에이터를 기본 FORCE 유형에서 VELOCITY 유형으로 변경합니다."

#: ../../tutorials/biped.md:406 208d9a9f092648218c5af9ba92d63c87
msgid ""
"Once all four wheels are set to VELOCITY actuator type, you can command "
"them by directly setting the desired velocity:"
msgstr ""
"네 개 바퀴를 모두 VELOCITY 유형으로 바꾸면 원하는 속도를 직접 지정해 제어할 수 있습니다:"

#: ../../tutorials/biped.md:419 2445adcb17894359a5c12730d3bac6b8
msgid ""
"Note that ``setCommand`` only exerts commanding force in the current time"
" step. If you wish the wheel to continue spinning at a particular speed, "
"``setCommand`` needs to be called at every time step."
msgstr ""
"``setCommand`` 는 현재 타임스텝에서만 제어력을 적용합니다. 특정 속도로 계속 회전시키려면 매 "
"타임스텝마다 ``setCommand`` 를 호출해야 합니다."

#: ../../tutorials/biped.md:423 f041c60d1a6b4e44aa0f21bf6d638df2
msgid "We also set the stiffness and damping coefficients for the wheels to zero."
msgstr "바퀴의 강성과 감쇠 계수도 0으로 설정합니다."

#: ../../tutorials/biped.md:438 f4da6665ca9c4bb8bbcd5443b14e19ed
msgid ""
"This is because we do not want the velocity-based actuators to "
"incorrectly affect the computation of SPD. If we use simple PD control "
"scheme, the values of these spring and damping coefficients do not affect"
" the dynamics of the system."
msgstr ""
"이는 속도 기반 액추에이터가 SPD 계산에 영향을 주지 않도록 하기 위함입니다. 단순 PD 제어를 "
"사용하더라도 이 스프링·감쇠 계수 값은 시스템 동역학에 영향을 주지 않습니다."

#: ../../tutorials/biped.md:443 cadaaf17c881406a96a21dff3ff72055
msgid ""
"Let's simulate what we've got so far. The biped now is connecting to the "
"skateboard through a Euler joint. Once the simulation starts, you can use"
" 'a' and 's' to increase or decrease the wheel speed. However, the biped "
"falls on the floor immediately because the current target pose is not "
"balanced for one-foot stance. We need to find a better target pose."
msgstr ""
"지금까지 구성한 상태로 시뮬레이션을 돌립니다. 이족 보행자는 Euler 조인트를 통해 스케이트보드와 "
"연결되어 있고, 시뮬레이션 도중 'a'와 's' 키로 바퀴 속도를 조절할 수 있습니다. 다만 현재 목표 "
"자세가 한 발 지지에 적합하지 않아 곧바로 넘어지므로 더 나은 목표 자세가 필요합니다."

#: ../../tutorials/biped.md:450 6e36388cbfa4462599c97947ce81a6e1
msgid "Lesson 7: Inverse kinematics"
msgstr "Lesson 7: 역기구학"

#: ../../tutorials/biped.md:452 65816804bde44e21b58c138ac7d94cd6
msgid ""
"Instead of manually designing a target pose, this time we will solve for "
"a balanced pose by formulating an inverse kinematics (IK) problem and "
"solving it using gradient descent method. In this example, a balanced "
"pose is defined as a pose where the center of mass is well supported by "
"the ground contact and the left foot lies flat on the ground. As such, we"
" cast IK as an optimization problem that minimizes the horizontal "
"deviation between the center of mass and the center of the left foot, as "
"well as the vertical distance of the four corners of the left foot from "
"the ground:"
msgstr ""
"이번에는 목표 자세를 직접 설계하는 대신 역기구학(IK) 문제를 구성해 기울기 하강법으로 균형 자세를 "
"구합니다. 균형 자세란 질량 중심이 지면 접촉으로 잘 지지되고 왼발이 평평하게 놓인 상태로 정의합니다. "
"이에 따라 질량 중심과 왼발 중심 간 수평 편차와 왼발 네 모서리의 지면과의 높이를 최소화하는 "
"최적화 문제로 IK를 정식화합니다:"

#: ../../tutorials/biped.md:464 201581bea3ba437f8bcf38d6b0655b3e
msgid ""
"where <b>c</b> and <b>p</b> indicate the projected center of mass and "
"center of pressure on the ground, and *p<sub>i</sub>* indicates the "
"vertical height of one corner of the left foot."
msgstr ""
"여기서 <b>c</b> 와 <b>p</b> 는 지면에 투영한 질량 중심과 압력 중심, *p<sub>i</sub>* 는 왼발 "
"각 모서리의 높이를 의미합니다."

#: ../../tutorials/biped.md:468 2aa27b9af1e342119bb95ed419198166
msgid ""
"To compute the gradient of the above objective function, we need to "
"evaluate the partial derivatives of each objective term with respect to "
"the degrees of freedom, i.e., the computation of Jacobian matrix. DART "
"provides a comprensive set of APIs for accessing various types of "
"Jacobian. In this example, computing the gradient of the first term of "
"the objective function requires the Jacobian of the center of mass of the"
" Skeleton, as well as the Jacobian of the center of mass of a BodyNode:"
msgstr ""
"이 목표 함수의 그래디언트를 계산하려면 각 항을 자유도에 대해 편미분해야 하므로 자코비안을 구해야 "
"합니다. DART는 다양한 자코비안에 접근하는 API를 제공합니다. 예를 들어 첫 번째 항의 그래디언트는 "
"스켈레톤 질량 중심 자코비안과 특정 BodyNode 질량 중심 자코비안을 필요로 합니다:"

#: ../../tutorials/biped.md:487 cbca4adc041a472a9c712e4f24961b76
msgid ""
"``getCOMLinearJacobian`` returns the linear Jacobian of the center of "
"mass of the Skeleton, while ``getLinearJacobian`` returns the Jacobian of"
" a point on a BodyNode. The BodyNode and the local coordinate of the "
"point are specified as parameters to this function. Here the point of "
"interest is the center of mass of the left foot, which local coordinates "
"can be accessed by ``getCOM`` with a parameter indicating the left foot "
"being the frame of reference. We use ``getLinearJacobian`` again to "
"compute the gradient of the second term of the objective function:"
msgstr ""
"``getCOMLinearJacobian`` 은 스켈레톤 질량 중심의 선형 자코비안을, ``getLinearJacobian`` "
"은 BodyNode 상의 특정 점 자코비안을 반환합니다. BodyNode와 해당 점의 로컬 좌표는 함수 "
"인자로 넘기며, 여기서는 왼발을 기준으로 ``getCOM`` 을 호출해 질량 중심 좌표를 얻습니다. 두 번째 "
"항의 그래디언트 역시 ``getLinearJacobian`` 으로 계산합니다:"

#: ../../tutorials/biped.md:507 09721d55cc6349a9a82d914539a15c3d
msgid ""
"The full list of Jacobian APIs can be found in the [API "
"Documentation](http://dartsim.github.io/dart/). The  following table "
"summarizes the essential APIs."
msgstr ""
"자코비안 관련 API 전체 목록은 [API 문서](http://dartsim.github.io/dart/)에서 확인할 수 있으며 "
"아래 표는 핵심 API를 정리한 것입니다."

#: ../../tutorials/biped.md f45e0b34d46b45268eaa90c6e4f6a3ee
msgid "getJacobian"
msgstr "getJacobian"

#: ../../tutorials/biped.md 04ea7d7e1fc04cbda2c48a1f1d4f1e04
msgid ""
"Return the generalized Jacobian targeting the origin of the BodyNode. The"
" Jacobian is expressed in the Frame of this BodyNode."
msgstr "BodyNode 원점을 대상으로 하는 일반화 자코비안을 BodyNode 좌표계로 반환합니다."

#: ../../tutorials/biped.md bbba6b312c51446797455e1090419649
msgid "getLinearJacobian"
msgstr "getLinearJacobian"

#: ../../tutorials/biped.md 9676006c0d784727a4b78ea788ce0f80
msgid ""
"Return the linear Jacobian targeting the origin of the BodyNode. You can "
"specify a coordinate Frame to express the Jacobian in."
msgstr "BodyNode 원점의 선형 자코비안을 반환하며 표현 좌표계를 지정할 수 있습니다."

#: ../../tutorials/biped.md 50f168ccafbf4ee5ba964967f5493cc6
msgid "getAngularJacobian"
msgstr "getAngularJacobian"

#: ../../tutorials/biped.md 6fa27b523fc64728944d265792b49e0b
msgid ""
"Return the angular Jacobian targeting the origin of the BodyNode. You can"
" specify a coordinate Frame to express the Jacobian in."
msgstr "BodyNode 원점의 각 자코비안을 반환하며 표현 좌표계를 지정할 수 있습니다."

#: ../../tutorials/biped.md 2a6eb530fcae495bb8e28bb0c073caf8
msgid "getJacobianSpatialDeriv"
msgstr "getJacobianSpatialDeriv"

#: ../../tutorials/biped.md b8ac1341aa4a431f821f88641a19dd24
msgid ""
"Return the spatial time derivative of the generalized Jacobian targeting "
"the origin of the BodyNode. The Jacobian is expressed in the BodyNode's "
"coordinate Frame."
msgstr "BodyNode 원점의 일반화 자코비안에 대한 공간 도함수를 BodyNode 좌표계로 반환합니다."

#: ../../tutorials/biped.md ed005bef00fc4f3490359db1d7c5b1fb
msgid "getJacobianClassicDeriv"
msgstr "getJacobianClassicDeriv"

#: ../../tutorials/biped.md fd26f38f30d54ef8a8ad671954955776
msgid ""
"Return the classical time derivative of the generalized Jacobian "
"targeting the origin of the BodyNode. The Jacobian is expressed in the "
"World coordinate Frame."
msgstr "BodyNode 원점의 일반화 자코비안을 월드 좌표계에서 고전적으로 미분한 값을 반환합니다."

#: ../../tutorials/biped.md 38ea7ea0cb274b8ab589b0cb03caf03f
msgid "getLinearJacobianDeriv"
msgstr "getLinearJacobianDeriv"

#: ../../tutorials/biped.md 7f9a93efdf284bdd94ab3f80500249bb
msgid ""
"Return the linear Jacobian (classical) time derivative, in terms of any "
"coordinate Frame."
msgstr "선형 자코비안의 고전적 시간 미분을 원하는 좌표계로 반환합니다."

#: ../../tutorials/biped.md 345f2fba8c754695a9beb3f2998b4983
msgid "getAngularJacobianDeriv"
msgstr "getAngularJacobianDeriv"

#: ../../tutorials/biped.md 18fbc34cb89543259ca0119ff666f803
msgid ""
"Return the angular Jacobian (classical) time derivative, in terms of any "
"coordinate Frame."
msgstr "각 자코비안의 고전적 시간 미분을 원하는 좌표계로 반환합니다."

#: ../../tutorials/biped.md:520 99cb2ec7d9654c9d84de259d5ffc06a9
msgid ""
"This Lesson concludes the entire Biped tutorial. You should see a biped "
"standing stably on the skateboard. With moderate "
"acceleration/deceleration on the skateboard, the biped is able to "
"maintain balance and hold the one-foot stance pose."
msgstr ""
"이 Lesson을 끝으로 이족 보행 튜토리얼을 마칩니다. 이족 보행자는 스케이트보드 위에서 안정적으로 서 "
"있어야 하며, 적당한 가감속이 가해져도 한 발 지지 자세를 유지할 수 있어야 합니다."
