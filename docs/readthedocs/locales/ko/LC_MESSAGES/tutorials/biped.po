# SOME DESCRIPTIVE TITLE.
# Copyright (C) Copyright (c) 2011, The DART development contributors
# This file is distributed under the same license as the DART: Dynamic
# Animation and Robotics Toolkit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: DART: Dynamic Animation and Robotics Toolkit "
"7.0.0-alpha0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-17 09:47-0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ko\n"
"Language-Team: ko <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../tutorials/biped.md:1 e52288222f1346189b37e5e8fce83e8b
msgid "Biped"
msgstr "이족 보행"

#: ../../tutorials/biped.md:3 397be14837344809aeb3b6ecbf4d80eb
msgid "Overview"
msgstr "개요"

#: ../../tutorials/biped.md:4 4ebe840a553c41b39ab9758aed12985c
msgid ""
"This tutorial demonstrates the dynamic features in DART useful for "
"developing controllers for bipedal or wheel-based robots. The tutorial "
"consists of seven Lessons covering the following topics:"
msgstr ""
"이 튜토리얼은 이족 보행 혹은 바퀴 기반 로봇의 제어기를 개발할 때 유용한 DART의 동역학 기능을 소개합니다. 총 일곱 개 "
"Lesson으로 구성되어 있으며 다음 주제를 다룹니다:"

#: ../../tutorials/biped.md:8 643cbbdba7f24562aec5805edccd12ee
msgid "Joint limits and self-collision."
msgstr "조인트 제한과 자충돌"

#: ../../tutorials/biped.md:9 641074a72093407ea79726b60d9b1866
msgid "Actuators types and management."
msgstr "액추에이터 유형과 관리"

#: ../../tutorials/biped.md:10 8c04791c2f38428eafda37e50959f279
msgid "APIs for Jacobian matrices and other kinematic quantities."
msgstr "자코비안 및 기타 운동학량 API"

#: ../../tutorials/biped.md:11 655059760b0a431383c80230fb060d3b
msgid "APIs for dynamic quantities."
msgstr "동역학량 API"

#: ../../tutorials/biped.md:12 1e026d68991b46e4b936cf967144ca70
msgid "Skeleton editing."
msgstr "스켈레톤 편집"

#: ../../tutorials/biped.md:14 e554c46c3cfc4282b81dca46b3d21475
msgid ""
"Please reference the source code in "
"[**tutorial_biped/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_biped/main.cpp),"
" "
"[**tutorial_biped_finished/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_biped_finished/main.cpp),"
" and the dartpy variant "
"[**python/tutorials/04_biped/main_finished.py**](https://github.com/dartsim/dart/blob/main/python/tutorials/04_biped/main_finished.py)."
msgstr ""
"자세한 구현은 "
"[**tutorial_biped/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_biped/main.cpp)"
" 와 "
"[**tutorial_biped_finished/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_biped_finished/main.cpp),"
" 그리고 dartpy 버전인 "
"[**python/tutorials/04_biped/main_finished.py**](https://github.com/dartsim/dart/blob/main/python/tutorials/04_biped/main_finished.py)"
" 를 참고하세요."

#: ../../tutorials/biped.md:16 3af58d0047184abea903e556b56b0783
msgid "Lesson 1: Joint limits and self-collision"
msgstr "Lesson 1: 조인트 제한과 자충돌"

#: ../../tutorials/biped.md:17 da9a3233959b495f9a98846ad17b0591
msgid ""
"Let's start by locating the ``main`` function in "
"tutorials/tutorial_biped/main.cpp. We first create a floor and call "
"``loadBiped`` to load a bipedal figure described in SKEL format, which is"
" an XML format representing a robot model. A SKEL file describes a "
"``World`` with one or more ``Skeleton``s in it. Here we load in a World "
"from "
"[**biped.skel**](https://github.com/dartsim/dart/blob/main/data/skel/biped.skel)"
" and assign the bipedal figure to a ``Skeleton`` pointer called *biped*."
msgstr ""
"tutorials/tutorial_biped/main.cpp에서 ``main`` 함수를 찾아보겠습니다. 먼저 바닥을 생성하고 "
"``loadBiped``를 호출하여 SKEL 형식(로봇 모델을 표현하는 XML 포맷)으로 정의된 이족 보행 모델을 불러옵니다. "
"SKEL 파일은 하나 이상의 ``Skeleton`` 을 포함한 ``World`` 를 묘사합니다. 여기서는 "
"[**biped.skel**](https://github.com/dartsim/dart/blob/main/data/skel/biped.skel)"
" 에서 World를 로드한 뒤 이족 보행 모델을 *biped* 라는 ``Skeleton`` 포인터에 할당합니다."

#: ../../tutorials/biped.md:27 ../../tutorials/biped.md:75
#: ../../tutorials/biped.md:95 ../../tutorials/biped.md:139
#: ../../tutorials/biped.md:181 ../../tutorials/biped.md:210
#: ../../tutorials/biped.md:261 ../../tutorials/biped.md:315
#: ../../tutorials/biped.md:340 ../../tutorials/biped.md:386
#: ../../tutorials/biped.md:450 ../../tutorials/biped.md:471
#: ../../tutorials/biped.md:547 08ebc8338a3848c1b7e6b1c7f59f2723
#: 22d55ce29f864d5686478f3e89bdf56a 2e289594fa77449091fe4b7fa459eb6d
#: 43734cdec3644575b32afb48e55a5111 583c8cd80b6c4482a847b501fcfcae22
#: 7fb9860575e044449867a4d93e604a10 88b117609bad41a29143efb5a6ce1469
#: 940fe8d0eea64975abe58f12a02787ba 946789a762be4908841af259b490f36e
#: abb62f1e3613478b9f7c1b5d111ab0ad bbe99700ad5542a4a894a53943a319f3
#: c8ebe87013874919a1532b75bff0f2a5 d9ec3766a456482e878eb94eaef2d1f5
msgid "C++"
msgstr "C++"

#: ../../tutorials/biped.md:34 ../../tutorials/biped.md:82
#: ../../tutorials/biped.md:102 ../../tutorials/biped.md:146
#: ../../tutorials/biped.md:188 ../../tutorials/biped.md:217
#: ../../tutorials/biped.md:268 ../../tutorials/biped.md:322
#: ../../tutorials/biped.md:347 ../../tutorials/biped.md:393
#: ../../tutorials/biped.md:457 ../../tutorials/biped.md:478
#: ../../tutorials/biped.md:554 64918eb6571c4b8998f020090247f495
#: 74e2ac35f1e44f49a9b8a727d961995f 756d1eb23779413fbe018d3637e6d295
#: 7ded49544b4b486299a4cfe09fef8945 879f3bfd76a54bce8983189edead7839
#: 8f846fa13fab4d2999c24d1060d8b7bd 972318f5c5b846b486761552293dc8d9
#: c3079f368116468eb86071c1075e9b2f c6b342928f954cc499ede0fc55e285f8
#: cb8a5a25bebb4d8ab34a85734adde1ca e40aa383033b4201aaa9a82430a686f6
#: e90d2c0f6464416b95638f6d9e130f49 fc0249d7f0a34d24ac73ffbf64b9f4d2
msgid "Python"
msgstr "파이썬"

#: ../../tutorials/biped.md:42 31efa6ca6a1849469dbbb840c740e0f8
msgid ""
"Running the skeleton code (hit the spacebar) without any modification, "
"you should see a human-like character collapse on the ground and fold in "
"on itself. Before we attempt to control the biped, let's first make the "
"biped a bit more realistic by enforcing more human-like joint limits."
msgstr ""
"코드를 수정하지 않고 스켈레톤을 실행(스페이스바)하면 인간형 캐릭터가 바닥에 쓰러지면서 몸이 접히는 모습을 보게 됩니다. 이족 "
"보행자를 제어하기 전에 좀 더 현실적인 인간 관절 제한을 적용해 모델을 다듬겠습니다."

#: ../../tutorials/biped.md:47 d1b49a57df284131b2c64326779be8e0
msgid ""
"DART allows the user to set upper and lower bounds on each degree of "
"freedom in the SKEL file or using provided APIs. For example, you should "
"see the description of the right knee joint in **biped.skel**:"
msgstr ""
"DART에서는 SKEL 파일이나 제공된 API를 사용해 각 자유도에 상한과 하한을 설정할 수 있습니다. 예를 들어 "
"**biped.skel** 에서 오른쪽 무릎 조인트 정의를 찾아보면:"

#: ../../tutorials/biped.md:64 aec8911a060d485389ec034b34213e4d
msgid ""
"The &lt;upper> and &lt;lower> tags make sure that the knee can only flex "
"but not extend. Alternatively, you can directly specify the joint limits "
"in the code using ``setPositionUpperLimit`` and "
"``setPositionLowerLimit``."
msgstr ""
"`<upper>` 와 `<lower>` 태그는 무릎이 굽혀지기만 하고 펴지지 않도록 보장합니다. 또는 "
"``setPositionUpperLimit`` 와 ``setPositionLowerLimit`` 을 호출해 코드에서 직접 제한을 "
"설정할 수도 있습니다."

#: ../../tutorials/biped.md:69 bf490913496c415794156e5a25dfbf48
msgid ""
"In either case, the joint limits on the biped will not be activated until"
" you call ``setPositionLimited``:"
msgstr "어느 방법이든 ``setPositionLimited`` 를 호출하기 전까지는 이족 보행자의 조인트 제한이 적용되지 않습니다:"

#: ../../tutorials/biped.md:89 f40f79ed420f419e9256110759648a6c
msgid ""
"Once the joint limits are set, the next task is to enforce self-"
"collision. By default, DART does not check self-collision within a "
"skeleton. You can enable self-collision checking on the biped by"
msgstr ""
"조인트 제한을 설정한 다음에는 자충돌을 강제해야 합니다. 기본적으로 DART는 스켈레톤 내부의 자충돌을 검사하지 않으므로, 다음 "
"설정으로 이족 보행자에 대한 자충돌 검사를 활성화합니다:"

#: ../../tutorials/biped.md:109 66df5c1c1c0940dea3c8b202630a03be
msgid ""
"This function will enable self-collision on every pair of body nodes. If "
"you wish to disable self-collisions on adjacent body nodes, call the "
"following function"
msgstr "위 함수는 모든 바디 노드 쌍에 대해 자충돌을 활성화합니다. 인접한 바디 노드 간 충돌을 제외하고 싶다면 다음 함수를 호출합니다."

#: ../../tutorials/biped.md:115 6e803fd9ff3b49048fa7597c36a24957
msgid ""
"Running the program again, you should see that the character is still "
"floppy like a ragdoll, but now the joints do not bend backward and the "
"body nodes do not penetrate each other anymore."
msgstr ""
"프로그램을 다시 실행하면 캐릭터가 여전히 인형처럼 부드럽게 움직이지만, 이제 조인트가 뒤로 꺾이지 않고 바디 노드끼리 서로 관통하지"
" 않습니다."

#: ../../tutorials/biped.md:119 5fccc56c2da342a1a6fcd94ea788286b
msgid "Lesson 2: Proportional-derivative control"
msgstr "Lesson 2: 비례-미분(PD) 제어"

#: ../../tutorials/biped.md:121 d72b3f0906b04808aaf6ec858cf36a0c
msgid ""
"To actively control its own motion, the biped must exert internal forces "
"using actuators. In this Lesson, we will design one of the simplest "
"controllers to produce internal forces that make the biped hold a target "
"pose. The proportional-derivative (PD) control computes control force by "
"&Tau; = -k<sub>p</sub> (&theta; - &theta;<sub>target</sub>) - "
"k<sub>d</sub> &theta;&#775;, where &theta; and &theta;&#775; are the "
"current position and velocity of a degree of freedom, "
"&theta;<sub>target</sub> is the target position set by the controller, "
"and k<sub>p</sub> and k<sub>d</sub> are the stiffness and damping "
"coefficients. The detailed description of a PD controller can be found "
"[here](https://en.wikipedia.org/wiki/PID_controller)."
msgstr ""
"이족 보행자가 스스로 움직임을 제어하려면 액추에이터를 통해 내부 힘을 만들어야 합니다. 이번 Lesson에서는 목표 자세를 유지하기"
" 위해 내부 힘을 생성하는 가장 단순한 제어기 중 하나를 설계해 보겠습니다. 비례-미분(PD) 제어는 &Tau; = "
"-k<sub>p</sub> (&theta; - &theta;<sub>target</sub>) - k<sub>d</sub> "
"&theta;&#775; 공식을 사용해 제어력을 계산합니다. &theta; 와 &theta;&#775; 는 특정 자유도의 현재 "
"위치와 속도, &theta;<sub>target</sub> 은 제어기가 지정한 목표 위치, k<sub>p</sub> 와 "
"k<sub>d</sub> 는 강성 및 감쇠 계수입니다. PD 제어기에 대한 자세한 설명은 "
"[여기](https://en.wikipedia.org/wiki/PID_controller)에서 확인할 수 있습니다."

#: ../../tutorials/biped.md:133 7370d2fd54424cdf8cdec48202a80e74
msgid ""
"The first task is to set the biped to a particular configuration. You can"
" use ``setPosition`` to set each degree of freedom individually:"
msgstr ""
"첫 번째 작업은 이족 보행자를 특정 자세로 맞추는 것입니다. 각 자유도를 개별적으로 설정하려면 ``setPosition`` 을 "
"사용할 수 있습니다:"

#: ../../tutorials/biped.md:153 23f87eca415e4cb0883557290d791dee
msgid ""
"Here the degree of freedom named \"j_thigh_left_z\" is set to 0.15 "
"radian. Note that each degree of freedom in a skeleton has a numerical "
"index which can be accessed by ``getIndexInSkeleton``. You can also set "
"the entire configuration using a vector that holds the positions of all "
"the degreed of freedoms using ``setPositions``."
msgstr ""
"여기서는 \"j_thigh_left_z\" 자유도를 0.15 라디안으로 설정합니다. 스켈레톤의 각 자유도에는 "
"``getIndexInSkeleton`` 으로 접근할 수 있는 인덱스가 있다는 점에 유의하세요. ``setPositions`` 를 "
"사용하면 모든 자유도의 위치를 담은 벡터로 전체 자세를 한 번에 지정할 수도 있습니다."

#: ../../tutorials/biped.md:161 1b68289e958b410a88280d37582f0ab9
msgid ""
"We continue to set more degrees of freedoms in the lower body to create a"
" roughly stable standing pose."
msgstr "이후 하반신의 자유도를 추가로 설정해 대략적인 안정 정지 자세를 구성합니다."

#: ../../tutorials/biped.md:173 5d21a69d60e649969b7d758f60fea522
msgid ""
"Now the biped will start in this configuration, but will not maintain "
"this configuration as soon as the simulation starts. We need a controller"
" to make this happen. Let's take a look at the constructor of our "
"``Controller`` in the skeleton code:"
msgstr ""
"이제 이 구성에서 시뮬레이션을 시작하지만, 시뮬레이션이 진행되면 자세가 금방 무너집니다. 이를 유지하려면 제어기가 필요합니다. "
"스켈레톤 코드의 ``Controller`` 생성자를 살펴보면:"

#: ../../tutorials/biped.md:196 54d9a590f9d04a2cb479acb779945f96
msgid ""
"Here we arbitrarily define the stiffness and damping coefficients to 1000"
" and 50, except for the first six degrees of freedom. Because the global "
"translation and rotation of the biped are not actuated, the first six "
"degrees of freedom at the root do not exert any internal force. "
"Therefore, we set the stiffness and damping coefficients to zero. At the "
"end of the constructor, we set the target position of the PD controller "
"to the current configuration of the biped."
msgstr ""
"여기서는 첫 여섯 자유도를 제외하고 임의로 강성과 감쇠 계수를 각각 1000과 50으로 둡니다. 전체 병진/회전 자유도는 "
"액추에이터가 없으므로 루트의 처음 여섯 자유도는 내부 힘을 생성하지 않습니다. 따라서 해당 계수는 0으로 설정합니다. 생성자 "
"마지막에서는 PD 제어기의 목표 자세를 현재 이족 보행자 구성으로 초기화합니다."

#: ../../tutorials/biped.md:204 2edb8d2555aa47009ad145367a125b90
msgid ""
"With these settings, we can compute the forces generated by the PD "
"controller and add them to the internal forces of biped using "
"``setForces``:"
msgstr ""
"이제 이 설정을 바탕으로 PD 제어기가 생성하는 힘을 계산해 ``setForces`` 를 통해 이족 보행자의 내부 힘에 더할 수 "
"있습니다:"

#: ../../tutorials/biped.md:224 69f7c68724374fecaaa41801b1d888af
msgid ""
"Note that the PD control force is *added* to the current internal force "
"stored in mForces instead of overriding it."
msgstr "PD 제어력이 기존 mForces 값에 덮어쓰이지 않고 *추가* 된다는 점을 기억하세요."

#: ../../tutorials/biped.md:227 c72a6c273f4f456580b470099d5aff15
msgid ""
"Now try to run the program and see what happens. The skeleton disappears "
"almost immediately as soon as you hit the space bar! This is because our "
"stiffness and damping coefficients are set way too high. As soon as the "
"biped deviates from the target position, huge internal forces are "
"generated to cause the numerical simulation to blow up."
msgstr ""
"프로그램을 다시 실행해 보면 스페이스바를 누르자마자 스켈레톤이 사라집니다! 강성과 감쇠 계수를 너무 크게 설정했기 때문입니다. 목표"
" 자세에서 조금만 벗어나도 엄청난 내부 힘이 발생해 수치 시뮬레이션이 폭발적으로 발산하는 것입니다."

#: ../../tutorials/biped.md:234 36e67d4f0e5740dc96fe27087ac99e4c
msgid ""
"So let's lower those coefficients a bit. It turns out that each of the "
"degrees of freedom needs to be individually tuned depending on many "
"factors, such as the inertial properties of the body nodes, the type and "
"properties of joints, and the current configuration of the system. "
"Figuring out an appropriate set of coefficients can be a tedious process "
"difficult to generalize across new tasks or different skeletons. In the "
"next Lesson, we will introduce a much more efficient way to stabilize the"
" PD controllers without endless tuning and trial-and-errors."
msgstr ""
"따라서 계수를 조금 낮춰야 합니다. 각 자유도는 바디 노드의 관성, 조인트 형태와 특성, 현재 구성 등 많은 요인에 따라 개별적으로"
" 조정해야 합니다. 적절한 값을 찾는 과정은 새 작업이나 다른 스켈레톤에 일반화하기 어렵고 번거롭습니다. 다음 Lesson에서는 "
"끝없는 튜닝 없이 PD 제어기를 안정화하는 더 효율적인 방법을 소개합니다."

#: ../../tutorials/biped.md:244 64e6e060504441bcbd1d18d341fb45e7
msgid "Lesson 3: Stable PD control"
msgstr "Lesson 3: 안정적인 PD 제어"

#: ../../tutorials/biped.md:246 f65f622ec3f040159a5593afc5747985
msgid ""
"SPD is a variation of PD control proposed by [Jie "
"Tan](http://www.cc.gatech.edu/~jtan34/project/spd.html). The basic idea "
"of SPD is to compute control force using the predicted state at the next "
"time step, instead of the current state. This Lesson will only "
"demonstrate the implementation of SPD using DART without going into "
"details of SPD derivation."
msgstr ""
"SPD(Stable PD)는 [Jie "
"Tan](http://www.cc.gatech.edu/~jtan34/project/spd.html)이 제안한 PD 제어 변형으로, "
"현재 상태 대신 다음 타임스텝에서 예측한 상태를 사용해 제어력을 계산합니다. 이 Lesson에서는 SPD의 수학적 유도 대신 "
"DART로 구현하는 방법을 보여줍니다."

#: ../../tutorials/biped.md:253 1c79adf4a11243d4958335b8cce13c73
msgid ""
"The implementation of SPD involves accessing the current dynamic "
"quantities in Lagrange's equations of motion. Fortunately, these "
"quantities are readily available via DART API, which makes the full "
"implementation of SPD simple and concise:"
msgstr ""
"SPD를 구현하려면 라그랑주 운동방정식에 등장하는 동역학량에 접근해야 합니다. DART API가 이러한 값을 제공하므로 구현이 "
"간결해집니다:"

#: ../../tutorials/biped.md:276 427563b986ae406eae258851eae0fea9
msgid ""
"You can get mass matrix, Coriolis force, gravitational force, and "
"constraint force projected onto generalized coordinates using function "
"calls ``getMassMatrix``, ``getCoriolisForces``, ``getGravityForces``, and"
" ``getConstraintForces``, respectively. Constraint forces include forces "
"due to contacts, joint limits, and other joint constraints set by the "
"user (e.g. the weld joint constraint in the multi-pendulum tutorial)."
msgstr ""
"``getMassMatrix``, ``getCoriolisForces``, ``getGravityForces``, "
"``getConstraintForces`` 함수를 호출하면 각각 질량 행렬, 코리올리 힘, 중력, 일반화 좌표로 사영된 제약 힘을 "
"얻을 수 있습니다. 제약 힘에는 접촉, 조인트 제한, 사용자가 추가한 다른 제약(예: multi-pendulum 튜토리얼의 용접 "
"제약)이 포함됩니다."

#: ../../tutorials/biped.md:287 3c990f4b1b6546c58f3c0f8e6987eecd
msgid ""
"With SPD, a wide range of stiffness and damping coefficients will all "
"result in stable motion. In fact, you can just leave them to our original"
" values: 1000 and 50. By holding the target pose, now the biped can stand"
" on the ground in balance indefinitely. However, if you apply an external"
" push force on the biped (hit ',' or '.' key to apply a backward or "
"forward push), the biped loses its balance quickly. We will demonstrate a"
" more robust feedback controller in the next Lesson."
msgstr ""
"SPD를 사용하면 폭넓은 강성·감쇠 계수 범위에서도 안정적인 움직임을 얻을 수 있으므로 기본값인 1000/50을 그대로 사용해도 "
"됩니다. 목표 자세를 유지하면 이족 보행자는 오랫동안 균형을 유지할 수 있지만 ',' 또는 '.' 키로 외력을 가하면 금방 "
"무너집니다. 다음 Lesson에서는 더 견고한 피드백 제어기를 소개합니다."

#: ../../tutorials/biped.md:296 a95e05d7fdfd417abe35f6ae689129fa
msgid "Lesson 4: Ankle strategy"
msgstr "Lesson 4: 발목 전략"

#: ../../tutorials/biped.md:298 af8949fa69604dc88e635e54999ea84c
msgid ""
"Ankle (or hip) strategy is an effective way to maintain standing balance."
" The idea is to adjust the target position of ankles according to the "
"deviation between the center of mass and the center of pressure projected"
" on the ground. A simple linear feedback rule is used to update the "
"target ankle position: &theta;<sub>a</sub> = -k<sub>p</sub> (x - p) - "
"k<sub>d</sub> (x&#775; - p&#775;), where x and p indicate the center of "
"mass and center of pressure in the anterior-posterior axis. k<sub>p</sub>"
" and k<sub>d</sub> are the feedback gains defined by the user."
msgstr ""
"발목(또는 고관절) 전략은 정지 균형을 유지하는 효과적인 방법입니다. 개념은 질량 중심과 바닥에 투영된 압력 중심 간의 차이를 "
"측정해 발목의 목표 위치를 조정하는 것입니다. 선형 피드백 규칙 &theta;<sub>a</sub> = -k<sub>p</sub> "
"(x - p) - k<sub>d</sub> (x&#775; - p&#775;)을 사용하며, x와 p는 앞뒤 축에서의 질량 중심과 "
"압력 중심을 의미하고 k<sub>p</sub>, k<sub>d</sub> 는 사용자가 정하는 피드백 이득입니다."

#: ../../tutorials/biped.md:308 128bbdcb632e4440b041c3d417f61173
msgid ""
"To implement ankle strategy, let's first compute the deviation between "
"the center of mass and an approximated center of pressure in the "
"anterior-posterior axis:"
msgstr "발목 전략을 적용하려면 먼저 앞뒤 축에서 질량 중심과 근사 압력 중심 사이의 편차를 계산합니다:"

#: ../../tutorials/biped.md:330 26f9388627674584a48cbee8127681cd
msgid ""
"DART provides various APIs to access useful kinematic information. For "
"example, ``getCOM`` returns the center of mass of the skeleton and "
"``getTransform`` returns transformation of the body node with respect to "
"any coordinate frame specified by the parameter (world coordinate frame "
"as default). DART APIs also come in handy when computing the derivative "
"term,  -k<sub>d</sub> (x&#775; - p&#775;):"
msgstr ""
"DART는 유용한 운동학 정보를 얻기 위한 다양한 API를 제공합니다. 예를 들어 ``getCOM`` 은 스켈레톤의 질량 중심을 "
"반환하고 ``getTransform`` 은 기본적으로 월드 좌표계에 대한 BodyNode의 변환을 돌려줍니다. 도함수 항  "
"-k<sub>d</sub> (x&#775; - p&#775;) 를 계산할 때도 DART API가 유용합니다:"

#: ../../tutorials/biped.md:355 862e64739e444258ae6488a514f96688
msgid ""
"The linear/angular velocity/acceleration of any point in any coordinate "
"frame can be easily accessed in DART. The full list of the APIs for "
"accessing various velocities/accelerations can be found in the [API "
"Documentation](http://dartsim.github.io/dart/). The  following table "
"summarizes the essential APIs."
msgstr ""
"DART에서는 어떤 좌표계에서든任의 지점의 선형/각 속도·가속도를 쉽게 얻을 수 있습니다. 관련 API 전체 목록은 [API "
"문서](http://dartsim.github.io/dart/)에서 확인할 수 있으며, 아래 표에는 핵심 API를 정리했습니다."

#: ../../tutorials/biped.md 41ca13d831b44ce1906d4ba3a95c5a73
#: 6234031a3ea841568af67e5a1a434397 db54f5f8b7b34b9c98ee1e46a4ccd74b
msgid "Function Name"
msgstr "함수 이름"

#: ../../tutorials/biped.md 4a334730b2d3492880675cf1d36cb065
#: 7f3a098ba4834045b3d135e76849bb91 d901a452075e41ea9cec95fc1bb4804e
#: ef813505db3047048d0c62b6b137d09b
msgid "Description"
msgstr "설명"

#: ../../tutorials/biped.md 191d32e5679545e5a3d6229cc26d558f
msgid "getSpatialVelocity"
msgstr "getSpatialVelocity"

#: ../../tutorials/biped.md dae15b666bf94a7aa80e1338c5fc4485
msgid ""
"Return the spatial velocity of this BodyNode in the coordinates of the "
"BodyNode."
msgstr "이 BodyNode 좌표계에서의 공간 속도를 반환합니다."

#: ../../tutorials/biped.md ea76e8224b2a4a06aef4004936ee4429
msgid "getLinearVelocity"
msgstr "getLinearVelocity"

#: ../../tutorials/biped.md fc9a3f77803b4c98b3e7cbf18651b9e1
msgid ""
"Return the linear portion of classical velocity of the BodyNode relative "
"to some other BodyNode."
msgstr "다른 BodyNode에 대한 고전적 속도의 선형 부분을 반환합니다."

#: ../../tutorials/biped.md a18049b0f1ce4b48b8d092ee38144b74
msgid "getAngularVelocity"
msgstr "getAngularVelocity"

#: ../../tutorials/biped.md e823d23cae474924adb287e5c81869c2
msgid ""
"Return the angular portion of classical velocity of this BodyNode "
"relative to some other BodyNode."
msgstr "다른 BodyNode에 대한 고전적 속도의 각 부분을 반환합니다."

#: ../../tutorials/biped.md 7c5ff4581789498291f7a9ffbffe316f
msgid "getSpatialAcceleration"
msgstr "getSpatialAcceleration"

#: ../../tutorials/biped.md 2478586afeea462c9267044fb1fc4469
msgid ""
"Return the spatial acceleration of this BodyNode in the coordinates of "
"the BodyNode."
msgstr "해당 BodyNode 좌표계에서의 공간 가속도를 반환합니다."

#: ../../tutorials/biped.md 9445f3f4b18b46c28aa35298f38bc63f
msgid "getLinearAcceleration"
msgstr "getLinearAcceleration"

#: ../../tutorials/biped.md 0c823799479e4485bbe98de3be8e760c
msgid ""
"Return the linear portion of classical acceleration of the BodyNode "
"relative to some other BodyNode."
msgstr "다른 BodyNode에 대한 고전적 가속도의 선형 부분을 반환합니다."

#: ../../tutorials/biped.md 1e7f5fa1c1e64e26bb4c2f2a70368813
msgid "getAngularAcceleration"
msgstr "getAngularAcceleration"

#: ../../tutorials/biped.md a0cc9751e5fc4d529097b1d84d9e2b0e
msgid ""
"Return the angular portion of classical acceleration of this BodyNode "
"relative to some other BodyNode."
msgstr "다른 BodyNode에 대한 고전적 가속도의 각 부분을 반환합니다."

#: ../../tutorials/biped.md:369 03094ed29ff04e89936c199f03a8cc78
msgid ""
"The remaining of the ankle strategy implementation is just the matter of "
"parameters tuning. We found that using different feedback rules for "
"falling forward and backward result in more stable controller."
msgstr ""
"발목 전략 구현의 나머지는 파라미터 조정 문제입니다. 전방/후방으로 넘어질 때 서로 다른 피드백 규칙을 사용하면 제어기가 더 "
"안정적이라는 점을 확인했습니다."

#: ../../tutorials/biped.md:373 bfe180cb430a4bbcae9a71eb75b88c9c
msgid "Lesson 5: Skeleton editing"
msgstr "Lesson 5: 스켈레톤 편집"

#: ../../tutorials/biped.md:375 22507daf925d43be9cde8f6c889cd571
msgid ""
"DART provides various functions to copy, delete, split, and merge parts "
"of skeletons to alleviate the pain of building simulation models from "
"scratch. In this Lesson, we will load a skateboard model from a SKEL file"
" and merge our biped with the skateboard to create a wheel-based robot."
msgstr ""
"DART는 스켈레톤 일부를 복사·삭제·분할·병합하는 다양한 기능을 제공해 모델링 작업을 돕습니다. 이번 Lesson에서는 SKEL "
"파일에서 스케이트보드 모델을 불러와 이족 보행자와 결합해 바퀴 기반 로봇을 만듭니다."

#: ../../tutorials/biped.md:381 f71c8c77e5054155b41fda0585b7e517
msgid "We first load a skateboard from **skateboard.skel**:"
msgstr "**skateboard.skel** 에서 스케이트보드를 불러옵니다:"

#: ../../tutorials/biped.md:401 615db67d487f417bacaf719c975db2ab
msgid ""
"Our goal is to make the skateboard Skeleton a subtree of the biped "
"Skeleton connected to the left heel BodyNode via a newly created Euler "
"joint. To do so, you need to first create an instance of "
"``EulerJoint::Properties`` for this new joint."
msgstr ""
"목표는 새 Euler 조인트를 통해 스케이트보드 스켈레톤을 이족 보행자 스켈레톤의 왼발 뒤꿈치 BodyNode 아래 서브트리로 "
"만드는 것입니다. 이를 위해 먼저 ``EulerJoint::Properties`` 인스턴스를 생성합니다."

#: ../../tutorials/biped.md:406 4b37d8bd12d940e0816e985b68d0c456
msgid ""
"Here we increase the vertical distance between the child BodyNode and the"
" joint by 0.1m to give some space between the skateboard and the left "
"foot before merging it with the biped."
msgstr ""
"스케이트보드를 이족 보행자와 병합하기 전에 왼발과의 간격을 확보하려고 자식 BodyNode와 조인트 사이의 수직 거리를 0.1m "
"늘립니다."

#: ../../tutorials/biped.md:410 92810948026241d797b67a8dc4fbc7a1
msgid ""
"There are many other functions you can use to edit skeletons. Here is a "
"table of some relevant functions for quick references."
msgstr "스켈레톤 편집에 사용할 수 있는 다른 함수도 많습니다. 참고용으로 주요 함수를 표로 정리했습니다."

#: ../../tutorials/biped.md 0e7d0d5957e54d039df5a35a0cdd6c1d
msgid "Example"
msgstr "예시"

#: ../../tutorials/biped.md 4c2344698a7b421a8e993aa22b23b63e
msgid "remove"
msgstr "remove"

#: ../../tutorials/biped.md a7747ad57c8f4b03ae7edea4719ad03f
msgid "bd1->remove()"
msgstr "bd1->remove()"

#: ../../tutorials/biped.md d3229c72d5a84f348b556b5d5f19ec86
msgid "Remove the BodyNode bd1 and its subtree from their Skeleton."
msgstr "BodyNode bd1과 그 하위 트리를 스켈레톤에서 제거합니다."

#: ../../tutorials/biped.md 8387c7738a1540c6b2279b06735842e6
msgid "moveTo"
msgstr "moveTo"

#: ../../tutorials/biped.md 253a1505cc85456d9689920bfac91ee1
msgid "bd1->moveTo(bd2)"
msgstr "bd1->moveTo(bd2)"

#: ../../tutorials/biped.md 9c46d4026dfb429dbc2efd59b11643d3
msgid "Move the BodyNode bd1 and its subtree under the BodyNode bd2."
msgstr "BodyNode bd1과 그 하위 트리를 BodyNode bd2 아래로 이동합니다."

#: ../../tutorials/biped.md 85c089af3d364ec7b0ceb86636980756
msgid "split"
msgstr "split"

#: ../../tutorials/biped.md d14e18de4311403eac9a7820e0f49190
msgid "auto newSkel = bd1->split(\"new skeleton\")`"
msgstr "auto newSkel = bd1->split(\"new skeleton\")`"

#: ../../tutorials/biped.md 6bdb9aba223d47199300986834dfa8fc
msgid ""
"Remove the BodyNode bd1 and its subtree from their current Skeleton and "
"move them into a newly created Skeleton with \"new skeleton\" name."
msgstr ""
"BodyNode bd1과 그 하위 트리를 현재 스켈레톤에서 제거한 뒤 \"new skeleton\"이라는 이름의 새 스켈레톤으로 "
"옮깁니다."

#: ../../tutorials/biped.md 8d7c6ee931654755a938502bf5d87720
msgid "changeParentJointType"
msgstr "changeParentJointType"

#: ../../tutorials/biped.md 4718a8585ff84fa1a81af110373ba83d
msgid "bd1->changeParentJointType&lt;BallJoint&gt;()"
msgstr "bd1->changeParentJointType&lt;BallJoint&gt;()"

#: ../../tutorials/biped.md 90d2f821763540e5aa34a20000c54fd6
msgid "Change the Joint type of the BodyNode bd1's parent joint to BallJoint"
msgstr "BodyNode bd1의 부모 조인트 유형을 BallJoint로 변경합니다."

#: ../../tutorials/biped.md c9787ef39c104a18a7e4c8e11c56c628
msgid "copyTo"
msgstr "copyTo"

#: ../../tutorials/biped.md 129e43a342ff41d1af2d3fa8e09002b2
msgid "bd1->copyTo(bd2)"
msgstr "bd1->copyTo(bd2)"

#: ../../tutorials/biped.md 953b10346dcf4d82a3096de68c111a02
msgid ""
"Create clones of the BodyNode bd1 and its subtree and attach the clones "
"to the specified the BodyNode bd2."
msgstr "BodyNode bd1과 그 하위 트리를 복제해 지정한 BodyNode bd2 아래에 붙입니다."

#: ../../tutorials/biped.md 65cb83f082694795a6bda071231bdbea
msgid "copyAs"
msgstr "copyAs"

#: ../../tutorials/biped.md d9f67f06d9e544b59c62b5a9b3fe27bf
msgid "auto newSkel = bd1->copyAs(\"new skeleton\")"
msgstr "auto newSkel = bd1->copyAs(\"new skeleton\")"

#: ../../tutorials/biped.md 233c6acf4f214e0a908a7875fc78a8ce
msgid ""
"Create clones of the BodyNode bd1 and its subtree and create a new "
"Skeleton with \"new skeleton\" name to attach them to."
msgstr "BodyNode bd1과 그 하위 트리를 복제하여 \"new skeleton\"이라는 새 스켈레톤에 추가합니다."

#: ../../tutorials/biped.md:423 7bc790be3ccf436cabf07f1f5f0ef73c
msgid "Lesson 6: Actuator types"
msgstr "Lesson 6: 액추에이터 유형"

#: ../../tutorials/biped.md:425 73a9848547624e14b05245d202316369
msgid ""
"DART provides seven types of actuator. Each joint can select its own "
"actuator type."
msgstr "DART는 일곱 가지 액추에이터 유형을 제공하며 각 조인트는 필요에 맞는 유형을 선택할 수 있습니다."

#: ../../tutorials/biped.md 38fbe3033dff4d88811fd5480fd23f01
msgid "Type"
msgstr "유형"

#: ../../tutorials/biped.md 5bae209f54f2404c802890e2462cdc8c
msgid "FORCE"
msgstr "FORCE"

#: ../../tutorials/biped.md 60c412fe85b84a5e9316e63945004c06
msgid "Take joint force and return the resulting joint acceleration."
msgstr "조인트 힘을 받아 그에 따른 가속도를 반환합니다."

#: ../../tutorials/biped.md 5fb4f5f80fea4c8193746776578fdd83
msgid "PASSIVE"
msgstr "PASSIVE"

#: ../../tutorials/biped.md 9b92ea9e056b401d8459a94633d6e1cc
msgid ""
"Take nothing (joint force = 0) and return the resulting joint "
"acceleration."
msgstr "입력 없이(조인트 힘=0) 발생하는 가속도를 반환합니다."

#: ../../tutorials/biped.md 1007c329d86d4091b223273737e17806
msgid "SERVO"
msgstr ""

#: ../../tutorials/biped.md a18a50ec49c74a6cb165bca2df742560
msgid ""
"Track a desired joint velocity using a constraint-based servo that "
"applies whatever force is allowed by the joint."
msgstr ""

#: ../../tutorials/biped.md 171b559a0f6243829458a14d5ec6c1af
msgid "ACCELERATION"
msgstr "ACCELERATION"

#: ../../tutorials/biped.md d4e91cde3c9541b2a1fd6ba8e02e6ba8
msgid ""
"Take desired joint acceleration and return the joint force to achieve the"
" acceleration."
msgstr "목표 가속도를 입력받아 해당 가속도를 만들 힘을 반환합니다."

#: ../../tutorials/biped.md cc215dd3a73047418d37c8b64b002b36
msgid "VELOCITY"
msgstr "VELOCITY"

#: ../../tutorials/biped.md 9c5bd3e38c94453586bf85bbfef0d208
msgid ""
"Take desired joint velocity and return the joint force to achieve the "
"velocity."
msgstr "목표 속도를 입력받아 그 속도를 내기 위한 힘을 반환합니다."

#: ../../tutorials/biped.md ba1a7903773e4ab58f5650dd240031de
msgid "LOCKED"
msgstr "LOCKED"

#: ../../tutorials/biped.md 1d257d9f6e0f43cd9ba46302d517894c
msgid ""
"Lock the joint by setting the joint velocity and acceleration to zero and"
" return the joint force to lock the joint."
msgstr "속도와 가속도를 0으로 만들고 조인트를 잠그기 위한 힘을 반환합니다."

#: ../../tutorials/biped.md edff2191e857422390b8cf7030b13acd
msgid "MIMIC"
msgstr ""

#: ../../tutorials/biped.md 8f2b92c7f8f24317ab0bcac462382d3a
msgid "Mirror the command of another joint instead of accepting a direct command."
msgstr ""

#: ../../tutorials/biped.md:438 26e65fda6f7c4b7db46d14c07b5c2193
msgid ""
"Servo actuators behave dynamically (like `FORCE` joints) while steering "
"the velocity toward the command via a `ServoMotorConstraint`. This is "
"useful when you want to respect force limits and still let the dynamics "
"solver decide how much torque is needed, as opposed to the `VELOCITY` "
"actuator which drives the joint kinematically."
msgstr ""

#: ../../tutorials/biped.md:444 7612ecb1e44e492d9a76508b9938e911
msgid ""
"In this Lesson, we will switch the actuator type of the wheels from the "
"default FORCE type to VELOCITY type."
msgstr "이번 Lesson에서는 바퀴 액추에이터를 기본 FORCE 유형에서 VELOCITY 유형으로 변경합니다."

#: ../../tutorials/biped.md:465 162b58e29a8b4fdcb8f158e2c9e8721a
msgid ""
"Once all four wheels are set to VELOCITY actuator type, you can command "
"them by directly setting the desired velocity:"
msgstr "네 개 바퀴를 모두 VELOCITY 유형으로 바꾸면 원하는 속도를 직접 지정해 제어할 수 있습니다:"

#: ../../tutorials/biped.md:486 87273bed7a56407ea384d19a297ce3e3
msgid ""
"Note that ``setCommand`` only exerts commanding force in the current time"
" step. If you wish the wheel to continue spinning at a particular speed, "
"``setCommand`` needs to be called at every time step."
msgstr ""
"``setCommand`` 는 현재 타임스텝에서만 제어력을 적용합니다. 특정 속도로 계속 회전시키려면 매 타임스텝마다 "
"``setCommand`` 를 호출해야 합니다."

#: ../../tutorials/biped.md:490 c46a650a12d94407843cb2128c96239a
msgid "We also set the stiffness and damping coefficients for the wheels to zero."
msgstr "바퀴의 강성과 감쇠 계수도 0으로 설정합니다."

#: ../../tutorials/biped.md:505 392a3e34a38a4745a1d5b18af6c41486
msgid ""
"This is because we do not want the velocity-based actuators to "
"incorrectly affect the computation of SPD. If we use simple PD control "
"scheme, the values of these spring and damping coefficients do not affect"
" the dynamics of the system."
msgstr ""
"이는 속도 기반 액추에이터가 SPD 계산에 영향을 주지 않도록 하기 위함입니다. 단순 PD 제어를 사용하더라도 이 스프링·감쇠 계수"
" 값은 시스템 동역학에 영향을 주지 않습니다."

#: ../../tutorials/biped.md:510 77a8b29b2fab4274924af0145eabbe31
msgid ""
"Let's simulate what we've got so far. The biped now is connecting to the "
"skateboard through a Euler joint. Once the simulation starts, you can use"
" 'a' and 's' to increase or decrease the wheel speed. However, the biped "
"falls on the floor immediately because the current target pose is not "
"balanced for one-foot stance. We need to find a better target pose."
msgstr ""
"지금까지 구성한 상태로 시뮬레이션을 돌립니다. 이족 보행자는 Euler 조인트를 통해 스케이트보드와 연결되어 있고, 시뮬레이션 도중"
" 'a'와 's' 키로 바퀴 속도를 조절할 수 있습니다. 다만 현재 목표 자세가 한 발 지지에 적합하지 않아 곧바로 넘어지므로 더 "
"나은 목표 자세가 필요합니다."

#: ../../tutorials/biped.md:517 93bf8080d360475294e0b3da0248e27a
msgid "Lesson 7: Inverse kinematics"
msgstr "Lesson 7: 역기구학"

#: ../../tutorials/biped.md:519 b342d8194c6146ae8009836084a65a77
msgid ""
"Instead of manually designing a target pose, this time we will solve for "
"a balanced pose by formulating an inverse kinematics (IK) problem and "
"solving it using gradient descent method. In this example, a balanced "
"pose is defined as a pose where the center of mass is well supported by "
"the ground contact and the left foot lies flat on the ground. As such, we"
" cast IK as an optimization problem that minimizes the horizontal "
"deviation between the center of mass and the center of the left foot, as "
"well as the vertical distance of the four corners of the left foot from "
"the ground:"
msgstr ""
"이번에는 목표 자세를 직접 설계하는 대신 역기구학(IK) 문제를 구성해 기울기 하강법으로 균형 자세를 구합니다. 균형 자세란 질량 "
"중심이 지면 접촉으로 잘 지지되고 왼발이 평평하게 놓인 상태로 정의합니다. 이에 따라 질량 중심과 왼발 중심 간 수평 편차와 왼발 "
"네 모서리의 지면과의 높이를 최소화하는 최적화 문제로 IK를 정식화합니다:"

#: ../../tutorials/biped.md:531 b5666a21525a440ba066b83a485e1e64
msgid ""
"where <b>c</b> and <b>p</b> indicate the projected center of mass and "
"center of pressure on the ground, and *p<sub>i</sub>* indicates the "
"vertical height of one corner of the left foot."
msgstr ""
"여기서 <b>c</b> 와 <b>p</b> 는 지면에 투영한 질량 중심과 압력 중심, *p<sub>i</sub>* 는 왼발 각 "
"모서리의 높이를 의미합니다."

#: ../../tutorials/biped.md:535 773ddaf08e7243a0ba747eab8804daf4
msgid ""
"To compute the gradient of the above objective function, we need to "
"evaluate the partial derivatives of each objective term with respect to "
"the degrees of freedom, i.e., the computation of Jacobian matrix. DART "
"provides a comprensive set of APIs for accessing various types of "
"Jacobian. In this example, computing the gradient of the first term of "
"the objective function requires the Jacobian of the center of mass of the"
" Skeleton, as well as the Jacobian of the center of mass of a BodyNode:"
msgstr ""
"이 목표 함수의 그래디언트를 계산하려면 각 항을 자유도에 대해 편미분해야 하므로 자코비안을 구해야 합니다. DART는 다양한 "
"자코비안에 접근하는 API를 제공합니다. 예를 들어 첫 번째 항의 그래디언트는 스켈레톤 질량 중심 자코비안과 특정 BodyNode "
"질량 중심 자코비안을 필요로 합니다:"

#: ../../tutorials/biped.md:562 a391a70dcf0f482c88b318dc8e408109
msgid ""
"``getCOMLinearJacobian`` returns the linear Jacobian of the center of "
"mass of the Skeleton, while ``getLinearJacobian`` returns the Jacobian of"
" a point on a BodyNode. The BodyNode and the local coordinate of the "
"point are specified as parameters to this function. Here the point of "
"interest is the center of mass of the left foot, which local coordinates "
"can be accessed by ``getCOM`` with a parameter indicating the left foot "
"being the frame of reference. We use ``getLinearJacobian`` again to "
"compute the gradient of the second term of the objective function:"
msgstr ""
"``getCOMLinearJacobian`` 은 스켈레톤 질량 중심의 선형 자코비안을, ``getLinearJacobian`` 은 "
"BodyNode 상의 특정 점 자코비안을 반환합니다. BodyNode와 해당 점의 로컬 좌표는 함수 인자로 넘기며, 여기서는 왼발을"
" 기준으로 ``getCOM`` 을 호출해 질량 중심 좌표를 얻습니다. 두 번째 항의 그래디언트 역시 "
"``getLinearJacobian`` 으로 계산합니다:"

#: ../../tutorials/biped.md:582 e73bd1a121e6490f90a161ebce6bd3a6
msgid ""
"The full list of Jacobian APIs can be found in the [API "
"Documentation](http://dartsim.github.io/dart/). The  following table "
"summarizes the essential APIs."
msgstr ""
"자코비안 관련 API 전체 목록은 [API 문서](http://dartsim.github.io/dart/)에서 확인할 수 있으며 "
"아래 표는 핵심 API를 정리한 것입니다."

#: ../../tutorials/biped.md fe7cf3eb082e4e7cbfb6242c935115cd
msgid "getJacobian"
msgstr "getJacobian"

#: ../../tutorials/biped.md bcf8dda5feea4ac48767810c5aada411
msgid ""
"Return the generalized Jacobian targeting the origin of the BodyNode. The"
" Jacobian is expressed in the Frame of this BodyNode."
msgstr "BodyNode 원점을 대상으로 하는 일반화 자코비안을 BodyNode 좌표계로 반환합니다."

#: ../../tutorials/biped.md 07d4ad43e9e24bb3ae59cd451acbeea6
msgid "getLinearJacobian"
msgstr "getLinearJacobian"

#: ../../tutorials/biped.md 558455988bec418599e260f074f0542e
msgid ""
"Return the linear Jacobian targeting the origin of the BodyNode. You can "
"specify a coordinate Frame to express the Jacobian in."
msgstr "BodyNode 원점의 선형 자코비안을 반환하며 표현 좌표계를 지정할 수 있습니다."

#: ../../tutorials/biped.md a9f2d6c8922b4d4c8359390b91177884
msgid "getAngularJacobian"
msgstr "getAngularJacobian"

#: ../../tutorials/biped.md 99dea9be107642b1acedab6a059d1fd7
msgid ""
"Return the angular Jacobian targeting the origin of the BodyNode. You can"
" specify a coordinate Frame to express the Jacobian in."
msgstr "BodyNode 원점의 각 자코비안을 반환하며 표현 좌표계를 지정할 수 있습니다."

#: ../../tutorials/biped.md 84a3d1fef4944e4cb74d25e904a98989
msgid "getJacobianSpatialDeriv"
msgstr "getJacobianSpatialDeriv"

#: ../../tutorials/biped.md eace0381fb0f4884ba5479029e815a7b
msgid ""
"Return the spatial time derivative of the generalized Jacobian targeting "
"the origin of the BodyNode. The Jacobian is expressed in the BodyNode's "
"coordinate Frame."
msgstr "BodyNode 원점의 일반화 자코비안에 대한 공간 도함수를 BodyNode 좌표계로 반환합니다."

#: ../../tutorials/biped.md 42c7aa3730074dcab6441c63b9aa4c7c
msgid "getJacobianClassicDeriv"
msgstr "getJacobianClassicDeriv"

#: ../../tutorials/biped.md 6e578e27a6a64d23a262d452e40a07a0
msgid ""
"Return the classical time derivative of the generalized Jacobian "
"targeting the origin of the BodyNode. The Jacobian is expressed in the "
"World coordinate Frame."
msgstr "BodyNode 원점의 일반화 자코비안을 월드 좌표계에서 고전적으로 미분한 값을 반환합니다."

#: ../../tutorials/biped.md 4cdf34ce752c406092f10c48a07553a6
msgid "getLinearJacobianDeriv"
msgstr "getLinearJacobianDeriv"

#: ../../tutorials/biped.md 3bc0406363804af0803e6a2531b4879c
msgid ""
"Return the linear Jacobian (classical) time derivative, in terms of any "
"coordinate Frame."
msgstr "선형 자코비안의 고전적 시간 미분을 원하는 좌표계로 반환합니다."

#: ../../tutorials/biped.md 898b982b81394712819654d66e4d43f2
msgid "getAngularJacobianDeriv"
msgstr "getAngularJacobianDeriv"

#: ../../tutorials/biped.md 9fc20de3d96d4d39838c9a79eb62724f
msgid ""
"Return the angular Jacobian (classical) time derivative, in terms of any "
"coordinate Frame."
msgstr "각 자코비안의 고전적 시간 미분을 원하는 좌표계로 반환합니다."

#: ../../tutorials/biped.md:595 a94f1dfb86c94fd5a43fd8d3559c7a7c
msgid ""
"This Lesson concludes the entire Biped tutorial. You should see a biped "
"standing stably on the skateboard. With moderate "
"acceleration/deceleration on the skateboard, the biped is able to "
"maintain balance and hold the one-foot stance pose."
msgstr ""
"이 Lesson을 끝으로 이족 보행 튜토리얼을 마칩니다. 이족 보행자는 스케이트보드 위에서 안정적으로 서 있어야 하며, 적당한 "
"가감속이 가해져도 한 발 지지 자세를 유지할 수 있어야 합니다."
