# SOME DESCRIPTIVE TITLE.
# Copyright (C) Copyright (c) 2011, The DART development contributors
# This file is distributed under the same license as the DART: Dynamic
# Animation and Robotics Toolkit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: DART: Dynamic Animation and Robotics Toolkit "
"7.0.0-alpha0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-17 09:47-0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ko\n"
"Language-Team: ko <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../tutorials/collisions.md:1 c1fd6790b04d470f9dfa68f8bbb2008e
msgid "Collisions"
msgstr "충돌"

#: ../../tutorials/collisions.md:3 6a9c17cb991e4925970edf011d1e2eb5
msgid "Overview"
msgstr "개요"

#: ../../tutorials/collisions.md:4 014d1a6e9b41432da3887a7576543ba0
msgid ""
"This tutorial will show you how to programmatically create different "
"kinds of bodies and set initial conditions for Skeletons. It will also "
"demonstrate some use of DART's Frame Semantics."
msgstr ""
"이 튜토리얼에서는 프로그래밍 방식으로 다양한 종류의 몸체를 생성하고 스켈레톤의 초기 조건을 설정하는 방법을 보여줍니다. 또한 "
"DART의 프레임 의미론의 일부 사용을 보여줍니다."

#: ../../tutorials/collisions.md:8 f2fd54e3879e42f9bc6a2a25135c7cbb
msgid "The tutorial consists of five Lessons covering the following topics:"
msgstr "이 튜토리얼은 다음 주제를 다루는 5개의 단원으로 구성됩니다."

#: ../../tutorials/collisions.md:10 82712987dac14888a3034a440adca647
msgid "Creating a rigid body"
msgstr "강체 만들기"

#: ../../tutorials/collisions.md:11 b662be2f261745f3875a9098bcf11e60
msgid "Creating a soft body"
msgstr "부드러운 몸 만들기"

#: ../../tutorials/collisions.md:12 14c2aa978dd1440b878c496a618fea66
msgid "Setting initial conditions and taking advantage of Frames"
msgstr "초기 조건 설정 및 프레임 활용"

#: ../../tutorials/collisions.md:13 36a713757e704eb692d055d5d898b767
msgid "Setting joint spring and damping properties"
msgstr "조인트 스프링 및 감쇠 속성 설정"

#: ../../tutorials/collisions.md:14 786998793b18466f9b4e01da0a960923
msgid "Creating a closed kinematic chain"
msgstr "닫힌 운동학적 체인 만들기"

#: ../../tutorials/collisions.md:16 0cd98bec7de24d249f3eb940a6a27812
msgid ""
"Please reference the source code in "
"[**tutorial_collisions/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_collisions/main.cpp)"
" and "
"[**tutorial_collisions_finished/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_collisions_finished/main.cpp)."
msgstr ""
"[**tutorial_collisions/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_collisions/main.cpp)"
" 와 [**tutorial_collisions_finished/main.cpp**](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_collisions_finished/main.cpp)"
" 소스 코드를 참고하세요."

#: ../../tutorials/collisions.md:18 8dc15f79ec3c4ebc8f0f21854c2e6b70
msgid "Lesson 1: Creating a rigid body"
msgstr "단원 1: 강체 만들기"

#: ../../tutorials/collisions.md:20 939f1283a2704548948ef443d1df3dac
msgid ""
"Start by opening the Skeleton code in "
"[``tutorials/tutorial_collisions/main.cpp``](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_collisions/main.cpp)."
" Find the function named ``addRigidBody``. You will notice that this is a"
" templated function. If you're not familiar with templates, that's okay; "
"we won't be doing anything too complicated with them. Different Joint "
"types in DART are managed by a bunch of different classes, so we need to "
"use templates if we want the same function to work with a variety of "
"Joint types."
msgstr ""
"먼저 "
"[``tutorials/tutorial_collisions/main.cpp``](https://github.com/dartsim/dart/blob/main/tutorials/tutorial_collisions/main.cpp)"
"의 스켈레톤 코드를 열고 ``addRigidBody`` 라는 함수를 찾으세요. 이 함수가 템플릿 함수라는 것을 알 수 있습니다. "
"템플릿에 익숙하지 않아도 괜찮습니다. 여기서는 복잡한 작업을 하지 않을 것입니다. DART의 다양한 조인트 유형은 서로 다른 "
"클래스가 관리하므로 여러 조인트 유형에서 동일한 함수가 동작하도록 하려면 템플릿이 필요합니다."

#: ../../tutorials/collisions.md:27 9e2e568d573245cfae26f1f2c80ec3e0
msgid "Lesson 1a: Setting joint properties"
msgstr "1a단원: 접합 속성 설정"

#: ../../tutorials/collisions.md:29 7ee33f51ce87468786d85cfec226a53b
msgid ""
"The first thing we'll want to do is set the Joint properties for our new "
"body. Whenever we create a BodyNode, we must also create a parent Joint "
"for it. A BodyNode needs a parent Joint, even if that BodyNode is the "
"root of the Skeleton, because we need its parent Joint to describe how "
"it's attached to the world. A root BodyNode could be attached to the "
"world by any kind of Joint. Most often, it will be attached by either a "
"FreeJoint (if the body should be completely free to move with respect to "
"the world) or a WeldJoint (if the body should be rigidly attached to the "
"world, unable to move at all), but *any* Joint type is permissible."
msgstr ""
"가장 먼저 해야 할 일은 새 몸체의 관절 속성을 설정하는 것입니다. BodyNode를 생성할 때마다 이에 대한 상위 조인트도 "
"생성해야 합니다. BodyNode가 스켈레톤의 루트인 경우에도 BodyNode에는 상위 조인트가 필요합니다. 세계에 어떻게 "
"연결되는지 설명하려면 상위 조인트가 필요하기 때문입니다. 루트 BodyNode는 모든 종류의 조인트를 통해 월드에 연결될 수 "
"있습니다. 대부분의 경우 FreeJoint(신체가 월드에 대해 완전히 자유롭게 움직여야 하는 경우) 또는 WeldJoint(신체가 "
"월드에 단단히 부착되어 전혀 움직일 수 없는 경우)에 의해 연결되지만 *모든* 조인트 유형이 허용됩니다."

#: ../../tutorials/collisions.md:39 a893f3bd58d342b981be1d028856fb74
msgid ""
"Joint properties are managed in a nested class, which means it's a class "
"which is defined inside of another class. For example, ``RevoluteJoint`` "
"properties are managed in a class called ``RevoluteJoint::Properties`` "
"while ``PrismaticJoint`` properties are managed in a class called "
"``PrismaticJoint::Properties``. However, both ``RevoluteJoint`` and "
"``PrismaticJoint`` inherit the ``SingleDofJoint`` class so the "
"``RevoluteJoint::Properties`` and ``PrismaticJoint::Properties`` classes "
"both inherit the ``SingleDofJoint::Properties`` class. The difference is "
"that ``RevoluteJoint::Properties`` also inherits "
"``RevoluteJoint::UniqueProperties`` whereas "
"``PrismaticJoint::Properties`` inherits "
"``PrismaticJoint::UniqueProperties`` instead. Many DART classes contain "
"nested ``Properties`` classes like this which are compositions of their "
"base class's nested ``Properties`` class and their own "
"``UniqueProperties`` class. As you'll see later, this is useful for "
"providing a consistent API that works cleanly for fundamentally different"
" types of classes."
msgstr ""
"조인트 속성은 중첩 클래스에서 관리됩니다. 즉, 다른 클래스 내부에 정의된 클래스라는 뜻입니다. 예를 들어, "
"``RevoluteJoint`` 속성은 ``RevoluteJoint::Properties``라는 클래스에서 관리되는 반면 "
"``PrismaticJoint`` 속성은 ``PrismaticJoint::Properties``라는 클래스에서 관리됩니다. 그러나 "
"``RevoluteJoint``와 ``PrismaticJoint``는 모두 ``SingleDofJoint`` 클래스를 상속하므로 "
"``RevoluteJoint::Properties``와 ``PrismaticJoint::Properties`` 클래스는 모두 "
"``SingleDofJoint::Properties`` 클래스를 상속합니다. 차이점은 "
"``RevoluteJoint::Properties``도 ``RevoluteJoint::UniqueProperties``를 상속하는 "
"반면 ``PrismaticJoint::Properties``는 ``PrismaticJoint::UniqueProperties``를 "
"상속한다는 것입니다. 많은 DART 클래스에는 기본 클래스의 중첩된 ``Properties`` 클래스와 자체 "
"``UniqueProperties`` 클래스의 구성인 이와 같은 중첩된 ``Properties`` 클래스가 포함되어 있습니다. "
"나중에 보게 되겠지만 이는 근본적으로 다른 유형의 클래스에 대해 깔끔하게 작동하는 일관된 API를 제공하는 데 유용합니다."

#: ../../tutorials/collisions.md:53 318720998f1845c8ae0113edcc13e6bf
msgid ""
"To create a ``Properties`` class for our Joint type, we instantiate the "
"nested struct for the joint, assign it a unique name, and, if needed, "
"offset the joint from its parent BodyNode. The block below shows the "
"complete setup, including the transforms that align the joint halfway "
"between the two bodies:"
msgstr ""

#: ../../tutorials/collisions.md:61 ../../tutorials/collisions.md:116
#: ../../tutorials/collisions.md:174 ../../tutorials/collisions.md:208
#: ../../tutorials/collisions.md:236 ../../tutorials/collisions.md:258
#: ../../tutorials/collisions.md:283 ../../tutorials/collisions.md:331
#: ../../tutorials/collisions.md:364 ../../tutorials/collisions.md:395
#: ../../tutorials/collisions.md:421 ../../tutorials/collisions.md:450
#: ../../tutorials/collisions.md:482 ../../tutorials/collisions.md:534
#: ../../tutorials/collisions.md:563 ../../tutorials/collisions.md:591
#: ../../tutorials/collisions.md:629 ../../tutorials/collisions.md:656
#: ../../tutorials/collisions.md:685 ../../tutorials/collisions.md:721
#: ../../tutorials/collisions.md:745 ../../tutorials/collisions.md:771
#: ../../tutorials/collisions.md:799 3d1e0fea79dc44caa3e6b38801df94d9
#: 416b322a3edc468b935a5b46c28597fb 44366fee281a436a816c999c8dde88e9
#: 494e320b42ee4d9c8656d269021b1cba 497c635e56ab45b1ba5cc21888be6ddb
#: 4f2a0bd888df4516bb69c93cb672cb86 5085f99b7a5c44cfa26a63a682ffc5ca
#: 5ed920b4fdd141c3a3f9f3e0a7179799 66498cee190b4118b36ac8ecdeb95992
#: 6af1dbcab19c4896803611eaf28249ff 749f2c63b3c64322bb130902d8bb2fae
#: 77fd9a4b4c184bb6b9dcd5238e371e63 8fee8bf75984415f8c29ab87cdf94897
#: a9a6d694eef34ca981c1ee951d758969 b71b275c042643e7b2a1a5cc0dd41677
#: b91929e460804f14a7f8e9e8fafd1af6 b9b53fd080a24269a89a4639c7fecbe9
#: bff46f298d19401aa9668420c92f7fbd cf0b9d8835fc486e9b291907d038422a
#: e2ac5bf0310e41daaba2f670841d3a59 f0b2052cb52f49dcbc14a24cf8c49128
#: f3edd9ae1c904fc28cfdb24a43ee235d f836542d3f85412992b099a8cc08866a
msgid "C++"
msgstr ""

#: ../../tutorials/collisions.md:68 ../../tutorials/collisions.md:123
#: ../../tutorials/collisions.md:181 ../../tutorials/collisions.md:215
#: ../../tutorials/collisions.md:243 ../../tutorials/collisions.md:265
#: ../../tutorials/collisions.md:290 ../../tutorials/collisions.md:338
#: ../../tutorials/collisions.md:371 ../../tutorials/collisions.md:402
#: ../../tutorials/collisions.md:428 ../../tutorials/collisions.md:457
#: ../../tutorials/collisions.md:489 ../../tutorials/collisions.md:541
#: ../../tutorials/collisions.md:570 ../../tutorials/collisions.md:598
#: ../../tutorials/collisions.md:636 ../../tutorials/collisions.md:663
#: ../../tutorials/collisions.md:692 ../../tutorials/collisions.md:728
#: ../../tutorials/collisions.md:752 ../../tutorials/collisions.md:778
#: ../../tutorials/collisions.md:806 01b621ee400446e0bccaff824ab8fca6
#: 02c49cb986a9472d8a7e3bb530ecfd2f 059df24f19f147e19f25a3960e8dc76d
#: 124eca5f9e5f402c9685e0dde62955ce 21e280390d794bf2940bae217bf42bdf
#: 28889175c31c4530b30f3f361c8c8fc0 28bc827857e54bb3aac03184ef2f6300
#: 40600e4be3674a42968e61092687e722 44249cb455ca48668e8834df026eb174
#: 48d935b51b3e485a8f78f96e29663edf 517f7e4cb2ca4e13bd66d6089ac6a6d9
#: 52bc7255f3dd4fa0b338855792f85f15 6730d8be857c4eb482dcb7a77e35e284
#: 73671c37a7bf469595b8eb9478cdc497 ac6d6e0d738c4eea9eed138856082e34
#: b45ba01ee30e4b74b118869a0b52c423 c8336ac8f17848b79fc95e9183e501f7
#: ce8dd956e0ce44899de93c30260722ca d0a632c446f2479c89f47d1ebcb08257
#: d8c3b21480ac4be6b704b56f6a4ab489 dac8df536bf24ac4803cd4fd466e362c
#: daedfff865ac46a5b69d6c047c678c51 e7b89df1e4124b4b937c0820690d7503
msgid "Python"
msgstr "파이썬"

#: ../../tutorials/collisions.md:76 622be6fa396948688d1b0b656792dc26
msgid ""
"We need to include the ``typename`` keywords because of how the syntax "
"works for templated functions. Leaving it out should make your compiler "
"complain."
msgstr ""
"템플릿 함수에 대해 구문이 작동하는 방식 때문에 ``typename`` 키워드를 포함해야 합니다. 이를 그대로 두면 컴파일러가 "
"불평을 하게 됩니다."

#: ../../tutorials/collisions.md:79 eec7b9db8f014c27b0889076448b6ac9
msgid ""
"From here, we can set the Joint properties in any way we'd like. There "
"are only a few things we care about right now: First, the Joint's name. "
"Every Joint in a Skeleton needs to have a non-empty unique name. Those "
"are the only restrictions that are placed on Joint names. If you try to "
"make a Joint's name empty, it will be given a default name. If you try to"
" make a Joint's name non-unique, DART will append a number tag to the end"
" of the name in order to make it unique. It will also print out a warning"
" during run time, which can be an eyesore (because it wants you to be "
"aware when you are being negligent about naming things). For the sake of "
"simplicity, let's just give it a name based off its child BodyNode."
msgstr ""
"이제 여기서 원하는 방식으로 조인트 속성을 설정할 수 있습니다. 지금 당장 신경 쓸 부분은 몇 가지뿐입니다. 첫째, 조인트 이름입니다."
" 스켈레톤 안의 모든 조인트에는 비어 있지 않은 고유 이름이 있어야 합니다. 이름을 비워 두면 기본 이름이 자동으로 붙고, 고유성을 "
"깨면 DART가 이름 끝에 숫자 태그를 덧붙여 구분합니다. 또한 실행 중에 경고를 출력해 이름 관리가 소홀했다는 사실을 알려줍니다. "
"단순하게 자식 BodyNode를 기준으로 이름을 붙이겠습니다."

#: ../../tutorials/collisions.md:89 8751e03203cc463ba5b6fdf962779de5
msgid ""
"Next we'll want to deal with offsetting the new BodyNode from its parent "
"BodyNode. An ``Isometry3`` (python) or ``Isometry3d`` (C++) is the Eigen "
"library's version of a homogeneous transformation matrix. Initialize it "
"to the identity to ensure the contents are well-defined before applying "
"translations. We can easily compute the center point between the origins "
"of the two bodies using our default height value and then assign that "
"translation to both the parent- and child-to-joint transforms."
msgstr ""

#: ../../tutorials/collisions.md:97 c5c78b66fe944d1395b44d4b0954c6eb
msgid ""
"Remember that all of that code should go inside the ``if(parent)`` "
"condition. We do not want to create this offset for root BodyNodes, "
"because later on we will rely on the assumption that the root Joint "
"origin is lined up with the root BodyNode origin."
msgstr ""
"해당 코드는 모두 ``if(parent)`` 조건 안에 들어가야 한다는 점을 기억하세요. 나중에 루트 관절 원점이 루트 "
"BodyNode 원점과 정렬된다는 가정에 의존하기 때문에 루트 BodyNode에 대해 이 오프셋을 생성하고 싶지 않습니다."

#: ../../tutorials/collisions.md:102 5df50ccc0c0848fbb32b41198056fb0d
msgid "Lesson 1b: Create a Joint and BodyNode pair"
msgstr "1b단원: Joint 및 BodyNode 쌍 생성"

#: ../../tutorials/collisions.md:104 564b4432e7624c978f27b2c74dd15f43
msgid ""
"A single function is used to simultaneously create a new Joint and its "
"child BodyNode. It's important to note that a Joint cannot be created "
"without a child BodyNode to accompany it, and a BodyNode cannot be "
"created with parent Joint to attach it to something. A parent Joint "
"without a child BodyNode or vice-versa would be non-physical and "
"nonsensical, so we don't allow it."
msgstr ""
"단일 함수는 새로운 조인트와 그 하위 BodyNode를 동시에 생성하는 데 사용됩니다. 동반할 하위 BodyNode가 없으면 "
"조인트를 생성할 수 없으며, 무언가에 연결하기 위해 상위 조인트를 사용하여 BodyNode를 생성할 수 없다는 점을 기억하는 것이 "
"중요합니다. 하위 BodyNode가 없는 상위 조인트 또는 그 반대의 경우는 비물리적이고 무의미하므로 허용하지 않습니다."

#: ../../tutorials/collisions.md:110 903bf362de7545e1ad401b09e43f22f7
msgid ""
"Use the following to create a new Joint & BodyNode, and obtain a pointer "
"to that new BodyNode:"
msgstr "다음을 사용하여 새 Joint & BodyNode를 만들고 해당 새 BodyNode에 대한 포인터를 얻습니다."

#: ../../tutorials/collisions.md:131 368ad67d5f714128a4e648f71571de89
msgid ""
"There's a lot going on in this function, so let's break it down for a "
"moment:"
msgstr "이 함수에는 많은 일이 일어나고 있으므로 잠시 분석해 보겠습니다."

#: ../../tutorials/collisions.md:133 a1a112cf62e344dd925c0a671878ee52
msgid "``chain->createJointAndBodyNodePair<JointType>``"
msgstr ""

#: ../../tutorials/collisions.md:135 7be5ec7d76fd40d6b0ee1e47631f3056
msgid ""
"This is a Skeleton member function that takes template arguments. The "
"first template argument specifies the type of Joint that you want to "
"create. In our case, the type of Joint we want to create is actually a "
"template argument of our current function, so we just pass that argument "
"along. The second template argument of ``createJointAndBodyNodePair`` "
"allows us to specify the BodyNode type that we want to create, but the "
"default argument is a standard rigid  BodyNode, so we can leave the "
"second argument blank."
msgstr ""
"이것은 템플릿 인수를 취하는 Skeleton 멤버 함수입니다. 첫 번째 템플릿 인수는 생성하려는 조인트 유형을 지정합니다. 우리의 "
"경우, 우리가 생성하려는 조인트 유형은 실제로 현재 함수의 템플릿 인수이므로 해당 인수를 전달하기만 하면 됩니다. "
"``createJointAndBodyNodePair``의 두 번째 템플릿 인수를 사용하면 생성하려는 BodyNode 유형을 지정할 "
"수 있지만 기본 인수는 표준 강체 BodyNode이므로 두 번째 인수를 비워 둘 수 있습니다."

#: ../../tutorials/collisions.md:143 23f2b8bcd78748deb8329dc3d4a1dc48
msgid "``(parent, joint_properties, BodyNode::AspectProperties(name))``"
msgstr ""

#: ../../tutorials/collisions.md:145 2a1e5ae6d2eb4f3d899fde571d7397af
msgid ""
"Now for the function arguments: The first specifies the parent BodyNode. "
"In the event that you want to create a root BodyNode, you can simply pass"
" in a nullptr as the parent. The second argument is a "
"``JointType::Properties`` struct, so we pass in the ``joint_properties`` "
"object that we created earlier. The third argument is a "
"``BodyNode::Properties`` struct, but we're going to set the BodyNode "
"properties later, so we'll just toss the name in by wrapping it up in a "
"``BodyNode::AspectProperties`` object and leave the rest as default "
"values."
msgstr ""
"이제 함수 인수에 대해 설명합니다. 첫 번째 인수는 상위 BodyNode를 지정합니다. 루트 BodyNode를 생성하려는 경우 "
"nullptr을 부모로 전달하기만 하면 됩니다. 두 번째 인수는 ``JointType::Properties`` 구조체이므로 이전에 "
"생성한 ``joint_properties`` 개체를 전달합니다. 세 번째 인수는 ``BodyNode::Properties`` "
"구조체이지만 BodyNode 속성은 나중에 설정할 것이므로 이름을 ``BodyNode::AspectProperties`` 객체로 "
"감싸서 넣고 나머지는 기본값으로 두겠습니다."

#: ../../tutorials/collisions.md:153 66747d9fc5e24e4584dacdea9387c588
msgid "Now notice the very last thing on this line of code:"
msgstr "이제 이 코드 줄의 마지막 내용을 확인하세요."

#: ../../tutorials/collisions.md:155 d15daa5c72d54eccbb88a0f942523c9b
msgid "``.second;``"
msgstr ""

#: ../../tutorials/collisions.md:157 e92e831987b34b4d8c7b9dfe8a246cde
msgid ""
"The function actually returns a ``std::pair`` of pointers to the new "
"Joint and new BodyNode that were just created, but we only care about "
"grabbing the  BodyNode once the function is finished, so we can append "
"``.second`` to the end of the line so that we just grab the BodyNode "
"pointer and ignore the Joint  pointer. The joint will of course still be "
"created; we just have no need to  access it at this point."
msgstr ""
"함수는 실제로 방금 생성된 새 Joint 및 새 BodyNode에 대한 포인터의 ``std::pair``를 반환하지만 함수가 완료된"
" 후에 BodyNode를 잡는 것에만 관심이 있으므로 줄 끝에 ``.second``를 추가하여 BodyNode 포인터를 잡고 "
"Joint 포인터를 무시할 수 있습니다. 물론 조인트는 계속 생성됩니다. 지금은 액세스할 필요가 없습니다."

#: ../../tutorials/collisions.md:164 808e5926f4e1474597406b4ec006f0a8
msgid "Lesson 1c: Make a shape for the body"
msgstr "1c단원: 몸체 모양 만들기"

#: ../../tutorials/collisions.md:166 11c9bf1b994f4892b383208c470614a1
msgid ""
"We'll take advantage of the Shape::ShapeType enumeration to specify what "
"kind of Shape we want to produce for the body. In particular, we'll allow"
" the user to specify three types of Shapes: ``Shape::BOX``, "
"``Shape::CYLINDER``, and ``Shape::ELLIPSOID``."
msgstr ""
"Shape::ShapeType 열거형을 활용하여 몸체에 대해 어떤 종류의 Shape를 생성할지 지정합니다. 특히, 사용자는 "
"``Shape::BOX``, ``Shape::CYLINDER`` 및 ``Shape::ELLIPSOID``의 세 가지 유형의 모양을 "
"지정할 수 있습니다."

#: ../../tutorials/collisions.md:189 d5414364f8bd4432a196872155a17964
msgid ""
"``ShapePtr`` is simply a typedef for ``std::shared_ptr<Shape>``. DART has"
" this typedef in order to improve space usage and readability, because "
"this type gets used very often."
msgstr ""
"``ShapePtr``은 단순히 ``std::shared_ptr<Shape>``에 대한 형식 정의입니다. DART에는 공간 활용과 "
"가독성을 높이기 위해 이 유형 정의가 있습니다. 이 유형은 매우 자주 사용되기 때문입니다."

#: ../../tutorials/collisions.md:193 e80380da8be04822a6bd011644452f24
msgid ""
"Now we want to construct each of the Shape types within their conditional"
" statements. Each constructor is a bit different."
msgstr "이제 조건문 내에서 각 Shape 유형을 구성하려고 합니다. 생성자마다 조금씩 다릅니다."

#: ../../tutorials/collisions.md:196 eb48eac7a4d1452c821e8c11dac2a817
msgid ""
"For box shapes we pass a vector that contains the three dimensions of the"
" box. The cylinder branch uses a radius and height, and the ellipsoid "
"branch consumes the three axis lengths. Since we actually want a sphere, "
"all three axis lengths will be equal, so we can create a vector filled "
"with ones and then multiply it by the length that we actually want for "
"the three components."
msgstr ""
"상자 모양에는 상자의 세 변을 담은 벡터를 넘겨주고, 실린더 분기에서는 반지름과 높이를, 타원체 분기에서는 세 축 길이를 "
"사용합니다. 여기서는 구를 만들고자 하므로 세 축 길이가 모두 동일해야 합니다. 따라서 ``math::Vector3d::Ones()``로 "
"1로 채워진 벡터를 만들고 거기에 원하는 길이를 곱해 세 구성 요소를 한꺼번에 설정할 수 있습니다."

#: ../../tutorials/collisions.md:202 fc5ef2d1c81344d8838414f924997b2b
msgid ""
"Finally, we want to add this shape as a visualization **and** collision "
"shape for the BodyNode:"
msgstr "마지막으로 이 모양을 BodyNode의 시각화 **및** 충돌 모양으로 추가하려고 합니다."

#: ../../tutorials/collisions.md:223 6bda4f8abc5a4de0b7217fb4ff3eb8c3
msgid ""
"We want to do this no matter which type was selected, so those two lines "
"of code should be after all the condition statements."
msgstr "어떤 유형을 선택했는지에 관계없이 이 작업을 수행하기를 원하므로 해당 두 줄의 코드는 모든 조건문 뒤에 있어야 합니다."

#: ../../tutorials/collisions.md:226 ad33158aebc24722b8c88507d7c1c7eb
msgid "Lesson 1d: Set up the inertia properties for the body"
msgstr "1d단원: 몸체의 관성 속성 설정"

#: ../../tutorials/collisions.md:228 ecb32aebd34742c39dda5b647da1ba8d
msgid ""
"For the simulations to be physically accurate, it's important for the "
"inertia properties of the body to match up with the geometric properties "
"of the shape. We can create an ``Inertia`` object and set its values "
"based on the shape's geometry, then give that ``Inertia`` to the "
"BodyNode."
msgstr ""
"시뮬레이션이 물리적으로 정확하려면 몸체의 관성 속성이 모양의 기하학적 속성과 일치하는 것이 중요합니다. ``관성`` 개체를 만들고 "
"모양의 기하학적 구조에 따라 값을 설정한 다음 해당 ``관성``을 BodyNode에 제공할 수 있습니다."

#: ../../tutorials/collisions.md:251 6f7ae4e8ff1941fd93acbcde85b594a1
msgid "Lesson 1e: Set the coefficient of restitution"
msgstr "1e단원: 복원 계수 설정"

#: ../../tutorials/collisions.md:253 cddd6a444f2a4ac4b14959f5d5d3131a
msgid "This is very easily done with the following function:"
msgstr "이는 다음 기능을 사용하면 매우 쉽게 수행됩니다."

#: ../../tutorials/collisions.md:273 4cb873db7def4726baee01d8bff25548
msgid "Lesson 1f: Set the damping coefficient"
msgstr "레슨 1f: 감쇠 계수 설정"

#: ../../tutorials/collisions.md:275 52d176b0104f44efb5c72db6dd54e8c4
msgid ""
"In real life, joints have friction. This pulls energy out of systems over"
" time, and makes those systems more stable. In our simulation, we'll "
"ignore air friction, but we'll add friction in the joints between bodies "
"in order to have better numerical and dynamic stability:"
msgstr ""
"실생활에서 관절에는 마찰이 있습니다. 이는 시간이 지남에 따라 시스템에서 에너지를 끌어내고 해당 시스템을 더욱 안정적으로 만듭니다."
" 시뮬레이션에서는 공기 마찰을 무시하지만 더 나은 수치적 및 동적 안정성을 얻기 위해 몸체 사이의 관절에 마찰을 추가할 것입니다."

#: ../../tutorials/collisions.md:298 4a385f7847f143af96ba57a5c7181bb4
msgid ""
"If this BodyNode has a parent BodyNode, then we set damping coefficients "
"of its Joint to a default value."
msgstr "이 BodyNode에 상위 BodyNode가 있는 경우 해당 조인트의 감쇠 계수를 기본값으로 설정합니다."

#: ../../tutorials/collisions.md:301 b672afdae36f43919d21b872d5fca16f
msgid "Lesson 2: Creating a soft body"
msgstr "단원 2: 부드러운 몸체 만들기"

#: ../../tutorials/collisions.md:303 40707cccf76a4ffc903f766fbd8c4ae8
msgid ""
"Find the templated function named ``addSoftBody``. This function will "
"have a role identical to the ``addRigidBody`` function from earlier."
msgstr ""
"``addSoftBody``라는 템플릿 함수를 찾으세요. 이 함수는 이전의 ``addRigidBody`` 함수와 동일한 역할을 "
"합니다."

#: ../../tutorials/collisions.md:307 4ccf28eaf80d42ab878861d512e0eec8
msgid ""
"Soft body helpers are currently exposed only in the C++ API. The dartpy "
"snippets approximate the same structure by reusing rigid BodyNodes with "
"matching geometry and transparency so you can follow along with each "
"lesson."
msgstr ""

#: ../../tutorials/collisions.md:312 e4d185542caa42ef9adbe36649ab5bd6
msgid "Lesson 2a: Set the Joint properties"
msgstr "2a단원: 접합 속성 설정"

#: ../../tutorials/collisions.md:314 42f96e8ceb3041f5ad11df91ed8f7192
msgid ""
"This portion is exactly the same as Lesson 1a. You can even copy the code"
" directly from there if you'd like to."
msgstr "이 부분은 Lesson 1a와 완전히 동일합니다. 원하는 경우 거기에서 직접 코드를 복사할 수도 있습니다."

#: ../../tutorials/collisions.md:317 a3ce5300489d419d8b8b19a5dae999e9
msgid "Lesson 2b: Set the properties of the soft body"
msgstr "2b단원: 연체의 속성 설정"

#: ../../tutorials/collisions.md:319 0de8fee6e92a4227863e87b4e0f1171a
msgid ""
"Last time we set the BodyNode properties after creating it, but this time"
" we'll set them beforehand."
msgstr "지난번에는 BodyNode 속성을 생성한 후 설정했지만 이번에는 미리 설정해 보겠습니다."

#: ../../tutorials/collisions.md:322 88e9d5a651f3439797c300453f2f94be
msgid ""
"First, let's create a struct for the properties that are unique to "
"SoftBodyNodes. Up above we defined an enumeration for a couple different "
"SoftBodyNode types. There is no official DART-native enumeration for "
"this, we created our own to use for this function. We'll want to fill in "
"the ``SoftBodyNode::UniqueProperties`` struct based off of this "
"enumeration."
msgstr ""
"먼저 SoftBodyNode에만 적용되는 속성을 담을 구조체를 만들겠습니다. 위쪽에서 여러 SoftBodyNode 유형에 대한 "
"열거형을 정의했는데, 이는 DART에서 기본으로 제공하는 값이 아니므로 이번 함수에서 사용하려고 직접 만든 것입니다. 이 "
"열거형을 기준으로 ``SoftBodyNode::UniqueProperties`` 구조체를 채워봅시다."

#: ../../tutorials/collisions.md:346 f444be1e938b47659ef2b599e7663c7c
msgid ""
"Each of the C++ conditionals leverages ``SoftBodyNodeHelper`` to "
"construct the skin and its mass distribution (feel free to experiment "
"with slice/stack counts, keeping in mind the minimum values noted in the "
"comments). The dartpy implementation currently falls back to creating a "
"rigid shell with matching geometry because SoftBody nodes are not yet "
"exposed, but the remainder of the lesson still applies."
msgstr ""
"각 C++ 조건문은 ``SoftBodyNodeHelper`` 를 사용해 껍데기와 질량 분포를 구성합니다. 주석에 적힌 최소값만 "
"유지한다면 슬라이스/스택 개수는 자유롭게 실험해도 됩니다. 아직 SoftBody 노드가 dartpy에 노출되지 않았기 때문에 "
"파이썬 구현은 동일한 형상의 강체 셸을 만드는 방식으로 대체되지만, 이후 단계는 그대로 적용됩니다."

#: ../../tutorials/collisions.md:353 7ac1876bba474be7a3aef506f6ccdec0
msgid "Lesson 2c: Create the Joint and Soft Body pair"
msgstr "단원 2c: 조인트 및 소프트 바디 쌍 만들기"

#: ../../tutorials/collisions.md:355 37b2827e172e4d1595b439379d70c666
msgid ""
"This step is very similar to Lesson 1b, except now we'll want to specify "
"that we're creating a soft BodyNode. First, let's create a full  "
"``SoftBodyNode::Properties``. This will combine the ``UniqueProperties`` "
"of the SoftBodyNode with the standard properties of a BodyNode. Now we "
"can pass the whole thing into the creation function:"
msgstr ""
"이 단계는 1b단원과 매우 비슷하지만, 이번에는 소프트 BodyNode를 생성한다는 점을 명시해야 합니다. 먼저 전체 "
"``SoftBodyNode::Properties`` 를 구성합니다. 이렇게 하면 SoftBodyNode의 "
"``UniqueProperties`` 와 일반 BodyNode 속성이 결합됩니다. 이제 이 전체 구조체를 생성 함수에 그대로 넘길 수 "
"있습니다:"
"이 단계는 소프트 BodyNode를 생성한다는 점을 지정한다는 점을 제외하고는 1b과와 매우 유사합니다. 먼저 전체 "
"``SoftBodyNode::Properties``를 만들어 보겠습니다."

#: ../../tutorials/collisions.md:379 f9cb821e4d7a40479fa602ba32a67530
msgid ""
"Notice that this time it will return a ``SoftBodyNode`` pointer rather "
"than a normal ``BodyNode`` pointer. This is one of the advantages of "
"templates!"
msgstr ""
"이번에는 일반적인 ``BodyNode`` 포인터가 아닌 ``SoftBodyNode`` 포인터를 반환한다는 점에 유의하세요. 템플릿의"
" 장점 중 하나죠!"

#: ../../tutorials/collisions.md:382 8b352b2f38744919a63df29955f26ff9
msgid "Lesson 2d: Zero out the BodyNode inertia"
msgstr "2d단원: BodyNode 관성 제로화"

#: ../../tutorials/collisions.md:384 e8fd580d4da84f8780ea8b8fb15813d4
msgid ""
"A SoftBodyNode has two sources of inertia: the underlying inertia of the "
"standard BodyNode class, and the point mass inertias of its soft skin. In"
" our case, we only want the point mass inertias, so we should zero out "
"the standard BodyNode inertia. However, zeroing out inertia values can be"
" very dangerous, because it can easily result in singularities. So "
"instead of completely zeroing them out, we will just make them small "
"enough that they don't impact the simulation:"
msgstr ""
"SoftBodyNode에는 두 가지 관성 소스, 즉 표준 BodyNode 클래스의 기본 관성과 소프트 스킨의 점질량 관성이 "
"있습니다. 우리의 경우에는 점 질량 관성만 원하므로 표준 BodyNode 관성을 0으로 설정해야 합니다. 그러나 관성 값을 0으로 "
"만드는 것은 쉽게 특이점을 초래할 수 있으므로 매우 위험할 수 있습니다. 따라서 완전히 0으로 만드는 대신 시뮬레이션에 영향을 주지"
" 않을 만큼 작게 만듭니다."

#: ../../tutorials/collisions.md:410 5d9b59e89cb445d2be4a975f955b9f6f
msgid "Lesson 2e: Make the shape transparent"
msgstr "2e단원: 모양을 투명하게 만들기"

#: ../../tutorials/collisions.md:412 bbe667d62cba4dd1a855f8ec56a0373d
msgid ""
"To help us visually distinguish between the soft and rigid portions of a "
"body, we can make the soft part of the shape transparent. Upon creation, "
"a SoftBodyNode will have exactly one visualization shape: the soft shape "
"visualizer. We can reduce the value of its alpha channel (or directly "
"call ``setAlpha`` in dartpy) so it stands out from the rigid pieces:"
msgstr ""
"몸체의 연체 부분과 강체 부분을 시각적으로 구분하기 위해 Shape의 연체 부분 투명도를 낮출 수 있습니다. SoftBodyNode가 "
"생성되면 기본적으로 연체 시각화 Shape 하나만 갖습니다. 이 모양을 선택해 알파 채널 값을 줄이거나 dartpy에서는 "
"``setAlpha`` 를 직접 호출해 강체 파트와 구분되도록 만들 수 있습니다."

#: ../../tutorials/collisions.md:436 30e5705ceea741bb8089e6e555f5c6a8
msgid "Lesson 2f: Give a hard bone to the SoftBodyNode"
msgstr "2f단원: SoftBodyNode에 단단한 뼈대 제공"

#: ../../tutorials/collisions.md:438 7a14f692c8344a68beb7d5526df7afb6
msgid ""
"SoftBodyNodes are intended to be used as soft skins that are attached to "
"rigid bones. We can create a rigid shape, place it in the SoftBodyNode, "
"and give some inertia to the SoftBodyNode's base BodyNode class, to act "
"as the inertia of the bone."
msgstr ""
"SoftBodyNodes는 단단한 뼈에 부착된 부드러운 스킨으로 사용되도록 만들어졌습니다. 고정된 모양을 만들어 "
"SoftBodyNode에 배치한 다음 SoftBodyNode의 기본 BodyNode 클래스에 약간의 관성을 부여하여 뼈의 관성 "
"역할을 할 수 있습니다."

#: ../../tutorials/collisions.md:443 2ae017f6723e4d8aa229dc3e149b1115
msgid ""
"Find the function ``createSoftBody()``. Underneath the call to "
"``addSoftBody``, we can create a box shape that matches the dimensions of"
" the soft box, but scaled down:"
msgstr ""
"``createSoftBody()`` 함수를 찾으세요. ``addSoftBody`` 호출 아래에서 소프트 박스의 크기와 일치하지만 "
"크기가 축소된 상자 모양을 만들 수 있습니다."

#: ../../tutorials/collisions.md:465 46c4f39e11b944b3861a942e81cb01e9
msgid ""
"After adding the rigid geometry, set its inertia so the simulation stays "
"physically reasonable. The dartpy version follows the same pattern using "
"the fallback rigid node."
msgstr ""

#: ../../tutorials/collisions.md:469 d731f4a8ae6c48cb8e5344216ec88819
msgid ""
"Note that the inertia of the inherited BodyNode is independent of the "
"inertia of the SoftBodyNode's skin."
msgstr "상속된 BodyNode의 관성은 SoftBodyNode 스킨의 관성과 무관합니다."

#: ../../tutorials/collisions.md:472 ff3b5921f05f4b48bbf58f477378eb8d
msgid "Lesson 2g: Add a rigid body attached by a WeldJoint"
msgstr "2g단원: WeldJoint로 연결된 강체 추가"

#: ../../tutorials/collisions.md:474 fe241a2930cc45adbef3b361204d1099
msgid ""
"To make a more interesting hybrid shape, we can attach a protruding rigid"
" body to a SoftBodyNode using a WeldJoint. Find the "
"``createHybridBody()`` function and see where we call the ``addSoftBody``"
" function. Just below this, we'll create a new rigid body with a "
"WeldJoint attachment:"
msgstr ""
"보다 흥미로운 하이브리드 모양을 만들기 위해 WeldJoint를 사용하여 돌출된 강체를 SoftBodyNode에 연결할 수 "
"있습니다. ``createHybridBody()`` 함수를 찾아 ``addSoftBody`` 함수를 호출하는 위치를 확인하세요. "
"바로 아래에 WeldJoint가 부착된 새 강체를 만듭니다."

#: ../../tutorials/collisions.md:497 485d553040114a22aa6ef6247b84bf0a
msgid ""
"Now we can give the new rigid BodyNode a box, offset it away from the "
"center of its parent so it protrudes, and set its inertia so that "
"collisions behave as expected."
msgstr ""

#: ../../tutorials/collisions.md:501 00a9cf3a1f2c4afeb1d597297bfbe002
msgid "Lesson 3: Setting initial conditions and taking advantage of Frames"
msgstr "학습 3: 초기 조건 설정 및 프레임 활용"

#: ../../tutorials/collisions.md:503 3f5a11a5fbe64b35a70d572a0500a3cc
msgid ""
"Find the ``addObject`` function in the ``MyWorld`` class. This function "
"will be called whenever the user requests for an object to be added to "
"the world. In this function, we want to set up the initial conditions for"
" the object so that it gets thrown at the wall. We also want to make sure"
" that it's not in collision with anything at the time that it's added, "
"because that would result in problems for the simulation."
msgstr ""
"``MyWorld`` 클래스에서 ``addObject`` 함수를 찾으세요. 이 함수는 사용자가 객체를 세계에 추가하도록 요청할 "
"때마다 호출됩니다. 이 함수에서는 물체가 벽에 던져질 수 있도록 물체의 초기 조건을 설정하려고 합니다. 또한 추가할 때 어떤 것과도"
" 충돌하지 않는지 확인하고 싶습니다. 그렇게 하면 시뮬레이션에 문제가 발생할 수 있기 때문입니다."

#: ../../tutorials/collisions.md:510 dc3f75f14d7d4175be218dd4f9f34cec
msgid "Lesson 3a: Set the starting position for the object"
msgstr "학습 3a: 개체의 시작 위치 설정"

#: ../../tutorials/collisions.md:512 4b696443a4584d6ab19e5ab71ff96227
msgid ""
"We want to position the object in a reasonable place for us to throw it "
"at the wall. We also want to have the ability to randomize its location "
"along the y-axis."
msgstr ""
"우리는 벽에 던질 수 있는 적당한 위치에 물체를 배치하고 싶습니다. 우리는 또한 y축을 따라 위치를 무작위로 지정하는 기능을 "
"원합니다."

#: ../../tutorials/collisions.md:515 12e0ef77f47343a5925d11a84d91d085
msgid "First, let's create a zero vector for the position:"
msgstr "먼저 위치에 대한 0 벡터를 만들어 보겠습니다."

#: ../../tutorials/collisions.md:520 7e6c759959834f45af3d1b8a63bdfa93
msgid ""
"You'll notice that this is an math::Vector**6**d rather than the usual "
"math::Vector**3**d. This vector has six components because the root "
"BodyNode has 6 degrees of freedom: three for orientation and three for "
"translation. Because we follow Roy Featherstone's Spatial Vector "
"convention, the **first** three components are for **orientation** using "
"a logmap (also known as angle-axis) and the **last** three components are"
" for **translation**."
msgstr ""
"이것은 일반적인 math::Vector**3**d가 아니라 math::Vector**6**d라는 것을 알 수 있습니다. 루트 "
"BodyNode에는 6개의 자유도(방향에 3개, 변환에 3개)가 있으므로 이 벡터에는 6개의 구성요소가 있습니다. Roy "
"Featherstone의 공간 벡터 규칙을 따르기 때문에 **처음** 세 구성요소는 로그맵(각도 축이라고도 함)을 사용한 "
"**방향**용이고 **마지막** 세 구성요소는 **변환**용입니다."

#: ../../tutorials/collisions.md:527 ce38acbdfa03486d9460dfc22011b23c
msgid ""
"First, if randomness is turned on, we'll set the y-translation to a "
"randomized value and then set the height to the default value before "
"applying the vector to the root FreeJoint. The helper below shows the "
"full block."
msgstr ""

#: ../../tutorials/collisions.md:549 92a44e9f25574e44854b2ff7991f05d4
msgid ""
"We trust that the root Joint is a FreeJoint with 6 degrees of freedom "
"because of how we constructed all the objects that are going to be thrown"
" at the wall: They were all given a FreeJoint between the world and the "
"root BodyNode."
msgstr ""
"우리는 벽에 던져질 모든 객체를 어떻게 구성했는가로 인해 루트 관절이 6 자유도를 가진 FreeJoint라고 믿습니다. 객체는 모두"
" 월드와 루트 BodyNode 사이에 FreeJoint가 주어졌습니다."

#: ../../tutorials/collisions.md:553 d2d36e4d8c3b4055a12c23c1f3375200
msgid "Lesson 3b: Set the object's name"
msgstr "3b단원: 개체 이름 설정"

#: ../../tutorials/collisions.md:555 d068364dbd924a0e9100f669e8c681a9
msgid ""
"Every object in the world is required to have a non-empty unique name. "
"Just like Joint names in a Skeleton, if we pass a Skeleton into a world "
"with a non-unique name, the world will print out a complaint to us and "
"then rename it. So avoid the ugly printout, we'll make sure the new "
"object has a unique name ahead of time:"
msgstr ""
"전 세계의 모든 객체에는 비어 있지 않은 고유 이름이 있어야 합니다. 스켈레톤의 공동 이름과 마찬가지로, 고유하지 않은 이름을 가진"
" 스켈레톤을 월드에 전달하면 월드는 우리에게 불만 사항을 인쇄한 다음 이름을 바꿉니다. 따라서 보기 흉한 인쇄 결과를 방지하고 새 "
"개체에 고유한 이름이 있는지 미리 확인하겠습니다."

#: ../../tutorials/collisions.md:578 206864b2125e4758936008bcdef20cf6
msgid "Lesson 3c: Add the object to the world without collisions"
msgstr "3c단원: 충돌 없이 월드에 개체 추가"

#: ../../tutorials/collisions.md:580 d472f597025243d7803d33a184852749
msgid ""
"Before we add the Skeleton to the world, we want to make sure that it "
"isn't actually placed inside of something accidentally. If an object in a"
"  simulation starts off inside of another object, it can result in "
"extremely non-physical simulations, perhaps even breaking the simulation "
"entirely. We can access the world's collision detector directly to check "
"make sure the new object is collision-free. If it isn't, we refuse to add"
" it and print a message explaining why."
msgstr ""
"스켈레톤을 월드에 추가하기 전에 다른 물체 내부에 실수로 배치되지 않았는지 반드시 확인해야 합니다. 시뮬레이션 개체가 다른 개체 "
"안에서 시작하면 물리적으로 터무니없는 결과가 나오거나 시뮬레이션이 완전히 망가질 수 있습니다. 월드의 충돌 감지기에 직접 접근해 "
"새 객체가 충돌 상태인지 확인하고, 충돌이 있으면 추가를 거부하면서 그 이유를 출력합니다."

#: ../../tutorials/collisions.md:606 a425a8f5fc784c32b01e7fb90ae922b7
msgid "Lesson 3d: Creating reference frames"
msgstr "3d과: 기준 좌표계 생성"

#: ../../tutorials/collisions.md:608 4546a3132efb4216bfd8b433602fb15a
msgid ""
"DART has a unique feature that we call Frame Semantics. The Frame "
"Semantics of DART allow you to create reference frames and use them to "
"get and set data relative to arbitrary frames. There are two crucial "
"Frame types currently used in DART: ``BodyNode``s and ``SimpleFrame``s."
msgstr ""
"DART에는 프레임 의미론이라는 고유한 기능이 있습니다. DART의 프레임 의미 체계를 사용하면 참조 프레임을 생성하고 이를 "
"사용하여 임의 프레임과 관련된 데이터를 가져오고 설정할 수 있습니다. 현재 DART에는 ``BodyNode``와 "
"``SimpleFrame``이라는 두 가지 중요한 프레임 유형이 사용됩니다."

#: ../../tutorials/collisions.md:613 1e7e6a19da7b48b581051d5140de1e3c
msgid ""
"The BodyNode class does not allow you to explicitly set its transform, "
"velocity, or acceleration properties, because those are all strictly "
"functions of the degrees of freedom that the BodyNode depends on. Because"
" of this, the BodyNode is not a very convenient class if you want to "
"create an arbitrary frame of reference. Instead, DART offers the "
"``SimpleFrame`` class which gives you the freedom of arbitrarily attaching"
" it to any parent Frame and setting its transform, velocity, and "
"acceleration to whatever you'd like. This makes SimpleFrame useful for "
"specifying arbitrary reference frames."
msgstr ""
"BodyNode 클래스에서는 변형, 속도 또는 가속도 속성을 명시적으로 설정할 수 없습니다. 이는 모두 BodyNode가 의존하는 "
"자유도의 함수이기 때문입니다. 이 때문에 BodyNode는 임의의 참조 프레임을 생성하려는 경우 매우 편리한 클래스가 아닙니다. "
"대신 DART는 상위 프레임에 임의로 연결하고 변환, 속도 및 가속도를 원하는 대로 설정할 수 있는 ``SimpleFrame`` "
"클래스를 제공합니다. 따라서 SimpleFrame은 임의의 참조 프레임을 지정하는 데 유용합니다."

#: ../../tutorials/collisions.md:622 eae3b82a523b4d899070dbff92258a6d
msgid ""
"We're going to set up a couple SimpleFrames and use them to easily "
"specify the velocity properties that we want the Skeleton to have. First,"
" we'll place a SimpleFrame at the Skeleton's center of mass:"
msgstr ""
"우리는 몇 개의 SimpleFrame을 설정하고 이를 사용하여 Skeleton에 원하는 속도 속성을 쉽게 지정할 것입니다. 먼저 "
"Skeleton의 질량 중심에 SimpleFrame을 배치합니다."

#: ../../tutorials/collisions.md:644 2acabeb3480349a58e3e36cfb9f90809
msgid ""
"Calling ``object->getCOM()`` will tell us the center of mass location "
"with respect to the World Frame. We use that to set the translation of "
"the SimpleFrame's relative transform so that the origin of the "
"SimpleFrame will be located at the object's center of mass."
msgstr ""
"``object->getCOM()``을 호출하면 월드 프레임에 대한 질량 중심 위치를 알려줍니다. 이를 사용하여 "
"SimpleFrame의 원점이 개체의 질량 중심에 위치하도록 SimpleFrame의 상대 변환 변환을 설정합니다."

#: ../../tutorials/collisions.md:649 2974f4a117ec4b2988acfd519cfba071
msgid ""
"Now we'll set what we want the object's angular and linear speeds to be. "
"We just use the default values unless randomization is turned on, then "
"convert those speeds into directional velocities and store them on the "
"SimpleFrame:"
msgstr ""
"이제 개체에 부여할 각속도와 선속도를 설정합니다. 무작위 옵션을 켜지 않았다면 기본값을 그대로 쓰고, 그렇지 않다면 해당 "
"속도들을 방향성 속도로 변환해 SimpleFrame에 저장합니다."

#: ../../tutorials/collisions.md:671 680f15805c56430884441bb40eebaa43
msgid ""
"The ``SimpleFrame::setClassicDerivatives()`` allows you to set the "
"classic linear and angular velocities and accelerations of a SimpleFrame "
"with respect to its parent Frame, which in this case is the World Frame. "
"In DART, classic velocity and acceleration vectors are explicitly "
"differentiated from spatial velocity and acceleration vectors. If you are"
" unfamiliar with the term \"spatial vector\", then you'll most likely "
"want to work in terms of classic velocity and acceleration."
msgstr ""
"``SimpleFrame::setClassicDerivatives()``를 사용하면 상위 프레임(이 경우에는 월드 프레임)에 대해 "
"SimpleFrame의 일반적인 선형 및 각속도와 가속도를 설정할 수 있습니다. DART에서는 일반적인 속도 및 가속도 벡터가 공간"
" 속도 및 가속도 벡터와 명시적으로 구분됩니다. \"공간 벡터\"라는 용어에 익숙하지 않다면 고전적인 속도와 가속도 측면에서 "
"작업하고 싶을 것입니다."

#: ../../tutorials/collisions.md:678 95ff22929b324275961c1c417c2a72f7
msgid ""
"Now we want to create a new SimpleFrame that will be a child of the "
"previous one, align it with the root BodyNode, and then use it to set the"
" root joint's spatial velocity:"
msgstr ""
"이제 앞서 만든 SimpleFrame을 부모로 두는 새 SimpleFrame을 만들어 루트 BodyNode와 정렬한 뒤, 이를 "
"사용해 루트 조인트의 공간 속도를 설정합니다."

#: ../../tutorials/collisions.md:700 fb2f65e2938b46a99184e07a96b52189
msgid ""
"Note that the FreeJoint uses spatial velocity and spatial acceleration "
"for its degrees of freedom."
msgstr "FreeJoint는 자유도를 위해 공간 속도와 공간 가속도를 사용합니다."

#: ../../tutorials/collisions.md:703 a68a42325f484da4aa7dec1264659551
msgid "Now we're ready to toss around objects!"
msgstr "이제 객체를 던질 준비가 되었습니다!"

#: ../../tutorials/collisions.md:705 d0f331b25bcf4b9aa4e8c01ac4ea8ed8
msgid "Lesson 4: Setting joint spring and damping properties"
msgstr "학습 4: 접합 스프링 및 감쇠 속성 설정"

#: ../../tutorials/collisions.md:707 7eb67909898343d98f1b8019676154a5
msgid ""
"Find the ``setupRing`` function. This is where we'll setup a chain of "
"BodyNodes so that it behaves more like a closed ring."
msgstr "``setupRing`` 기능을 찾으세요. 여기서는 닫힌 링처럼 작동하도록 BodyNodes 체인을 설정합니다."

#: ../../tutorials/collisions.md:710 317d85d6da3b4b22854da012665dab42
msgid "Lesson 4a: Set the spring and damping coefficients"
msgstr "4a단원: 스프링 및 감쇠 계수 설정"

#: ../../tutorials/collisions.md:712 6958adbe7ec24a1b8d741ba3487050c8
msgid ""
"We'll want to set the stiffness and damping coefficients of only the "
"DegreesOfFreedom that are **between** two consecutive BodyNodes. The "
"first six degrees of freedom are between the root BodyNode and the World,"
" so we don't want to change the stiffness of them, or else the object "
"will hover unnaturally in the air. But all the rest of the degrees of "
"freedom should be set:"
msgstr ""
"두 개의 연속 BodyNodes **사이**에 있는 DegreesOfFreedom의 강성과 감쇠 계수만 설정하려고 합니다. 처음 "
"6개의 자유도는 루트 BodyNode와 World 사이에 있으므로 이들의 강성을 변경하고 싶지 않습니다. 그렇지 않으면 개체가 "
"부자연스럽게 공중에 떠 있게 됩니다. 하지만 나머지 모든 자유도는 다음과 같이 설정되어야 합니다."

#: ../../tutorials/collisions.md:736 a06413bc72954badb62c1eb7725331dc
msgid "Lesson 4b: Set the rest positions of the joints"
msgstr "4b단원: 관절의 나머지 위치 설정"

#: ../../tutorials/collisions.md:738 bcf752584d5d482aa51ab2336753a9ad
msgid ""
"We want to make sure that the ring's rest position works well for the "
"structure it has. Using basic geometry, we know we can compute the "
"exterior angle on each edge of a polygon like so:"
msgstr ""
"우리는 링의 정지 위치가 그 구조에 잘 맞는지 확인하고 싶습니다. 기본 기하학을 사용하여 다음과 같이 다각형의 각 가장자리에 대한 "
"외부 각도를 계산할 수 있다는 것을 알고 있습니다."

#: ../../tutorials/collisions.md:760 3c3810e419614bc7b3f10381c4a5da55
msgid ""
"This loop converts each desired rotation into BallJoint positions and "
"sets the rest pose component-wise."
msgstr ""

#: ../../tutorials/collisions.md:763 23058889e68749239e080aa860b32d0e
msgid "Lesson 4c: Set the Joints to be in their rest positions"
msgstr "4c단원: 관절이 휴지 위치에 있도록 설정"

#: ../../tutorials/collisions.md:765 3e51923e032f4f0a935368a9323f7b06
msgid ""
"Finally, we should set the ring so that all the degrees of freedom (past "
"the root BodyNode) start out in their rest positions:"
msgstr "마지막으로 모든 자유도(루트 BodyNode를 지나)가 정지 위치에서 시작되도록 링을 설정해야 합니다."

#: ../../tutorials/collisions.md:786 a93e6a3d945b4b5586c040c398e0e967
msgid "Lesson 5: Create a closed kinematic chain"
msgstr "5단원: 닫힌 운동학적 체인 생성"

#: ../../tutorials/collisions.md:788 d14504e8be1345aeb8d3038518de6703
msgid ""
"Find the ``addRing`` function in ``MyWindow``. In here, we'll want to "
"create a dynamic constraint that attaches the first and last BodyNodes of"
" the chain together by a BallJoint-style constraint."
msgstr ""
"``MyWindow``에서 ``addRing`` 기능을 찾으세요. 여기서는 BallJoint 스타일 제약 조건을 통해 체인의 첫 "
"번째 BodyNodes와 마지막 BodyNodes를 함께 연결하는 동적 제약 조건을 생성하려고 합니다."

#: ../../tutorials/collisions.md:792 3bb2b8ee0164484e87165e5d704c6fa0
msgid ""
"First we'll grab the BodyNodes that we care about, compute the offset "
"where the BallJoint constraint should be located, create the constraint, "
"register it with the world's solver, and track it locally:"
msgstr ""

#: ../../tutorials/collisions.md:814 eb9fddefff6e41218cc7981c57bdc3de
msgid ""
"And that's it! You're ready to run the full tutorialCollisions "
"application!"
msgstr "그리고 그게 다야! 전체 튜토리얼Collisions 애플리케이션을 실행할 준비가 되었습니다!"

#: ../../tutorials/collisions.md:816 b5e1c9bfb38f4225be17431167e5810d
msgid ""
"**When running the application, keep in mind that the dynamics of "
"collisions are finnicky, so you may see some unstable and even completely"
" non-physical behavior. If the application freezes, you may need to force"
" quit out of it.**"
msgstr ""
"**애플리케이션을 실행할 때 충돌의 역학은 매우 까다롭기 때문에 일부 불안정하고 심지어 완전히 비물리적인 동작을 볼 수도 있다는 "
"점을 염두에 두십시오. 애플리케이션이 정지되면 강제로 종료해야 할 수도 있습니다.**"

#~ msgid "To create a ``Properties`` class for our Joint type, we'll want to say"
#~ msgstr "Joint 유형에 대한 ``Properties`` 클래스를 생성하려면 다음과 같이 말하고 싶습니다."

#~ msgid "Don't forget to uncomment the function arguments."
#~ msgstr "함수 인수의 주석 처리를 제거하는 것을 잊지 마십시오."

#~ msgid ""
#~ "Next we'll want to deal with "
#~ "offsetting the new BodyNode from its "
#~ "parent BodyNode. We can use the "
#~ "following to check if there is a"
#~ " parent BodyNode:"
#~ msgstr ""
#~ "다음으로 우리는 상위 BodyNode에서 새 BodyNode를 "
#~ "오프셋하는 작업을 처리하려고 합니다. 다음을 사용하여 상위"
#~ " BodyNode가 있는지 확인할 수 있습니다."

#~ msgid "Inside the brackets, we'll want to create the offset between bodies:"
#~ msgstr "괄호 안에 몸체 사이의 오프셋을 생성하려고 합니다."

#~ msgid ""
#~ "An ``math::Isometry3d`` is the Eigen "
#~ "library's version of a homogeneous "
#~ "transformation matrix. Here we are "
#~ "initializing it to an Identity matrix"
#~ " to start out. This is almost "
#~ "always something you should do when "
#~ "creating an math::Isometry3d, because "
#~ "otherwise its contents will be "
#~ "completely arbitrary trash."
#~ msgstr ""
#~ "``math::Isometry3d``는 Eigen 라이브러리 버전의 동종 "
#~ "변환 행렬입니다. 여기서는 시작하기 위해 Identity "
#~ "행렬로 초기화하고 있습니다. 이는 math::Isometry3d를 생성할"
#~ " 때 거의 항상 수행해야 하는 작업입니다. 그렇지 "
#~ "않으면 해당 내용이 완전히 임의의 쓰레기가 되기 "
#~ "때문입니다."

#~ msgid ""
#~ "We can easily compute the center "
#~ "point between the origins of the "
#~ "two bodies using our default height "
#~ "value:"
#~ msgstr "기본 높이 값을 사용하여 두 몸체의 원점 사이의 중심점을 쉽게 계산할 수 있습니다."

#~ msgid ""
#~ "We can then offset the parent and"
#~ " child BodyNodes of this Joint using"
#~ " this transform:"
#~ msgstr "그런 다음 이 변환을 사용하여 이 조인트의 상위 및 하위 BodyNode를 오프셋할 수 있습니다."

#~ msgid ""
#~ "For box we pass in an "
#~ "math::Vector3d that contains the three "
#~ "dimensions of the box:"
#~ msgstr "상자의 경우 상자의 세 가지 차원을 포함하는 math::Vector3d를 전달합니다."

#~ msgid "For cylinder we pass in a radius and a height:"
#~ msgstr "원통의 경우 반경과 높이를 전달합니다."

#~ msgid ""
#~ "For ellipsoid we pass in an "
#~ "math::Vector3d that contains the lengths "
#~ "of the three axes:"
#~ msgstr "타원체의 경우 세 축의 길이를 포함하는 math::Vector3d를 전달합니다."

#~ msgid ""
#~ "First, let's create a struct for "
#~ "the properties that are unique to "
#~ "SoftBodyNodes:"
#~ msgstr "먼저 SoftBodyNodes에 고유한 속성에 대한 구조체를 만들어 보겠습니다."

#~ msgid ""
#~ "Each of these types has a static"
#~ " function in the ``SoftBodyNodeHelper`` "
#~ "class that will set up your "
#~ "``UniqueProperties`` for you. The arguments"
#~ " for each of the functions are "
#~ "a bit complicated, so here is how"
#~ " to call it for each type:"
#~ msgstr ""
#~ "이러한 각 유형에는 ``SoftBodyNodeHelper`` 클래스에 "
#~ "``UniqueProperties``를 설정하는 정적 함수가 있습니다. "
#~ "각 함수에 대한 인수는 약간 복잡하므로 각 유형에"
#~ " 대해 호출하는 방법은 다음과 같습니다."

#~ msgid "For the SOFT_BOX:"
#~ msgstr "SOFT_BOX의 경우:"

#~ msgid "For the SOFT_CYLINDER:"
#~ msgstr "SOFT_CYLINDER의 경우:"

#~ msgid "And for the SOFT_ELLIPSOID:"
#~ msgstr "SOFT_ELLIPSOID의 경우:"

#~ msgid ""
#~ "Feel free to play around with the"
#~ " different parameters, like number of "
#~ "slices and number of stacks. However,"
#~ " be aware that some of those "
#~ "parameters have a minimum value, usually"
#~ " of 2 or 3. During runtime, you"
#~ " should be warned if you try to"
#~ " create one with a parameter that's"
#~ " too small."
#~ msgstr ""
#~ "슬라이스 수, 스택 수 등 다양한 매개변수를 "
#~ "자유롭게 사용해 보세요. 그러나 이러한 매개변수 중 "
#~ "일부에는 일반적으로 2 또는 3의 최소값이 있다는 "
#~ "점에 유의하십시오. 런타임 중에 너무 작은 매개변수를 "
#~ "사용하여 매개변수를 생성하려고 하면 경고를 받아야 합니다."

#~ msgid "Lastly, we'll want to fill in the softness coefficients:"
#~ msgstr "마지막으로 부드러움 계수를 입력하겠습니다."

#~ msgid ""
#~ "This will combine the ``UniqueProperties`` "
#~ "of the SoftBodyNode with the standard"
#~ " properties of a BodyNode. Now we "
#~ "can pass the whole thing into the"
#~ " creation function:"
#~ msgstr ""
#~ "이는 SoftBodyNode의 ``UniqueProperties``를 BodyNode의 "
#~ "표준 속성과 결합합니다. 이제 모든 것을 생성 "
#~ "함수에 전달할 수 있습니다."

#~ msgid ""
#~ "And then we can add that shape "
#~ "to the visualization and collision "
#~ "shapes of the SoftBodyNode, just like"
#~ " normal:"
#~ msgstr "그런 다음 평소와 같이 SoftBodyNode의 시각화 및 충돌 모양에 해당 모양을 추가할 수 있습니다."

#~ msgid ""
#~ "And we'll want to make sure that"
#~ " we set the inertia of the "
#~ "underlying BodyNode, or else the "
#~ "behavior will not be realistic:"
#~ msgstr "그리고 기본 BodyNode의 관성을 설정했는지 확인해야 합니다. 그렇지 않으면 동작이 현실적이지 않습니다."

#~ msgid "Now we can give the new rigid BodyNode a regular box shape:"
#~ msgstr "이제 새로운 강체 BodyNode에 일반 상자 모양을 지정할 수 있습니다."

#~ msgid ""
#~ "To make the box protrude, we'll "
#~ "shift it away from the center of"
#~ " its parent:"
#~ msgstr "상자를 돌출시키려면 상자를 부모의 중심에서 멀리 이동시킵니다."

#~ msgid ""
#~ "And be sure to set its inertia,"
#~ " or else the simulation will not "
#~ "be realistic:"
#~ msgstr "관성을 설정해야 합니다. 그렇지 않으면 시뮬레이션이 현실적이지 않습니다."

#~ msgid ""
#~ "First, if randomness is turned on, "
#~ "we'll set the y-translation to a "
#~ "randomized value:"
#~ msgstr "먼저 무작위성이 켜져 있으면 y-변환을 무작위 값으로 설정합니다."

#~ msgid ""
#~ "``mDistribution(mMT)`` will generate a random"
#~ " value in the range \\[-1, 1\\]  "
#~ "inclusive because of how we initialized"
#~ " the classes in the constructor of"
#~ " ``MyWindow``."
#~ msgstr ""
#~ "``mDistribution(mMT)``는 ``MyWindow`` 생성자에서 클래스를 "
#~ "초기화한 방식으로 인해 \\[-1, 1\\] 범위에서 임의의"
#~ " 값을 생성합니다."

#~ msgid "Then we always set the height to the default value:"
#~ msgstr "그런 다음 항상 높이를 기본값으로 설정합니다."

#~ msgid "Finally, we use this vector to set the positions of the root Joint:"
#~ msgstr "마지막으로 이 벡터를 사용하여 루트 관절의 위치를 ​​설정합니다."

#~ msgid ""
#~ "Now we shouldn't be surprised if "
#~ "the *other* objects are in collision "
#~ "with each other, so we'll need to"
#~ " check whether our new object "
#~ "overlaps with any existing objects.  "
#~ "First, we use the collision engine "
#~ "to create a group which contains "
#~ "our object. Then,  we get a group"
#~ " containing the existing objects in "
#~ "the world and use it to check "
#~ "for  collisions."
#~ msgstr ""
#~ "이제 *다른* 개체가 서로 충돌하더라도 놀라지 않아도 "
#~ "됩니다. 따라서 새 개체가 기존 개체와 겹치는지 "
#~ "확인해야 합니다.  먼저 충돌 엔진을 사용하여 개체를 "
#~ "포함하는 그룹을 만듭니다. 그런 다음 세계에 있는 "
#~ "기존 객체를 포함하는 그룹을 가져와 이를 사용하여 "
#~ "충돌을 확인합니다."

#~ msgid ""
#~ "If the new skeleton doesn't overlap "
#~ "an existing object, we can add it"
#~ " to the world without any complaints:"
#~ msgstr "새 스켈레톤이 기존 객체와 겹치지 않으면 아무런 불만 없이 월드에 추가할 수 있습니다."

#~ msgid ""
#~ "Of course we should also print out"
#~ " a message so that user understands"
#~ " why we didn't throw a new "
#~ "object."
#~ msgstr "물론 우리는 왜 우리가 새 객체를 던지지 않았는지 사용자가 이해할 수 있도록 메시지를 인쇄해야 합니다."

#~ msgid ""
#~ "Now we'll set what we want the "
#~ "object's angular and linear speeds to"
#~ " be:"
#~ msgstr "이제 객체의 각속도와 선형 속도를 원하는 대로 설정하겠습니다."

#~ msgid "We just use the default values unless randomization is turned on."
#~ msgstr "무작위화가 활성화되어 있지 않으면 기본값을 사용합니다."

#~ msgid "Now we'll convert those speeds into directional velocities:"
#~ msgstr "이제 해당 속도를 방향 속도로 변환하겠습니다."

#~ msgid ""
#~ "And now we'll use those vectors to"
#~ " set the velocity properties of the"
#~ " SimpleFrame:"
#~ msgstr "이제 이러한 벡터를 사용하여 SimpleFrame의 속도 속성을 설정하겠습니다."

#~ msgid ""
#~ "And we want the origin of this "
#~ "new Frame to line up with the "
#~ "root BodyNode of our object:"
#~ msgstr "그리고 우리는 이 새로운 프레임의 원점이 우리 객체의 루트 BodyNode와 일치하기를 원합니다."

#~ msgid ""
#~ "Now we'll use this reference frame "
#~ "to set the velocity of the root"
#~ " BodyNode. By setting the velocity of"
#~ " the root BodyNode equal to the "
#~ "velocity of this reference frame, we "
#~ "will ensure that the overall velocity"
#~ " of Skeleton's center of mass is "
#~ "equal to the velocity of the "
#~ "``center`` Frame from earlier."
#~ msgstr ""
#~ "이제 이 참조 프레임을 사용하여 루트 BodyNode의 "
#~ "속도를 설정하겠습니다. 루트 BodyNode의 속도를 이 참조"
#~ " 프레임의 속도와 동일하게 설정함으로써 스켈레톤 질량 "
#~ "중심의 전체 속도가 이전의 ``중심`` 프레임 속도와 "
#~ "동일하도록 보장합니다."

#~ msgid ""
#~ "Now it's important to remember that "
#~ "the joints we have between the "
#~ "BodyNodes are BallJoints, which use "
#~ "logmaps (a.k.a. angle-axis) to represent"
#~ " their positions. The BallJoint class "
#~ "provides a convenience function for "
#~ "converting rotations into a position "
#~ "vector for a BallJoint. A similar "
#~ "function also exists for EulerJoint and"
#~ " FreeJoint."
#~ msgstr ""
#~ "이제 BodyNode 사이에 있는 조인트는 로그맵(일명 각도"
#~ " 축)을 사용하여 위치를 나타내는 BallJoint라는 점을 "
#~ "기억하는 것이 중요합니다. BallJoint 클래스는 회전을 "
#~ "BallJoint의 위치 벡터로 변환하는 편리한 함수를 "
#~ "제공합니다. EulerJoint 및 FreeJoint에도 유사한 기능이"
#~ " 있습니다."

#~ msgid "Now we can set the rest positions component-wise:"
#~ msgstr "이제 나머지 위치를 구성요소별로 설정할 수 있습니다."

#~ msgid "First we'll grab the BodyNodes that we care about:"
#~ msgstr "먼저 관심 있는 BodyNodes를 가져옵니다."

#~ msgid ""
#~ "Now we want to compute the offset"
#~ " where the BallJoint constraint should "
#~ "be located:"
#~ msgstr "이제 BallJoint 제약 조건이 위치해야 하는 오프셋을 계산하려고 합니다."

#~ msgid ""
#~ "The offset will be located half "
#~ "the default height up from the "
#~ "center of the tail BodyNode."
#~ msgstr "오프셋은 꼬리 BodyNode 중심에서 위쪽으로 기본 높이의 절반 위치에 위치합니다."

#~ msgid "Now we have everything we need to construct the constraint:"
#~ msgstr "이제 제약 조건을 구성하는 데 필요한 모든 것이 준비되었습니다."

#~ msgid ""
#~ "In order for the constraint to "
#~ "work, we'll need to add it to "
#~ "the world's constraint solver:"
#~ msgstr "제약 조건이 작동하려면 이를 월드의 제약 조건 솔버에 추가해야 합니다."

#~ msgid ""
#~ "And in order to properly clean up"
#~ " the constraint when removing BodyNodes,"
#~ " we'll want to add it to our"
#~ " list of constraints:"
#~ msgstr "BodyNodes를 제거할 때 제약 조건을 적절하게 정리하려면 이를 제약 조건 목록에 추가해야 합니다."
